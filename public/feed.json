{"title":"王西柚","description":"王西柚,昏昏沉沉,不知其所以然.","language":"","link":"https://wangdabaoqq.github.io/hexo-back-up","pubDate":"Mon, 30 Jul 2018 02:37:00 GMT","lastBuildDate":"Thu, 31 Jan 2019 03:09:20 GMT","generator":"hexo-generator-json-feed","webMaster":"王西柚","items":[{"title":"'underscore系列之函数防抖\"'","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/07/30/underscore系列之函数防抖/","description":"稍等","pubDate":"Mon, 30 Jul 2018 02:37:00 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/07/30/underscore系列之函数防抖/","category":"underscore.js"},{"title":"'underscore系列之throttle\"'","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/07/25/underscore系列之函数节流/","description":"underscore函数节流前言 在说underscore函数节流之前, 还是明确概念, 什么是函数节流。函数节流简单来说就是&#39;开源节流&#39;, 什么意思呢？就是减少某个函数调用的太频繁, 降低频次。一般来讲, 对于dom的频繁操作会引起浏览器的重绘或者重排, 这个时候我们就可以来使用节流不要让他过快的操作dom, 从而页面渲染起来也会更加流畅。 举个场景: dom元素的移动与拖拽, 我默认都做过这个功能。对于dom元素的频繁拖拽, 对于一些性能不太好的浏览器(说的就是你IE)会有很大的损耗, 这个时候我们就可以适当的去降低这个事件的调用频次。 当然调用的频次也要有一个合适的阈值。不然也会引出意外的问题。。。 underscore函数throttle 上面提到了函数调用频次, 这个频次也就是调用时间, 所以在underscore中关于throttle函数是基于定时器与时间差来调用函数运行的频次。还有就是throttle函数接收三个参数, 关于最后一个参数我到最后再讲。 我们看下源码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var now = Date.now || function() &#123; return new Date().getTime();&#125;;var throttle = function(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = this.now(); if (!previous &amp;&amp; options.leading === false) previous = now; // console.log(previous) var remaining = wait - (now - previous); // console.log(remaining); // console.log(remaining) context = this; args = arguments; // remaining &gt; wait 表示客户端系统时间被调整过 if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; // timeout = null设置为null，不仅仅是为了防止内存泄漏，而是clearTimeout(timeout)后，timeout的值并不会清空，如果不设置为null，就不能根据!timeout设置下次的timeout &#125; previous = now; result = func.apply(context, args); // console.log(result) if (!timeout) context = args = null; // 这里不太明白, timeout 不是已经赋值为null了吗 // context = args = null; 引用值为空, 防止内存泄露。 &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; // console.log(remaining); timeout = setTimeout(later, remaining); // console.log(later, remaining) &#125; return result; &#125;; throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = context = args = null; &#125;; return throttled;&#125;; var func = function () &#123; console.log('wangdaye')&#125;window.onscroll = throttle(func, 1000); 我从自己的角度分析下: 首先滚动进入throttle函数携带两个参数, 函数内定义变量先不管, 直接说throttled函数, 首先要获取当前时间, 然后就是计算时间差, 当然第一次调用我们肯定是不希望要延迟加载, 所以变量remaining一定是负值, 获取最新时间戳, 然后调用函数。当连续调用时, 变量remaining是一个正值, 然后定时器延迟调用later方法, 刷新时间戳, timeout为null。当等待一秒钟再次调用时remaining为负值, 且已经存在timeout, 所以清空上一次定时器, timeout并为null。 我再说说关于第三个参数, 第三个参数有两种调用方式, 第一种是, {leading: false}, 当传递的方式的为{leading: false}就会忽略scroll开始前的回调。第二种方式是, {trailing: false}, 当传递方式为{trailing: false}时, scroll结束时会被忽略。 最后我还是希望可以debugger或者console.log下, 自己多去理解下, 我相信就会更加明白关于函数节流的知识点。 就到这了。。。。 参考 underscore 函数节流的实现-hanzichi 浅谈javascript的函数节流","pubDate":"Wed, 25 Jul 2018 11:37:00 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/07/25/underscore系列之函数节流/","category":"underscore.js"},{"title":"'underscore系列之无耦合函数\"'","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/07/20/underscore系列之无耦合函数/","description":"无耦合函数 无耦合函数: 叫无耦合函数可能不太准确, 之所以叫无耦合函数, 我想的是把underscore函数方法没有在其他函数中调用的方法, 所以就先暂时叫无耦合函数. 如果这样理解我在订正. 判断传入的参数是否为数组1234// 当如果支持es5时, 采用Array.isArray。反之采用第二次。var isArray = Array.isArray || function(obj) &#123; return toString.call(obj) === '[object Array]';&#125; 判断为DOM元素12345var isElement = function (obj) &#123; // 当obj为undefined或者null或者为空是, 转换为false返回。 // nodeType === 1时代表为一个元素节点如`&lt;p&gt;&lt;/p&gt;`和`&lt;div&gt;&lt;/div&gt;` return !!(obj &amp;&amp; obj.nodeType === 1);&#125;","pubDate":"Fri, 20 Jul 2018 08:37:00 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/07/20/underscore系列之无耦合函数/","category":"underscore.js"},{"title":"'Yellow + 流星'","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/07/19/yellow+流星/","description":"","pubDate":"Thu, 19 Jul 2018 04:37:00 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/07/19/yellow+流星/","category":"yellow"},{"title":"'underscore系列之比较两个元素是否\"相同\"'","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/07/15/underscore系列之比较两个元素是否相同/","description":"比较两个元素是否相同前言 之前就说过要读一下关于underscore.js的源码, 我就想先从某个函数开始读, 正好在github文章中(这里的文章我会在最后放上地址)提到了underscore中关于如何比较两个元素的是否相同, 我看完之后觉得很好玩。那么对于如何判断两个元素是否是相同呢？那么在什么程度上才算是相同, 举个例子: 1与1是相等的(当然他们前提是类型是一样的)那么1和 new Number(1)也应该相等。 underscore中有这么一个函数_.isEqual对没错, 就是这个。接下来我会以自己的知识来解释下, 这个函数的涉及的知识点。 如果有解释的不好的点, 请大家给我留言我一定改正。话不多说直接开始。 分析_.isEqualNumber类型判断 console.log( _.isEqual(a, b)); 我首先在 _.isEqual中传入了两个参数a, b。首先明确两个概念: 其一是a, b都是基本类型, 那么两个基本类型的值相同。其二是两个是引用类型, 那么引用类型相同。如果a === b为true, 我们是否可以说a和b是相等的。但是这里有个特殊的就是0, -0。0与-0被浏览器认为是相等的。正确来讲0与-0是不相等的(关于这里我是看了文章里面有提到, 我在控制台打印了下, 发现很神奇)。关于这里_.isEqual这样处理的。 1if (a === b) return a !== 0 || 1 / a === 1 / b; 我理解是这样的: 这里过滤了99%情况, 但是没有过滤掉0与-0的情况。但是return里面如果a是0, 直接就return false结束。还有就是a如果为-0呢？第一个条件满足, 我们看第二个 1 / a(-0) === -Infinity而1 / b(0) === Infinity;所以第二个条件也不满足, 那么直接返回return false. ——游戏结束。上面这种判断处理就是针对0与-0这种情况。 接下来就是 a !== b 如果a或者b其中有一个为null或者是undefined特殊处理。 1if (a === null || b === null) return a === b; 文章中说这里的这里的判断条件有点多余, 因为根据上面的判断条件 a === b肯定返回false。关于这里我想了想也对, 如果a === b 直接在上面的判断条件哪里直接就返回了。 所以把return a === b 替换成 retun false, 会更加清晰吧。 接下来用到了Object.prototype.toString.call, 如果判断的参数的类型不一样, 那么直接就返回return false。 12var className = toString.call(a)if (className !== toString.call(b)) return false; 如果a或者b都是Number类型, 但是这里又有一个特例就是not a number也就是NaN。这里我举个栗子: var number = new Number(&#39;s&#39;) var number2 = new Number(&#39;s&#39;); console.log(_.isEqual(number, number2)); 这里的number与number2的值都是Number{NaN},而且又都是[object Number]。 理应来讲number与number2应该是相等的, 因为都是NaN嘛。所以这里专门针对NaN的情况做了判断, 看case里的第一个判断条件: 如果+a不等于+a那么a就是NaN, 因为NaN === NaN为false。同理b也一样如果b为NaN那么返回为true。证明a, b相等(都为NaN)。如果+b === +b 返回false, 说明a, b不相等。 下面的return这里又有一个特殊处理, 是关于0的。举个例子: var s = new Number(-0); var a = new Number(0); console.log(_.isEqual(s, a)); 首先上面已经说过了0 === -0为true, 所以第一个条件为false。正确。同理把-0换成1, 走第二个条件也是一样, 返回false, 很明显不相等。 12345678case '[object Number]': // console.log('1') // `NaN`s are equivalent, but non-reflexive. // Object(NaN) is equivalent to NaN if (+a !== +a) return +b !== +b; // console.log(+b !== +b); // An `egal` comparison is performed for other numeric values. return +a === 0 ? 1 / +a === 1 / b : +a === +b; 关于对于Number类型的判断就到这里结束了。 正则RegExp和String类型判断举个例子:var a = /a/;var b = new RegExp(&#39;a&#39;)consolo.log(_.isEqual(s, a));我们看下是如何处理这种情况的, 首先还是老样子判断属于什么类型, 发现是RegExp进入return 转换为字符串进行比较-也就是a与a进行比较为true。String也一样,var a = new String(&#39;s&#39;);var b = new String(&#39;s&#39;);同上。123456case '[object RegExp]': // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')case '[object String]': // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is // equivalent to `new String(\"5\")`. return '' + a === '' + b; Date与Boolean类型判断举个栗子:还是根据数据类型选择进入:var a = new Date(1);var b = 1这样进行判断就会发现通过使用+new Date()或者+new Date转换成1。这样就会发现返回true;当然我觉得布尔类型也是如此,var a = true;var b = new Boolean(false);a为true, 我们也知道true == 1, true为布尔类型进入进行隐士类型转换, b也是如此, 如果相等返回true, 否则反之。123456case '[object Date]':case '[object Boolean]': // Coerce dates and booleans to numeric primitive values. Dates are compared by their // millisecond representations. Note that invalid dates with millisecond representations // of `NaN` are not equivalent. return +a === +b; 数组与对象类型比较关于数组的类型比较稍微比较麻烦, 因为涉及到数组有包括对象的情况。同理, 也有可能对象里面有数组的情况。还是老样子判断是否是[&#39;object Array&#39;]; 未完待续 参考 underscore-1.8.3.js 源码解读","pubDate":"Sun, 15 Jul 2018 07:37:00 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/07/15/underscore系列之比较两个元素是否相同/","category":"underscore.js"},{"title":"'2018年中总结'","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/07/09/年中总结/","description":"年中总结 距离上一个总结已经半年过去了, 上次的总结对于自己的要求和目标我还历历在目。说说我还在坚持的以及没有坚持到的, 看书这件事我今年开始了坚持, 因为我买了kindle, 目前javascript高程我看了80%, 但是有些知识点我还是很模糊, 我觉得在看的同时, 对于一些不太明白, 不太清晰的代码。一定要去敲下好吗, 我求你了。 因为我在看的时候有些没有敲, 相对与敲过代码的而言, 记忆薄弱了很多。看了曾探写的javascript设计模式与开发实践, 这本书我没有看完, 但我受益匪浅, 忽然觉得js这门语言很好玩。等我觉得有些概念了, 我会去写关于这本书的一些设计模式的自己看法与见解。对于自己而言有时候还是会很焦躁, 感觉会的还是太少了。对于博客我真的越来越懒, 更新频率越来越低下。说的是一个星期更新一篇, 拖到了一个月更新一次甚至更久。 健身方面的话, 中间另个一个健身房到期了, 又找了个便宜的。离得稍微近一点的。坚持锻炼吧。。。说好的, 看一看vue源码的我也没看。我甚至在想我能不能先看underscore或者jquery的源码。我有时候在想是不是可以让自己适当的停一下,慢一点, 给我一点缓冲的时间给自己充充电。我时常会感觉到自己的无力, 尤其对于在技术上, 本身前端技术的更新换代很快, 可能有时候稍微走了下神, 就会发现自己已经跟不上了。对于做技术而言, 一定要保持初心, 对于技术一定要有求知欲, 这方面我就做的很不好。希望自己保持初心吧。 下半年计划 下半年希望自己初心依旧。 读一遍underscore.js源码。 vue源码看看。 多学, 多看, 多听。 想多看看关于css的一些书籍。 可以的话, 学学英语。 心太小, 不想装太多, 太累了。","pubDate":"Mon, 09 Jul 2018 05:37:00 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/07/09/年中总结/","category":"年中总结"},{"title":"'我所知道的apply与call'","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/06/13/我所知道的apoly与call/","description":"我所知道的apply与call 在我打算写这篇文章之前我徘徊了两分钟(没错就是两分钟), 徘徊的原因是我觉得以我当前的对于js儿子-call与apply的掌握, 还不足以我能够很好的去解释给自己或者读者去听, 尤其是在看了一些书里面讲到了很多关于apply与call的妙用. 很神奇没有想到还能这么用. 但写了这篇文章的一个原因是我蛮久没有写了博客, 也该写了(尽力微笑…). 另一个原因是我想通过我的角度去说下我对于apply和call的看法. 其实在刚刚认识call或者apply的时候, 我在想这两个货是到底干嘛的, 在没有认识他们之前, 我也完成了某些功能的开发呀, 这两个货色的作用到底是什么, 我觉得我有必要去好好了解下. 开始认识call与apply 我打开了熟悉的mdn恩, 他好像挂了. 算了我用手机打开吧. 其中描述中这样的说道: 可以让call或者apply中的对象调用当前 对象所有的function. 你可以使用call()来实现继承: 写一个方法, 然后让另一个新的对象来继承它(而不是在新对象中再写一次这个方法). 难道是这样: 12345678910var foo = &#123; name: 'wangdaye', showName: function () &#123; console.log(this.name); &#125;&#125;var bar = &#123; name: 'liayi'&#125;foo.showName.call(bar); 我觉得这个栗子(栗子是我抄的_-_), 想表达的其实和上面描述里面提到的, 其实是一回事, 我觉得是这样, bar这个人想看下自己家的房产证名字写的是谁的, 但是没有梯子, 因为房产证放在需要梯子才能够到的地方, 所以他问了邻居foo, 嘿我用下你家梯子(showNmae方法), 行用吧, 然后就看到了自己的房产证是”老婆的名字”. 大概的的意思是, bar这个家伙没有自己方法, 但是他又想用, 怎么办那就借用了foo的方法. 就是这样. apply与apply的异同 同: apply与call 方法的第一个参数是在运行指定的this值. 需要注意的是, 指定的this值并不一定是该函数执行时真正的this值, 如果这个函数的处于非严格模式下, 则指定为null与undefined的this值会自动指向全局对象(浏览器中就是window对象), 同时值为原始值(数字, 字符串, 布尔值)的this会指向该原始值的自动包装对象. 关于这句话, 我再举个栗子: 1var max = Math.max.apply(null,array) 我在稍微说下: 这个栗子就很好的解释了上面提到的如果apply或者call的第一个参数, 我传递了null或者undefined那么这个时候this的指的就是上面提到的window, 而window里面有Math.max. 再举个栗子: 异: call参数是这样的形式(this, num1, num2, ….) apply参数是这样的形式(this, []) 未完待续。。。。。。—————————————–更新———————————————————– this与bind 我觉得既然聊到了apply与call就多聊一些, 加上this与bind。要说明this到底指向谁, 我在掘金上看到一篇关于this指向的文章, 提到了this永远指向最后调用它的那个对象。 123456var name = 'wangda';function aa () &#123; var name = \"wanger\"; console.log(name); // wangda&#125;aa();","pubDate":"Wed, 13 Jun 2018 06:24:00 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/06/13/我所知道的apoly与call/","category":"js,方法"},{"title":"'Chrome扩展程序'","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/04/28/Chrome插件/","description":"Chrome扩展程序 一直想着做一期关于chrome扩展程序的文章,索性就做了一期。其中的一些扩展程序我会根据自己用过的喜爱程序与相关推荐来做排名, 因为 其中有我没有用过的扩展程序。当然所有的相关程序都是需要进行翻墙来进行下载的。如果有需要可以联系我, 我会下载下来提供给你。 自用扩展程序 Adblock Plus JSON Viewer Momentum Noisli One Tab Postman Stylish Tampermonkey uBlock Origin (关闭) UI Stack Vue.js devtools WEB前端助手(FeHelper) 一键管理所有扩展 简悦 - SimpRead 目前就是这么多。 扩展程序排行榜 Adblock PlusAdblock是广告拦截软件。 目前chrome下载量: 161440 推荐指数: 5颗星 Tampermonkey油猴脚本是非常强大的扩展程序, 具体的用处建议自己去发掘下。说下令人感兴趣的如破解VIP会员视频集合。当然不是万能的有时候解析不出来视频, 而且不是清晰版, 其他还是可以的。目前chrome下载量: 55276 推荐指数 4颗星 Stylish强烈安利Stylish他的作用是更改网页主题如百度-google:目前chrome下载量: 15896 推荐指数: 4颗星 Momentum Momentum是新的标签页面,但不单单是标签页,里面还有很多隐藏的彩蛋。自己去发现吧。图片特别特别好看。怎么样,还可以吧。这个插件我的使用率不是很高。所以分数不是很高。目前chrome下载量: 12601 推荐指数: 3颗星 NoisliNoisli是一款很小清新的插件。不知道大家喜不喜欢下雨打雷看书的声音。那感觉(肾宝味道好极了)棒极了。可以自己配置一款自己喜欢的, 里面的声音大概10多种。随心所欲的去配置吧。此时的我就走在下着雨的森林,行走。除此以外, 好像没有别的用处。目前chrome下载量: 687 推荐指数: 3颗星 One Tab One Tab是一款与众不同的插件, 不知道你有没有烦恼过打开了’无数’的网站但就是不想关闭, 因为你只要关闭, 接下来再想看的话, 就要到历史记录里面去翻找(说多了都是泪啊)此处为本人脑补: 可能有的同学会说,我们不用翻找可以在历史记录进行搜索。非常好，同学你叫什么名字, 我叫陈独秀。陈同学你坐下。。。额 对, 用了这个插件我们可以十分顺畅,可以把所有的页面都集中在一个标签页上。目前chrome下载量: 10312 推荐指数: 4颗星 JSON ViewerJSON Viewer 接口格式化工具,我觉得做web前端工作的应该人手一个, 看到没有安装这个插件的同学, 马上安利。瞬间大神,额。。。。我呸。目前chrome下载量: 637 推荐指数: 4颗星 PostmanPostman是接口调试工具。恩对。反正挺好用的。目前chrome下载量: 652 推荐指数3颗星 WEB前端助手(FeHelper)?hl=zh-CN)FeHelper也是很不错的一款插件,它的功能比JSON Viewer会更多一些。随便说下,算了不说了。但是我把它关了。好像是因为它长的不好看?目前chrome下载量: 157 推荐指数: 3颗星 一键管理所有扩展一键管理插件真的对我来说作用不大。前提是如果你装了很多扩展插件,都是大部分都是摆着装13(麻烦帮我消下音), 这个时候可能在使用浏览器的过程中,可能会出现卡顿的现象。目前chrome下载量: 183 推荐指数 2颗星 这一期就这样吧。如果你们需要某一类的扩展程序, 比如打折或者划词翻译等等系列的。可以留言给我。我会搜集更多好玩, 实用的插件给你们。 我也会继续更新上面的插件,目前就想到这么多。 相应网站 更多知乎相应插件","pubDate":"Sat, 28 Apr 2018 06:54:48 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/04/28/Chrome插件/","category":"插件"},{"title":"'Javascript异步与同步'","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/04/23/Javascript异步与同步/","description":"Javascipt异步与同步 我们都知道Javascript语言执行环境是单线程的,所谓单线程在程序执行时,按照前面先执行,后面再去执行的顺序,也就是所谓的先进先出。但是这样一来,如果某个任务的执行时间很久,那么后面的所有任务都要去等着前面任务执行完毕。可能会出现浏览器卡死。作为浏览器语言,Javascript的主要用途是与用户互动,以及操作DOM。 在开始之前我还是要明确下何为异步,何为同步。 举个栗子： 12console.log('同步1')console.log('同步2') 按照的JavaScript语言执行顺序,最终的打印顺序为同步1然后同步2。 栗子2： 1234setTimeout(function() &#123; console.log('完成')&#125;, 0);console.log('结束') 我们都知道setTimeout是起到延迟器的作用,那么这里他的执行打印顺序为结束-完成。 这里可能有些迷惑,setTimeout不是0吗?为什么会是这样的打印结果。这里涉及到了一个关键词 Event Loop关于这个关键词目前我太不适于去讲。以后单开一篇文章,单独去讲。 这里我简单说下原理,我理解是这样的,javascript是单线程也是主线程,当出现异步操作时,它会等待主线程完成。然后进入。那么这时要等待执行console.log(‘结束’),然后再去执行setTimeout。 我在使用jquery ajax异步请求时面临到了这样一个问题： 1&lt;div id=\"content\"&gt; 12345678910111213var ccc = $(\"#content\")$.ajax(&#123; url: 'https://cnodejs.org/api/v1/topics', type: 'GET', dataType: 'json', success: function(res) &#123; ccc.html(res.data[0].content); &#125;&#125;)var con = $(\"#con\")con.click(function()&#123; console.log();&#125;); 这种情况下我想给返回的数据里的某个id为con的添加点击事件,这种情况下肯定是会报错了,原因是jquery-ajax默认是异步的,哪这种情况下当执行到获取dom元素时,是获取不到的,因为ajax的没有执行。 我想到的解决办法是: 改为同步(把async: false)这样的话,就会按照顺序执行,从而获取到id为con的dom元素。可是这样又会面临一个问题: 阻塞,如果返回的数据量很大的情况下,就会一直等待数据的返回,导致页面的卡顿。 哪有没有即是异步又可以获取dom的元素的呢。下面说第二种方法: jquery中有如下事件可以实现: on delegate bind live(最新jquery已删除)其中只测试了bind与on事件(如有其他需要请自行测试)123$('#content').on('click','#con',function() &#123; console.log('成功获取#con')&#125;); 如果我不想使用jquey的on或者其他事件,我可以实现吗？答案是当然可以。我查了下jquery的on的实现,提到了两个关键词事件代理或事件委托。当然上面的事件用的是事件委托。关于事件委托我简单说下:事件委托就是利用了事件冒泡的原理。举个栗子: 123456&lt;ul id=\"ul1\"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt; 12345678910window.onload = function()&#123; var oUl = document.getElementById(\"ul1\"); oUl.onclick = function(ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if (target.nodeName.toLowerCase() == 'li') &#123; alert(target.innerHTML); &#125; &#125;&#125; 简单的就是这样,我会再开一篇关于事件的文章。更系统的说下关于js的事件。其实关于异步我觉得更多的关注点还是要放在Event Loop上。如果你能够明白Event Loop那么异步也就不在话下。这篇文章就到这了。","pubDate":"Mon, 23 Apr 2018 06:24:00 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/04/23/Javascript异步与同步/","category":"js,事件"},{"title":"'mousewheel与DOMMouseScroll'","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/03/20/鼠标滚动事件兼容/","description":"mousewheel-DOMMouseScroll 最近在写vue的项目中涉及到了鼠标滚轮事件,之前没有用到过,所以踩了踩坑,想了想就写了一篇关于滚轮事件的文章。 踩坑 起先我是不知道关于滚轮事件是有兼容的,当时我只写了@mousewheel一种方法,满心欢喜去迎接马上到来的幸福生活。 先测了测chrome,没有问题完美实现。接下来是firefox,哎没有反应,我想了下肯定是姿势不对,再来一遍,漂亮,还是 没有反应,这个时候我想到了可能是有兼容,百度了下发现确实是有兼容,原来兼容分为两种,一种是firefox,一种是其他。 其他用到的是mousewheel而firefox用的是DOMMouseScroll。 下面是用到的部分代码 12345678910111213141516171819handleScroll (e) &#123; let type = e.type; if (type === 'DOMMouseScroll' || type === 'mousewheel') &#123; eventDelta = (e.wheelDelta) ? e.wheelDelta : -(e.detail || 0) * 40; &#125; if (eventDelta &gt; 0) &#123; this.left = Math.min(0, this.left + eventDelta); &#125; else &#123; if ($containerWidth - padding &lt; $wrapperWidth) &#123; if (this.left &lt; -($wrapperWidth - $containerWidth + padding)) &#123; this.left = this.left; &#125; else &#123; this.left = Math.max(this.left + eventDelta, $containerWidth - $wrapperWidth - padding); &#125; &#125; else &#123; this.left = 0; &#125; &#125;&#125; 我要说的是其他的滚动是根据e.wheelDelta作为判断条件,其中向上滚动是120,而向下滚动则取反是-120。而firefox判断滚轮方向 e.detail,向上判断是-3,向上则取反为3。 这个时间祭出大杀器推荐大家张鑫旭的博客关于鼠标滚动更好的总结。 张鑫旭-关于鼠标滚轮事件","pubDate":"Tue, 20 Mar 2018 14:26:00 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/03/20/鼠标滚动事件兼容/","category":"事件兼容"},{"title":"'this的值到底是什么？'","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/03/02/this的值到底是什么/","description":"题目 12345678var ob = &#123; foo: function () &#123; console.log(this); &#125;&#125;var bar = obj.foo;obj.foo(); // 打印的this为objbar(); // 打印的this为window 请解释最后两行函数的值为什么不一样。 初学者关于this的理解一直很模糊。今天这篇文章就要一次讲清楚了。 而且这个解释, 你在别的地方看不到。看懂这篇文章, 所有关于this的面试题, 都是小菜。 函数调用 首先需要从函数的调用开始讲起。 JS(ES5)里面有这种函数调用形式: 123func(p1, p2);obj.child.methods(p1, p2);func.call(context, p1, p2); 一般, 初学者都知道前两种形式, 而且认为前两种形式优于第三种形式。 从看到这篇文章起, 你一定要记住, 第三种调用形式, 才是正常调用形式: 1func.call(context, p1, p2); 其他两种形式都是语法糖, 可以等价地变为call形式: 1234func(p1, p2) 等价于func.call(undefined, p1, p2)obj.child.method(p1, p2) 等价于obj.child.method.call(obj.child, p1, p2); 请记下来。(我们称次代码为转换代码, 方便下文引用) 至此我们的函数调用只有一种形式: 1func.call(context, p1, p2) thisthis, 就是上面代码中的context。就这么简单。this是你call一个函数时的context, 由于你从来不用call形式的函数调用,所以你一直不知道。 先看func(p1, p2)中的this如何确定: 当你写下面代码时1234function func () &#123; console.log(this);&#125;func(); 等价于1234function func () &#123; console.log(this);&#125;func.call(undefined); 按理说打印出来的this应该就是undefined了吧, 但是浏览器里有一条规则:如果你传的context就null或者undefined, 那么window对象就是默认的context(严格模式下默认context是undefined)因此上面的打印结果是window。如果你希望这里的this不是window, 很简单:1func.call(obj) // 那么里面的this就是obj对象了 再看obj.child.method(p1, p2)的this如何确定123456var obj = &#123; foo: function () &#123; console.log(this) &#125;&#125;obj.foo() 按照转换代码, 我们将obj.foo()转换为1obj.foo.call(obj) 好了, this就是obj。 回到题目12345678var obj = &#123; foo: function () &#123; console.log(this) &#125;&#125;var bar = ob.fooobj.foo(); 转换为obj.foo.call(obj) this就是objbar() 转换为bar.call() 不传默认为undefined 所以指向window 总结 this 就是你 call 一个函数时，传入的 context。 如果你的函数调用形式不是 call 形式，请按照「转换代码」将其转换为 call 形式。 转载自掘金原作者方应杭在饥人谷","pubDate":"Fri, 02 Mar 2018 05:54:48 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/03/02/this的值到底是什么/","category":"关于this"},{"title":"'2017年度总结'","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/02/22/2017年总结/","description":"2017年度总结前言 2017年7月我从学校毕业出来,开始正式的进入社会,对一切充满了未知。当时我没有第一时间去选择找工作而是觉得当时的自己对于自己的认知还不是特别的明确,当然其中包括我对于自己要选择工作的技能。我觉得以我当时的能力还不足以去让自己能够找到心仪的工作,所以我当时选择了回家去闭关静修。我到了9月初选择了去找工作,短短两个月的时间,讲道理在我闭关的时间里没有我想象当中的那么的辛苦,当然我还是要去感谢当时自己的两个月的努力。可能努力的结果没有达到我现在的要求。但是,还是让我找到了工作。 工作 在公司工作了将近半年把,公司对于技术方面还是非常新颖的,一些相对来说比较久的相关采用的是angular.js,对于当时来说用的技术还是比较新的。之后的一些项目也是采用了比较火的框架Vue,因为之前在闭关的时候写了一个关于Vue的项目,所以对于上手还是相对比较轻松的。 再到后来重构了某个比较大的项目,采用了Vue。我想了想对于踩坑还是比较多的,差点逼死我。当然对于技术的提升还是蛮大的。反正就是慢慢来吧。 目标 把javascipt高级程序设计重新再看一遍。 把vue源码读一遍,理解相关部分。 博客每个星期更新一次。 github更新与打卡的记录更多一些。 了解并熟悉Http。 健身。 总结 总的来说这一年感慨还蛮多的,加上自己是一个比较多愁善感的人,很容易被周围的情绪影响。所以更多的时间我反而是在做自己想做的事情。没有更多去和朋友多去接触。家里人更多的是让我去和朋友多去接触,扩展人际关系。还有就是家里人也着急起来我的婚姻大事,我想说的是(婚姻大事我从没有放下),但更多的我还是在说再等等。 2018年努力努力再努力。 加油。 先到这,想到再更。","pubDate":"Thu, 22 Feb 2018 07:54:48 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/02/22/2017年总结/","category":"总结"},{"title":"music","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/01/14/我在未来等你/","description":"好妹妹-我在未来等你","pubDate":"Sun, 14 Jan 2018 08:38:48 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/01/14/我在未来等你/","category":"综合,music"},{"title":"music","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/01/12/你会爱我很久吗/","description":"秦昊-你会爱我很久吗","pubDate":"Fri, 12 Jan 2018 08:38:48 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/01/12/你会爱我很久吗/","category":"综合,music"},{"title":"'javascript-数组去重'","link":"https://wangdabaoqq.github.io/hexo-back-up/2018/01/10/数组去重/","description":"Javascipt数组去重方法一: 双循环（时间复杂度比较高, 性能一般。）测试用例一 123456789101112131415161718192021222324var arr = [1, 2, 3, 1];function unique (arr) &#123; var newArr = []; var len = arr.length; var isRepeat; for (var i = 0; i &lt; len; i++) &#123; isPepeat = false; // console.log(arr[i], 'arr[i]'); for (var j = i + 1; j &lt; len; j++) &#123; // console.log(arr[j], '111'); console.log(arr[i], 'arr[i]'); console.log(arr[j], 'arr[j]'); if (arr[i] === arr[j]) &#123; isPepeat = true; break; &#125; &#125; if (!isPepeat) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;console.log(unique(arr)); // [2, 3, 1] 测试用例二 12345678910111213141516function unique(arr) &#123; var newArr = []; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = i + 1; j &lt; len; j++) &#123; // console.log(j); if (arr[i] === arr[j]) &#123; j = ++i; // 不理解这里的意思,恕我愚钝 &#125; &#125; // console.log(arr[i]); newArr.push(arr[i]); &#125; return newArr;&#125;console.log(unique(arr)); // [2, 3, 1] tip: j = ++i;等价于 j = j + 1; i = i + 1； 整体思路就是如果是重复元素,则跳过重复元素,不对其进行push操作。 方法二: Array.prototype.indexOf()测试用例三 1234567891011function unique(arr) &#123; return arr.filter(function(item, index) &#123; // console.log(item); console.log(index); console.log(arr.indexOf(item)); // 其中indexOf代表着item里面第一次出现的位置, // 这样的话返回的也是所有第一次出现的元素。恩,对,没错。 return arr.indexOf(item) === index; &#125;);&#125;console.log(unique(arr)); // [1, 2, 3] tip: var new_array = arr.filter(callback, [thisArg]) callback: 用来测试数组的每个元素的函数,调用时使用参数(element,index, array)。 返回true表示保留该元素(通过测试),false则不保留。 thiArg: 可选。执行callback时的用于this的值。 整体思路就是索引不是第一个索引,说明是重复值。 详情见: MDN-filter 测试用例四 123456789101112function unique(arr) &#123; var newArr = []; arr.forEach((element) =&gt; &#123; console.log(newArr); console.log(newArr.indexOf(element)); if (newArr.indexOf(element) === -1) &#123; newArr.push(element); &#125; &#125;); return newArr;&#125;console.log(unique(arr)); // [1, 2, 3] tip: indexOf在这里代表着,当newArr里没有这个元素所以返回了-1, 而当newArr没有重复元素时,indexOf返回的都是-1。 整体思路为当没有没有重复元素返回-1,满足条件成立返回出去 详情见: MDN-indexOf 方法三: Array.prototype.sort()测试用例五 123456789101112function unique(arr) &#123; var newArr = []; arr.sort(); console.log(arr); for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] !== arr[i + 1]) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;unique(arr); // [1, 2, 3] tip: 原理就是按照排序的方式进行排序如[1, 2, 3, 1, 3]排序过后 就会形成[1, 1, 2, 3, 3]。当然这里有一个问题是sort对于其他 比如说[1, 11, 22, 18]就不会按照你设想的去排序,它会排序为 [1, 11, 18, 22]。然后就是进行判断相邻的(相邻的比如1, 1) 如果不相等就push然后返回。恩完美。 详情见: MDN-sort 测试用例六 123456789101112131415function unique(arr) &#123; var newArr = []; arr.sort(); for (var i = 0; i &lt; arr.length; i++) &#123; // console.log(arr[i]); console.log(arr[i], newArr[newArr.length - 1]); // console.log(arr[i]); if (arr[i] !== newArr[newArr.length - 1]) &#123; // console.log(arr[i]); newArr.push(arr[i]); &#125; &#125; return newArr;&#125;unique(arr); // [1, 2, 3] tip: 这里利用到的是与数组的进行比对,如果匹配不成功则push。 这里的点是进行第一次比对时因为数组为空那么它的长度-1就是undefined， 然后push了1进入。第二次比对发现长度-1与arr[i]匹配成功,条件不满足。 进行第三次匹配,以此类推。 方法四: 使用对象key来去重测试用例7 12345678910111213141516function unique(arr) &#123; var newArr = []; var len = arr.length; var tmp = &#123;&#125;; for (var i = 0; i &lt; len; i++) &#123; console.log(tmp); if (!tmp[arr[i]]) &#123; // console.log(tmp[arr[i]]); tmp[arr[i]] = 1; // console.log(tmp); newArr.push(arr[i]); &#125; &#125; return newArr;&#125;unique(arr); tip: 这里利用了对象(tmp)的key不可以重复的特性进行去重。 当进行匹配的时候默认情况下,是不存在tmp[arr[i]]的, 符合条件进行复制与push。循环往复。当有重复的元素时, 条件不满足。结束。 注意问题: // 这里我不太理解,希望有明白的能给解释下。 - 无法区分隐式类型转换成字符后一样的值, 比如1和&apos;1&apos;。 - 无法处理复杂数据类型, 比如对象(因为对象作为key会变成[object Object])。 - 特殊数据, 比如&apos;_proto_&apos;会挂掉,因为tmp对象的_proto_属性无法被重写。 解决1, 3: 可以为对象的key增加一个类型,或者将类型放到对象的value中来解决: 测试用例8 123456789101112131415161718function unique(arr) &#123; var newArr = []; var len = arr.length; var tmp = &#123;&#125;; var tmpKey; for(var i=0; i &lt; len; i++)&#123; tmpKey = typeof arr[i] + arr[i]; console.log(tmpKey); if(!tmp[tmpKey])&#123; tmp[tmpKey] = 1; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;console.log(unique(arr)); // [1,2,3] 这里换成了 var arr = [{xiaoming:23,xiaoqing:45},{xiaoming:24,xiaoqing:45}]; 解决问题二: 可以把对象序列化之后作为key来使用。这里使用了JSON.stringify()进行序列化。 测试用例9 12345678910111213141516function unique(arr) &#123; var newArr = []; var len = arr.length; var tmp = &#123;&#125;; var tmpKey; for(var i=0; i &lt; len; i++)&#123; tmpKey = typeof arr[i] + JSON.stringify(arr[i]); // console.log(tmpKey); if(!tmp[tmpKey])&#123; tmp[tmpKey] = 1; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;console.log(unique(arr)); ES6方法一: Map 12345678910111213function unique(arr) &#123; var newArr = []; var len = arr.length; var tmp = new Map(); for (var i = 0; i &lt; len; i++) &#123; if (!tmp.get(arr[i])) &#123; tmp.set(arr[i], 1); newArr.push(arr[i]); &#125; &#125; return newArr;&#125;unique(arr); // [1, 2, 3] tip: 这里用的是ES6-Map,是一种新的数据类型,类似于对象, 也是键值对的集合, 但是”键”的范围不限于字符串, 各种类型的值(包括对象)都可以当做键。可以把它想象成key类型没有限制的对象。它的存取使用单独的get() set()接口。 这里的方法也是进行判断tmp数组get有没有key与value如果没有就push,如果有判断条件不成立。 方法二: Set 12345function unique(arr) &#123; var set = new Set(arr); return Array.from(set);&#125;console.log(unique(arr)); // [1, 2, 3] tip: Set是一种新的数据结构。它类似与数组,但是成员的值都是唯一的,没有重复的值。 Array.from方法从类似数组或可迭代对象创建一个新的数组实例。 也可以使用扩展运算符 return […set]与Array.from同理。 方法三: Array.prototype.includes 1234567891011function unique(arr) &#123; var newArr = []; arr.forEach((element) =&gt; &#123; console.log(newArr.includes(element)); if (!newArr.includes(element)) &#123; newArr.push(element); &#125; &#125;); return newArr;&#125;console.log(unique(arr)); // [1, 2, 3] tip: includes方法用来判断一个数组是否包含一个指定的值,如果包含则返回true, 否则返回false。恩,就是这样。 纯手打。 加了一些自己的理解。后续还会加入更多关于数组去重的方法。 就这样,溜了。。。 原文章","pubDate":"Wed, 10 Jan 2018 07:15:15 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2018/01/10/数组去重/","category":"js,Array"},{"title":"'git命令(全)'","link":"https://wangdabaoqq.github.io/hexo-back-up/2017/10/01/git命令图(全)/","description":"git","pubDate":"Sun, 01 Oct 2017 14:02:12 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2017/10/01/git命令图(全)/","category":"git命令"},{"title":"'移动端资源整合部分'","link":"https://wangdabaoqq.github.io/hexo-back-up/2017/09/27/移动端/","description":"meta篇1.视窗宽度&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;, initial-scale=1.0, minimum-scale=1.0, maxinum-scale=1.0,user-scalable=no&quot;&quot;&gt; 其中width=device-width是设置视窗宽设备宽度,还可以固定宽度,例如:width=640则是640px的宽度(常见于微信);initial-scale=1.0: 设置缩放比例为1.0;minimum-scale=1.0和maximum-scale=1.0: 最大缩放比例和最大缩放比例;user-scalable-no: 禁止用户自由缩放,user-scalable默认值为yes. &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initscale=1.0, user-scalable=no&quot;&gt; 自动识别格式&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; content里面的参数: telephone是禁止浏览器自动识别手机号码,email=no是禁止浏览器自动识别Email. 完整模板&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; &lt;meta name=&quot;formate-detection&quot; content=&quot;email=no&quot;&gt; CSS篇body { font-family: \"Helvetica Neue\", Helvetica, STHeiTi, sans-serif; /* 使用无衬线字体 */ } a, img { -webkit-touch-callout: none; /* 禁止长按链接与图片弹出菜单 */ } html, body { -webkit-user-slect: none; /* 禁止选中文中 */ user-select: none; } button, input, optgroup, select, textarea { -webkit-tap-highlight-color: rgab(0, 0, 0, 0); /* 去掉a, input和button点击时的蓝色外边框和灰色半透明背景 */ } input::-webkit-input-placeholder { color: #ccc; /* 修改webkit中input的planceholder样式 */ } input:focus::-webkit-input-placeholder { color: #f00; /* 修改webkit中focus状态下input的planceholder样式 */ } body { -webkit-text-size-adjust: 100%!important; /* 禁止Ios调整字体大小 */ } input::-webkit-input-speech-button { display: none; /* 隐藏Android的语音输入按钮 */ } flex基础篇这里假设flex容器为.box, 子元素为item 定义容器为flex布局 .box { display: -webkit-flex; display: flex; } /* 行内flex */ .box { display: -webkit-inline-flex; display: inline-flex; } 容器样式 .box { flex-direction: row | row-reverse | column | column-reverse; /* 主轴方向: 从左到右(默认) | 从右到左 | 上到下 | 下到上 --> flex-wrap: norwap | wrap | wrap-reverse; /* 换行: 不换行(默认) | 换行 | 换行并第一行在下方 */ flex-flow: flex-direction | flex-wrap; /* 主轴方向和换行简写 */ justify-content: flex-start | flex-end | center | space-between | space-argound; /* 主轴对齐方式: 左对齐(默认) | 右对齐 | 居中对齐 | 两端对齐 | 平均分布 */ align-items: flex-start | flex-end | center | baseline | stretch; /* 交叉轴对齐方式: 顶部对齐(默认) 顶部对齐 居中对齐 | 上下对齐并铺满 | 文本基线对齐 */ align-content: flex-start | flex-end | cneter | space-between | space-around | strech; /* 多主轴对齐: 顶部对齐(默认) | 顶部对齐 | 居中对齐 | 上下对齐并铺满 | 上下平均分布 */ } 子元素样式 item { order: integer; /* 排序: 数值越小,越排前,默认为0 */ flex-grow: /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/ flex-shrink: /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/ flex-basis: | auto; /* default auto */ /*固定大小：默认为0，可以设置px值，也可以设置百分比大小*/ flex: none | [ ? || ] /*flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，*/ align-self: auto | flex-start | flex-end | center | baseline | stretch; /*单独对齐方式：自动（默认） | 顶部对齐 | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/ } 小技巧篇自定义苹果图标在网站文件根目录放一个 apple-touch-icon.png 文件，苹果设备保存网站为书签或桌面快捷方式时，就会使用这个文件作为图标，文件尺寸建议为：180px × 180px。 自定义favicon&lt;link rel=&quot;icon&quot; href=&quot;favicon.icon&quot; mce_href=&quot;favicon.icon&quot; type=&quot;image/x-icon&quot;&gt; 定义浏览器点击行为&lt;a href=&quot;tel: 020-10086&quot;&gt;打电话: 020-10086&lt;/a&gt; &lt;a href=&quot;sms: 10086&quot;&gt;发短信&lt;/a&gt; &lt;a href=&quot;mailto:me@22.clue&gt;发送邮件&lt;/a&gt; 定义上传文件类型和格式&lt;input type=&quot;file&quot; accept=&quot;image/*&quot;&gt; 上面的文件上传框中,accept可以限制上传文件的类型,参数image/是所有图片类型,点击会弹出图库,也可以指定图片格式,参数设置成image/png则可以限制图片类型png,参数如果为video/则是选择视频的意思;accept还可以设置多个文件格式,语法为accept=”image/gif, image/jpeg”; 使用box-shadow改变(挡住)表单自动填充后的黄色 input:-webkit-autofill, textarea: -webkit-autofill, select:-webkit-autofill { box-shadow: inset 0 0 0 1000px #fff; } 用CSS实现省略号截断white-space: nowrap; text-overflow: elipsis; 使用border绘制小三角原理是:上下和左右的边框对接其实是个斜角,利用这个特性,使其中一边的边框透明,另外一边写成想要的颜色并隐藏对边,就可以变成小箭头形状。 border-width: 10px 10px 10px 0; /* 三角形 */ border-color: transparent #fff; border-style: solid; width: 0; Toptips写法 &lt;div class=&quot;box&quot;&gt;嗨！点击菜单就可以关注兮兮公众号了哟 .box { position: relative; padding: 0 20px; width: 380px; height: 80px; border-radius: #efefef; font-size: 18px; line-height: 80px; } .box:after { position: absolute; top: 50%; left: -15px; z-index: 1; display: block; margin-top: -15px; width: 0; border-color: transparent #efefef; border-style: solid; border-width: 15px 15px 15px 0; content: ''; } 以上内容绝对纯手打,没有任何机打痕迹。转载自作者Heleth","pubDate":"Wed, 27 Sep 2017 15:09:56 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2017/09/27/移动端/","category":"web,移动端"},{"title":"'Javascript数组方法(ES5-ES6)'","link":"https://wangdabaoqq.github.io/hexo-back-up/2017/09/20/Javascript的数组方法/","description":"join() ES5join(speparator):将数组的元素组起一个字符串,spearator为分隔符,省略的话则用默认用逗号为分隔符,该方法只接收一个参数,即分隔符。1234var arr = [1,2,3];console.log(arr.join());console.log(arr.join('-'));console.log(arr); 通过join()方法可以重复字符串,只需传入字符串以及重复的次数,就能返回重复后的字符串,函数如下:12345function repeatString(str, n) &#123; console.log(new Array(n + 1).join(str)); return new Array(n + 1).join(str);&#125;;console.log(repeatString('abc', 3)); // abcabcabc push()和pop() ES5push()：可以接收任意数量的参数，把他们逐个添加到数组末尾,并返回修改后数组的长度。pop()：数组末尾移除最后,减少数组的length值,然后返回移除的项。1234567var arr = ['mi', 'to', 'you'];var count = arr.push('yao');console.log(count);console.log(arr);var sd = arr.pop();console.log(sd);console.log(arr); shift()和unshift()shift(): 删除原数组第一项,并返回删除元素的值,如果数组为空则返回undefind.unshift():将参数添加到原数组开头,并返回数组的长度。1234567var arr = ['ss', 'll', 'tt'];var cc = arr.unshift('cc');console.log(cc);console.log(arr);var ii = arr.shift();console.log(ii);console.log(arr); sort()sort():按照升序数组项-即最小的值位于最前面,最大的值排在最后面。在排序时,sort()方法会调用每个数组项的toString()转型方法,然后比较得到的字符串,以确定如何排序。即使数组中的每一项都是数值,sort()方法比较的也是字符串,因此会出现一下情况:12345var arr = ['a', 'b', 'c'];console.log(arr.sort());var arr1 = [2, 3, 7, 8];console.log(arr1.sort());console.log(arr1); // 原数组被改变 为了解决上述问题,sort()可以接收一个比较函数作为参数,以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数,如果第一个参数应该位于第二个之前则返回一个负数,如果两个参数相等则返回0,如果第一个参数位于第二个之后则返回一个正数。升序：1234567891011function compare (value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;;var arr2 = [23, 34, 37, 333];console.log(arr2.sort(compare)); 降序：1234567891011function compare (value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125;&#125;;var arr = [89, 23, 45, 99];console.log(arr.sort(compare)); reverse()reserve():反转数组项的顺序123var arr = [12, 34, 546, 333];console.log(arr.reverse());console.log(arr); // 原数组改变 concat()concat()：将参数添加到原数组中。这个方法会先创建当前数组的一个副本,然后将接收到的参数添加这个副本的末尾,最后返回新构建的数组。在没有concat()方法传递参数的情况下,它只是复制当前数组并返回副本。1234var arr = [1, 5, 9];var ss = arr.concat(98, [23, 78]);console.log(ss);console.log(arr); // 原数组未改变 传入的不是数组,则直接把参数添加到原数组的后面,传入的数组也是添加到原数组的后面。传入的二维数组？123var cv = arr.concat([0, [11, 89]]);console.log(cv); // [1, 5, 9, 0, [11, 89]];console.log(cv[4]); // [11, 89] 上述代码中,cv的第4项是一个包含两项的数组,也就是说concat方法只能将传入数组中的每一项添加到数组中,如果传入数组中有些项是数组,那么也会把这一数组项当作一项添加到cv中。 slice()slice(): 返回从原数组中指定开始下标和结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数,即要返回项的起始和结束位置。在只有一个参数的情况下,slice()方法返回从该参数指定位置开始到当前数组的末尾的所有项,如果有两个参数,该方法返回起始位置和结束位置之间的项-但不包括结束的位置的项。123456789var arr = [1, 3, 4, 90, 81];var count = arr.slice(1);console.log(count);var count1 = arr.slice(1, 4);console.log(count1);var count2 = arr.slice(1, -2);console.log(count2);var count3 = arr.slice(-2, -1);console.log(count3); count只设置了一个参数,也就是起始下标为1,所以返回的数组为下标,(包括下标)开始到数组的最后。 count2只设置了两个参数,返回起始下标(包括1)开始到终止下标(不包括4)。 count3只设置了两个参数,终止下标为负数,当出现负数时,将负数加上数组的长度的值(5)来替换该位置的数,因此就是1开始到3。count4中两个参数都是负数,所以都加上数组的长度5转换成正数,因此相当于slice(3, 4); splice()splice()：很强大的数组方法,它有很多用法,可以实现删除，插入和替换。 删除：可以删除任意数量的项,它只需指定两个参数,要删除的第一项的位置和要删除的项数,例如,splice(0, 2)会删除数组中的前两项。 插入:可以向指定位置插入任意数量的项,只需提供两个参数：其实位置,0(要删除的项数)和要插入的项。例如,splice(2, 0, 4, 6)会从当前的位置2开始插入4和6。 替换:可以向指定位置插入任意数量的项,且同时删除任意数量的项,只需指定3个参数,起始位置,要删除的项数和要插入的任意数量的项,插入的项数不必与删除的项数相等。例如,splice(2, 1, 4, 6)会删除当前数组位置2的项,然后再从位置2开始插入4和6.splice()方法始终都会返回一个数组,该数组中包含从原始数组中删除的项, 如果没有删除任何项,则返回一个空数值。 12345678910var arr = [1, 3, 4, 9, 90, 45];var ss = arr.splice(0, 2);console.log(arr);console.log(ss);var ss1 = arr.splice(2, 0, 4, 6);console.log(arr); //原数组已经改变console.log(ss1);var count3 = arr.splice(1, 1, 2, 4);console.log(arr);console.log(count); indexOf()和lastIndexOf()indexof():接收两个参数：要查找的项和(可选的)表示查找起点的位置的索引。其中,从数组的开头(位置0)开始向后查找。 lastIndexOf():接收两个参数：要查找的项和(可选的)表示查找起点位置的索引。其中,从数组的末尾开始向前查找。 这两个方法都返回要查找的项在数组中的位置,或者在没找到的情况下返回-1,在比较第一个参数与书中的每一项时,会使用全等操作符。 1234567var arr = [1, 2, 5, 9, 23, 5];console.log(arr.indexOf(5));console.log(arr.lastIndexOf(5));console.log(arr.indexOf(5, 2));console.log(arr.indexOf(5, 5));console.log(arr.lastIndexOf(5, 3));console.log(arr.indexOf(6)); forEach()forEach(): 对数组进行遍历循环,对数组的每一项进行给定函数。这个方法没有返回值。参数function类型,默认有传参,参数分别为：遍历的数组内容，对应的数组索引，数组本身。123456var arr = ['wa', 'ng', 'li', 'si'];arr.forEach(function(currentValue, index, li)&#123;console.log(item);console.log(index);console.log(li);&#125;); map()map():指’映射’,对数组中的每一项运行给定函数,返回每次函数调用的结果组成的数组。12345var arr = [1, 3, 5, 8];var arr2 = arr.map(function(item) &#123;return item * item;&#125;);console.log(arr2); filter()fliter():’过滤’功能,数组中的每一项运行给定函数,返回满足过滤条件组成的数组。 1234567var arr = [1, 3, 5, 7, 9];var arr2 = arr.filter(function(x, index) &#123;// console.log(x);// console.log(index);return index % 3 == 0 || x &gt;= 6;&#125;);console.log(arr2); every()every():判断数组中的每一项都是否满足条件,只有所有满足条件,才会返回true. 123456789var arr = [1, 2, 3, 4];var arr2 = arr.every(function(x) &#123; return x &lt; 1;&#125;);console.log(arr2);var arr3 = arr.every(function(x) &#123; return x &lt; 10;&#125;);console.log(arr3); some()some(): 判断数组中是否存在满足条件的项,只要有一项满足条件,就会返回true. 123456789var arr = [1, 2, 3];var arr2 = arr.some(function(x) &#123; return x &lt; 2;&#125;);console.log(arr2);var arr3 = arr.some(function(x) &#123; return x &lt; 1;&#125;);console.log(arr3); reduce()和reduceRight()这两个方法都会实现迭代数组的所有项,然后构建一个最终返回的值。reduce()方法从数组的第一项开始,逐个遍历到最后。而reduceRight()则从数组的最后一项开始,向前遍历到第一项。这两个方法都接收两个参数:一个在每一项上调用的函数和(可选的)作为归并基础的初始值。 传给reduce()和reduceRight()的函数接收4个参数:前一个值,当前值,项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项,因此第一个参数是数组的第一项,第二个参数就是数组的第一项。 123456789var arr = [1, 2, 3, 4];var sum = arr.reduceRight(function(p, c, i, a) &#123;console.log('prev', p);console.log('c', c);console.log('i', i);console.log('a', a); return p + c;&#125;, 10);console.log(sum); 数组的扩展扩展运算符扩展运算符(spread)是三个点(…).它好比reset参数的逆运算,将一个数组转为用逗号分隔的参数序列。123console.log(...[1, 2, 3]);console.log(1, ...[2, 3, 4], 5);[...document.querySelectorAll('div')] 该运算符用于函数的调用 12345678function push(array, ...items) &#123; array.push(...items); &#125;function add(x, y) &#123; return x + y;&#125;var numbers = [3, 4];add(...numbers) // 7 上面代码中,array.push(…items)和add(…numbers)这两行,都是函数的调用,它们都使用了扩展运算符,该运算将一个数组,变为参数序列。 扩展运算符与正常的函数参数可以结合使用,非常灵活。123function f(z, x, c, v) &#123;&#125;var args = [0, 1];f(-1, ...args, 2 ...[3]); 扩展运算符后面还可以放置表达式。 const arr = [ ...(x &gt; 0 ? [&#39;a&#39;] : []), &#39;b&#39;, ]; 如果扩展运算符后面是一个空数组,则不产生任何效果。 [...[], 1] 替代数组的apply方法由于扩展运算符可以展开数组,所以不再需要apply方法,将数组转为函数的参数了。12345678910 // ES5的写法 function f(x, y, z) &#123;&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; &#125;var args = [0, 1, 2, 3];f(...args); 下面是扩展运算符取代apply方法的一个实例的例子,应用Math.max方法,简化求出一个数组最大元素的写法。 123456// ES5的写法Math.max.apply(null, [14, 3, 77])// ES6的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 上面的代码中,由于javascript不提供数组最大元素的函数,所以只能套用Math.max函数,将数组转为一个参数序列,然后求最大值。有了扩展运算符以后,就可以直接用Math.max了。 另一个例子是通用push函数,将一个数组添加到另一个数组的尾部。 12345678// ES5的写法var arr1 = [0, 1, 2];var arr2 = [3, 4 ,5];Array.protype.push.apply(arr1, arr2);// ES6的写法var arr1 = [1, 2, 3];var arr2 = [3, 4, 5];arr1.push(...arr2); 上面代码的ES5写法中,push方法的参数不能是数组,所以只好通过apply方法变通使用push方法。 有了扩展运算符,就可以直接将数组传入push方法。 new (Date.bind.apply(Date, [null, 2015, 1, 1])); new Date(...[2015, 1, 1]); 扩展运算符的应用合并数组扩展运算符提供了数组合并的新写法1234567891011// [1, 2].concat(more)// [1, 2, ...more]var arr1 = ['a', ,'c'];var arr2 = ['c'];var arr3 = ['d', 'e'];// ES5的合并数组arr1.concat(arr2, arr3);// ['a', 'b', 'c', 'd', 'e']// ES6的合并数组[...arr1, ...arr2, ...arr3]// ['a', 'b', 'c', 'd', 'e'] 与结构赋值结合扩展运算符可以解构赋值结合起来,用于生成数组1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 下面是另一些例子 123456789const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = ['foo'];console.log(first);console.log(rest); 如果扩展运算符用于数组赋值,只能放在参数的最后一位,否则会报错。 123456789const [...butLast, last] = [1, 2, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 4, 5];// 报错const [first, last, ...middle] = [1, 2, 3, 4, 5];console.log(first);console.log(last);console.log(middle);// 不抱错 函数的返回值javascript的函数只能返回一个值,如果需要返回多个值,只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法. var dateFields = readDateFields(database); var d = new Date(...dateFields); 上面代码从数据库取出一行数据,通过扩展运算符,直接将其传入构造函数的Date. 字符串 扩展运算符还可以将字符串转为真正的数组12345678 console.log([...'hello']); // [ \"h\", \"e\", \"l\", \"l\", \"o\" ]``` 上面的写法,有一个重要的好处,那就是能够正确识别32位的Unicode字符。 ```js 'x\\uD83D\\uDE80y'.length // 4[...'x\\uD83D\\uDE80y'].length // 3 上面代码的第一种写法，JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。 123function length(str) &#123; return [...str].length;&#125; length(&#39;x\\uD83D\\uDE80y&#39;) // 3 凡是涉及到操作32位 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。 1234567let str = 'x\\uD83D\\uDE80y';str.split('').reverse().join('')// 'y\\uDE80\\uD83Dx'[...str].reverse().join('')// 'y\\uD83D\\uDE80x' 上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。 实现了 Iterator 接口的对象任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。 var nodeList = document.querySelectorAll(&#39;div&#39;); var array = [...nodeList]; 上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。 12345678let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// TypeError: Cannot spread non-iterable object.let arr = [...arrayLike]; 上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 Map 和 Set 结构，Generator 函数扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。 1234567let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3] Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 123456var go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] 上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。 如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。 12var obj = &#123;a: 1, b: 2&#125;;let arr = [...obj]; // TypeError: Cannot spread non-iterable object Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。 下面是一个类似数组的对象,Array.from将他转为真正的数组。 1234567891011 let arrays = &#123; '0': 'a', '1': 'c', length: 2&#125;;// ES5var arr1 = [].slice.call(arrays);console.log(arr1);// ES6let arr2 = Array.from(arrays);console.log(arr2); 实际应用中,常见的类似数组的对象是DOM操作返回的NodeList集合,以及函数内部的arguments对象。 Array.from 都可以将他们转为真正的数组。 123456789// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments);&#125; 上面代码中,querySelectorAll方法返回的是一个类似数组的对象,可以将这个对象转为真正的数组,在使用forEach方法。 只要是部署了Iterator接口的数据结构,Array.from都能将其转为数组。 12345console.log(Array.from('hello'));// [\"h\", \"e\", \"l\", \"l\", \"o\"]let nameSet = new Set(['a', 'b']);console.log(Array.from(nameSet));// (2) [\"a\", \"b\"] 上面代码中,字符串和Set结构都具有Iterator接口,因此可以被Array.from转为真正的数组。 如果参数是一个真正的数组,Array.from会返回一个一模一样的新数组。 123456789Array.from([1, 2, 3])// [1, 2, 3]值的提醒的是,扩展运算符(...)也可以将某些数据结构转为数组。// arguments对象function foo() &#123; var args = [...arguments];&#125;// NodeList对象[...document.querySelectorAll('div')] 扩展运算符背后调用的是遍历器接口(Symbol.iterator),如果一个对象没有部署这个接口,就无法转换。Array.from方法还可以支持数组的对象。所谓类似数组的对象,本质特征只有一点,即必须有length属性。因此,任何length属性的对象,都可以通过Array.from方法转为数组,而此时扩展运算符就无法转换。 12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] 上面的代码中,Array.from返回了一个具有三个成员的数组,每个位置的值都是undefind。扩展运算符转换不了这个对象。 对于还没有部署该方法的浏览器,可以用Array.prototype.slice方法替代。 123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj))(); Array.from 还可以接受第二个参数,作用类似与数组的map方法,用来对每个元素进行处理,将处理后的值放入返回的数组。 1234567Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9]console.log(Array.from([1, 2, 3], (x) =&gt; x * x)) 下面的例子是取出一组Dom节点的文本内容。 1234567let spans = document.querySelectorAll('span.name');// map()let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);// Array.from()let names2 = Array.from(spans, s =&gt; s.textContent) 下面的例子将数组中布尔值为false的成员转为0。 1console.log(Array.from([1, , , 2], (n) =&gt; n || 0)); 另一个例子是返回各种数据的类型。 12345function typeOf () &#123; return Array.from(arguments, value =&gt; typeof value)&#125;console.log(typeOf(null, [], NaN))// [\"object\", \"object\", \"number\"] 如果map函数里面用到了this关键字,还可以传入Array.from的第三个参数,用来绑定this. Array.from()可以将各种值转为真正的数组,并且还提供map功能。这实际上意味着,只要有一个原始的数据结构,你就可以先对它的值进行处理,然后专程规范的数组结构,进而就可以使用数量众多的数组方法。 12console.log(Array.from(&#123; length: 2&#125;, () =&gt; 'jack'))// ['jack', 'jack'] 上面的代码中,Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法非常灵活。 Array.from()的另一个应用是,将字符串转为数组,然后返回字符串的长度。因为它能正确处理各种Unicode字符,可以避免Javascript将大于\\uFFFF的Unicode字符,算做两个字符的bug. 123function countSymbols(string) &#123; return Array.from(string).length;&#125; Array.of()Array.of方法用于将一组值,转换为数组。 123console.log(Array.of(3, 11, 8));console.log(Array.of(1));console.log(Array.of(1).length); 这个方法的目的,是弥补数组构造函数的Array()的不足.因为参数个数的不同,会导致Array()行为差异。 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 上面的代码中,Array方法没有参数,一个参数,三个参数时,返回的结果都不一样。只有当参数不小于2个时,Array()才会返回由参数组成的新数组,参数个数只有一个时,实际上是指定数组的长度。 Array.of基本上可以替代Array()或new Array(),并且不存在由于参数不同而导致的重载.它的行为非常统一。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] Array.of总是返回参数组成的数组。如果没有参数,就返回一个空数组。 Array.of方法可以用下面的代码模拟实现。 123function ArrayOf()&#123; return [].slice.call(arguments);&#125; 数组实例的 copyWithin()数组实例的copyWithin方法,在当前数组内部,将指定位置的成员复制到其他位置(会覆盖原有成员),然后返回当前数组。也就是说,使用这个方法,会修改当前数组。1234567891011 Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 - target(必需): 从该位置开始替换数据。 - start(可选): 从该位置开始读取数据,默认是0.如果为负值,表示倒数。 - end(可选):到该位置前停止读取数据,默认等于数组长度,如果为负值,表示倒数。 这三个参数都应该是数值,如果不是,会自动转换为数值。 ``` ```jsconsole.log([1, 2, 3].copyWithin(0, 1));// [2, 3, 3] 上面的代码表示将从3号位直到数组结束的成员(4和5),复制到从0号位开始的位置,结果覆盖了原来了1和2. 下面是更多的例子 123456789101112131415161718192021console.log([1, 2, 3].copyWithin(0, 1, 2))// [2, 2, 3]// -2相当于3号位，-1相当于4号位console.log([1, 2, 3, 4, 5].copyWithin(0, -2, -1));[4, 2, 3, 4, 5]// 没有理解如下:// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位var i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 数组实例的find()和findIndex()数组实例的find方法,用于找出第一个符合条件的数组成员.它的参数是一个回调函数,所有的数组成员依次执行该回调函数,直到找出第一个返回值为true的成员,然后返回该成员。如果没有符合条件,则返回undefined. 123let ss = [1, 4, -5, 10].find((n) =&gt; n &lt; 0)console.log(ss);// -5 上面代码找出数组中第一个小于0的成员。 12345let arr = [1, 4, -5, 10].find(function(value, index, arr) &#123; return value &gt; 9;&#125;)console.log(arr);// 9 上面代码中,find方法的回调函数可以接受三个参数,以此为当前的值,当前的位置和原数组。 数组实例的findIndex方法的用法与find方法类似,返回第一个符合条件的数组成员的位置,如果所有成员都不符合条件,则返回-1. 12345let arr = [1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;)console.log(arr)// 2 这两个方法都可以接受第二个参数,用来绑定回调函数的this对象另外,这两个方法都可以发现NaN,弥补了数组的IndexOf方法的不足。 12345[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0 上面的代码中,indexOf方法无法识别数组的NaN成员,但是findIndex方法可以借助Object.is方法做到。 数组实例的fill()12345let arr = ['a', 'b', 'c'];console.log(arr.fill(7));// [7, 7, 7]console.log(new Array(3).fill(7));// [7, 7, 7] 上面代码表明,fill方法用于空数组的初始化非常方便.数组中已有的元素,会被全部抹去。 fill方法还可以接受第二个参数和第三个参数,用于指定填充起始位置和结束位置. 123let arr = ['a', 'b', 'c'];console.log(arr.fill(7, 1, 2));// [\"a\", 7, \"c\"] 上面代码表示,fill方法从1号位开始,向原数组填充7,到2号位之前结束。 数组实例的entries(),keys()和values()ES6提供了三个新的方法–entries(),keys()和values()–用于遍历数组.它们都返回一个遍历器对象(详见《Iterator》一章),可以用for…of循环进行遍历,唯一的区别是keys()是对键名的遍历,entries()是对键值对的遍历。 1234567891011121314for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// [\"a\",\"b\"].values(...) is not iterablefor (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 如果不使用for…of循环,可以手动调用循环遍历器对象的next方法,进行遍历。 12345678let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value);console.log(entries.next().value);console.log(entries.next().value);// [0, \"a\"]// [1, \"b\"]// [2, \"c\"] 数组实例的includes()Array.prototype.includes方法返回一个布尔值,表示某个数组是否包含给定的值,与字符串的includes方法类似。ES2016引入了该方法。123456console.log([1, 2, 3].includes(2));console.log([1, 2, 3].includes(4));console.log([1, 2, NaN].includes(NaN)); // true// false// true 该方法的第二个参数的表搜索的起始位置,默认为0。如果第二个参数为负数,则表示倒数的位置。如果这时它大于数组的长度(比如第二个参数为-4,但数组长度为3)则会重置它从0开始。 12console.log([1, 2, 3].includes(3, 3)); // falseconsole.log([1, 2, 3].includes(3, -1)); // true 没有该方法之前,我们通常使用数组的indexOf方法,检查是否包含某个值。 12if (arr.indexOf(el) !== -1) &#123;&#125; indexOf方法有两个缺点,一是不够语义化,它的含义是找到参数值的第一个出现位置,所以要去比较是否不等于-1,表达起来不够直观。二是,它内部使用严格相等运算符(===)进行判断,这会导致NaN的误判。 12[NaN].index(NaN)// -1 includes使用的是不一样的判断算法,就没有这个问题。 12[NaN].includes(NaN)// true 下面代码用来检查当前环境是否支持该方法,如果不支持,部署一个简易的替代版本。 1234const = contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el ===value))(); contains(['foo', 'bar'], 'baz'); // false 另外,Map和Set数据结构有一个has方法,需要注意includes区分。1234-Map结构的has方法,用来查找键名的,比如Map.prototype.has(key)webkMap.prototype.has(key),Reflect.has(target, prototypeKey).-Set结构的has方法,用来查找值的,比如Set.prototype.has(value),WeakSet.prototype.has(value). 数组的空位数组的空位指,数组的某一位置没有任何值。比如,Array构造函数返回的数组都是空位。 12console.log(Array(3))// [empty × 3] 上面代码中,Array(3)返回一个具有3个空位的数组。注意,空位不是undefined,一个位置等于undefined,依然是有值的。空位是没有任何值,in运算符可以说明这一点。 12console.log(0 in [undefined, undefined, undefined]) // trueconsole.log(0 in [, , ,]) // false 上面代码说明,第一个数组的0号位置是有值的,第二个数组的0号位置。ES5对空位的处理,已经很不一致,大多数情况下会忽略空位。 123- forEach(), filter(), every()和some()都会跳过空位。- map()会跳过空位,但会保留这个值- join()和toString()会将空位视为undefined,而undefined和null会被处理成空字符串。 12345678910111213141516// forEach方法[, 'a'].forEach((x, i) =&gt; &#123; console.log(i); // 1&#125;);// filter方法 console.log(['a', , 'b'].filter(x =&gt; true)); // [\"a\", \"b\"]// every方法console.log([, 'a'].every(x =&gt; x === 'a')) // true// some方法console.log([, 'a'].some(x =&gt; x!== 'a')) //false// map方法console.log([, 'a'].map(x =&gt; 1)) // [empty × 1, 1]// join方法console.log([, 'a', undefined, null].join('#')) // #a##// toString方法console.log([, 'a', undefined, null].toString()) // ,a,, ES6则是明确将空位转为undefined.Array.from方法会将数组的空位,转为undefined,也就是说,这个方法不会忽略空位。 12console.log(Array.from(['a', , 'b']))// [\"a\", undefined, \"b\"] 扩展运算符(…[‘a’ , , ‘b’])也会把空位转为undefined. 1console.log([...['a', , 'b']]) // [\"a\", undefined, \"b\"] copyWithin()会连空位一起拷贝。 12console.log([, 'a', 'b', ,].copyWithin(2, 0))// [empty × 1, \"a\", empty × 1, \"a\"] fill()会将空位视为正常的数组位置。 1console.log(new Array(3).fill('a')) for…of循环也会遍历空位。 1234let arr = [, ,];for (let i of arr) &#123; console.log(i); // undefined*2&#125; 上面代码中,数组arr有两个空位,for…of并没有忽略他们。如果改成map方法遍历,空位是会跳过。entries(),keys(),values(),find()和findIndex()会将空位处理成undefined.12345678910// entries()console.log([...[, 'a'].entries()]) // [0, undefined] [1, \"a\"]// keys()console.log([...[, 'a'].keys()]) // [0, 1]// values()console.log([...[,'a'].values()] ) // [(intermediate value),\"a\"].values(...) is not iterable// find()console.log([, 'a'].find(x =&gt; true)) // undefined// findIndex()console.log([, 'a'].findIndex(x =&gt; true)) // 0 由于空位的处理规则非常不统一,所以建议避免出现空位。 纯手打,没有任何机打痕迹。","pubDate":"Wed, 20 Sep 2017 14:30:12 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2017/09/20/Javascript的数组方法/","category":"javascript,Array方法"},{"title":"'面试题目'","link":"https://wangdabaoqq.github.io/hexo-back-up/2017/08/31/面试/","description":"2017年08月31日又开始上班了,我总结下我面试的一些题目,当然有些我没有回答上来。面试的第一天天气很不好,下着大雨,今天要面试三家公司,公司都相距很远,面试的第一家是做管理系统的后台是用php的,到了以后填写了相关信息,面试岗位,等等。给了一份面试题,上面就三个大题,第一道题目是关于迭代。 题目一用迭代实现1+2+3+4+5+…+n求值写的时候就忘了迭代与循环的什么关系这道题没有写出来回去以后就查了查迭代与循环的关系迭代是循环的一种。 var n = 100; var s = 0; for (var i = 1; i &lt;= n; i++ ) { s += i; console.log(s) } 题目二第二道题是类似杨辉三角形也没有做出来,具体题目我不大记得了,等我回想然后再去上传题目 ##题目三第三道题目类似有个字符串把他进行倒叙输出再把首字母转换为大写。 var reverse = function (str) { return str.split(‘ ‘).reverse().join(‘ ‘);}function titleCase(str) { str = str.toLowerCase().split(‘ ‘); for (var i in str) { str[i] = str[i].replace(str[i].charAt(0), str[i].charAt(0).toUpperCase()); };return str.join(‘ ‘);}console.log(titleCase(reverse(‘this is apple’))); //“Hello World” 著作权归作者所有。三道题一道题目也没有做出来,内心很难受,就意识到基础知识的薄弱,我也希望有同学看到我的面试经历,自己会去思考自己哪方面的知识稍微薄弱,可以去加深下。 这是第一家面试公司,结果失败,很糟糕接下来的面试说实话都不想去了,但是已经约了人家了就硬着头皮去了。——————————————第一家结束—————————————-第二家开始,第二家做的是一些汽车的网站。第二家面试的题目 题目一面试的技术跟我说了这样一个问题,比如说现在有这样一个问题项目已经完成并打包上线,但是出现个问题比如说有个汽车的价格写的不对,运营方面就直接修改了线上的价格,但是这样就出现了一个问题,如果运营直接把线上的修改了就会和本地的产生了差异,怎么才能不出现这个问题(大概是这个意思),那我就说,先给用户去看,如果没有问题了,再去把本地的去做更改,再去打包,部署到线上。然后他就点点头。(?). 题目二说说git与svn的区别我没有回答出来,面试官告诉我的是git是分布式的自己可以玩,而svn不能自己玩(大概就是这个意思)回去百度了下答案如下:1.GIT是分布式的，SVN不是： 这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。如果你能理解这个概念，那么你就已经上手一半了。需要做一点声明，GIT并不是目前第一个或唯一的分布式版本控制系统。还有一些系统，例如Bitkeeper, Mercurial等，也是运行在分布式模式上的。但GIT在这方面做的更好，而且有更多强大的功能特征。 GIT跟SVN一样有自己的集中式版本库或服务器。但，GIT更倾向于被使用于分布式模式，也就是每个开发人员从中心版本库/服务器上chect out代码后会在自己的机器上克隆一个自己的版本库。可以这样说，如果你被困在一个不能连接网络的地方时，就像在飞机上，地下室，电梯里等，你仍然能够提交文件，查看历史版本记录，创建项目分支，等。对一些人来说，这好像没多大用处，但当你突然遇到没有网络的环境时，这个将解决你的大麻烦。 同样，这种分布式的操作模式对于开源软件社区的开发来说也是个巨大的恩赐，你不必再像以前那样做出补丁包，通过email方式发送出去，你只需要创建一个分支，向项目团队发送一个推请求。这能让你的代码保持最新，而且不会在传输过程中丢失。GitHub.com就是一个这样的优秀案例。 有些谣言传出来说subversion将来的版本也会基于分布式模式。但至少目前还看不出来。 2.GIT把内容按元数据方式存储，而SVN是按文件： 所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。如果你把.git目录的体积大小跟.svn比较，你会发现它们差距很大。因为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。 3.GIT分支和SVN的分支不同： 分支在SVN中一点不特别，就是版本库中的另外的一个目录。如果你想知道是否合并了一个分支，你需要手工运行像这样的命令svn propget svn:mergeinfo，来确认代码是否被合并。感谢Ben同学指出这个特征。所以，经常会发生有些分支被遗漏的情况。 然而，处理GIT的分支却是相当的简单和有趣。你可以从同一个工作目录下快速的在几个分支间切换。你很容易发现未被合并的分支，你能简单而快捷的合并这些文件。 Git logo 4.GIT没有一个全局的版本号，而SVN有： 目前为止这是跟SVN相比GIT缺少的最大的一个特征。你也知道，SVN的版本号实际是任何一个相应时间的源代码快照。我认为它是从CVS进化到SVN的最大的一个突破。因为GIT和SVN从概念上就不同，我不知道GIT里是什么特征与之对应。如果你有任何的线索，请在评论里奉献出来与大家共享。 更新：有些读者指出，我们可以使用GIT的SHA-1来唯一的标识一个代码快照。这个并不能完全的代替SVN里容易阅读的数字版本号。但，用途应该是相同的。 5.GIT的内容完整性要优于SVN： GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 题目三说说webpack与grunt或gulp的异同同:我回答的是这三个都是打包自动化工具,都是为了提升工作效率.异:我回答的是webpack可以对一些图片或者js css等进行打包压缩,而gulp或grunt不能。grunt与gulp是自动化工具,而webpack是前端模块化工具。 ##题目四说说var和let的区别我回答的是作用域的不一样,在作用域外var可以在作用域内访问到而let不可以,let只能在那里定义在那里访问。使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；使用const声明的是常量，在后面出现的代码中不能再修改该常量的值。 题目五说一个div元素距离顶部为10像素在其内部也有个div距离上一个div的距离也是10像素,那么内部的div元素距离顶部是多少像素。我回答的是20像素,面试官告诉我是10像素,我问他为什么他说这是一个坑。 题目五说下vue是不是适合像政府类的网站我回答的是不适合,因为我觉得vue是轻量级的,而政府类的一般都是内容比较多的,特别的臃肿,所以我觉得不太适合。 题目五用jquery和vue分别实现导航高亮显示jquery就是选择元素当鼠标点击时当前的元素给他添加一个class样式,而他的兄弟节点进行removClass保持正常。vue我回答的不好,或者说不对。就不说了。 题目六第二家公司大体就是这样,最后跟我说一两天给我消息,我就走了,走的时候忘了拿伞又回去拿伞碰到了他们老板,他们老板让我去他办公司聊聊,聊了聊发现他认识我以前的同事,最后问了我薪资要求.(乌龙) —————————————–第二家结束——————————————赶去第三家,第三家比较远,做公交车,坐了一个小时多点,到了地方进行简单的自我介绍.开始面试的不是技术,就稍微问了我基本情况,过了一会让我进行了电话面试。 题目一说下怎么jquery怎么跨域讲道理之前看了跨域的实现方式有8种,我就回答可能是用的最多的一种jsonp 题目二vue和jquery的区别我回答的是:我觉得vue他本身是框架,而jquery他是库,框架他制定了一种自己的规则,你想要使用他你就要去按照他的方式去使用,而jquery他是一个库,引入就可以使用,我觉得他们两个不能进行比较。 过了一会他们老板进来了问了我平常喜欢做什么,我就说喜欢coding(抖个机灵),然后就问了一些个人情况,最后问我,面试几家了,我说好几家了(其实想博一下)然后跟我说来我们公司吧,其他的就不用去了,我说我考虑下,跟我说不用考虑了,我说你们公司现在前端多少人,他说都是新招的,我又问了他们用的什么框架,用的是can我不知道。然后跟我说,他是从阿里出来的,然后又是说了马云爸爸的激励人生的名言。 回去以后五点左右,开始继续投递,然后约了第二天面试的公司。。。————————————–第三家结束———————————————第二天去了离我住的很近的一个公司,但是要求很多,心理很虚.第一家公司题目 题目一等我整理下再来补充 ——————————————第四家结束—————————————–第五家简单问了问你用什么编辑器,我说了某某,然后跟我说了公司的基本情况,然后等等,公司是用vue的,然后给他看了看我打包的app但流畅性不好,最后问了问薪资,等等。 ————————————第五家结束———————————————–第六家 题目一说说怎么让一个函数怎么页面一加载就立即执行,我说了让window.onload等于那个函数,这样页面一加载函数就会立即执行,我问他这样可不可以,他说不行,我又说写个立即执行函数可以吗,他说也不行。 题目二问了我关于怎么让页面一加载就调用数据,说实话我是不理解的。 题目三问了html接近满了,说实话很心虚(当时写的有点多,呵呵)。友情提示:关于技能方面不要写那么多,那么满。 题目五问了我psd图能还原多少,我说我没有办法做到100%还原。。。GG还有问了我看了什么书我说权威指南与你不知道的javascript他说权威指南不好….?(为啥)还有几个但是我给忘了,想起来再补充。人事给我说了薪资,等等一些方面,说给我打电话。 ——————————————-面试结束——————————————最后我去了第三家,因为离我很近, 而且技术方面我觉得可能更合适我。就先这样。","pubDate":"Wed, 30 Aug 2017 16:00:00 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2017/08/31/面试/","category":"面试"},{"title":"'Promise'","link":"https://wangdabaoqq.github.io/hexo-back-up/2017/08/10/promise/","description":"1.Promise的立即执行性 var p = new Promise(function(resolve, reject){ console.log(&quot;create a promise&quot;); resolve(&quot;success&quot;); }); console.log(&quot;after new Promise&quot;); p.then(function(value){ console.log(value); }); 控制台输出： &quot;create a promise&quot; &quot;after new Promise&quot; &quot;success&quot; Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。 2.Promise 三种状态 var p1 = new Promise(function(resolve,reject){ resolve(1); }); var p2 = new Promise(function(resolve,reject){ setTimeout(function(){ resolve(2); }, 500); }); var p3 = new Promise(function(resolve,reject){ setTimeout(function(){ reject(3); }, 500); }); console.log(p1); console.log(p2); console.log(p3); setTimeout(function(){ console.log(p2); }, 1000); setTimeout(function(){ console.log(p3); }, 1000); p1.then(function(value){ console.log(value); }); p2.then(function(value){ console.log(value); }); p3.catch(function(err){ console.log(err); }); 控制台输出： Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 1} Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined} Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined} 1 2 3 Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 2} Promise {[[PromiseStatus]]: &quot;rejected&quot;, [[PromiseValue]]: 3} Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。 p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个setTimeout函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。 3.Promise 状态的不可逆性 var p1 = new Promise(function(resolve, reject){ resolve(&quot;success1&quot;); resolve(&quot;success2&quot;); }); var p2 = new Promise(function(resolve, reject){ resolve(&quot;success&quot;); reject(&quot;reject&quot;); }); p1.then(function(value){ console.log(value); }); p2.then(function(value){ console.log(value); }); 控制台输出： &quot;success1&quot; &quot;success&quot; Promise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中resolve(“success2”)并不能将p1的值更改为success2，p2中reject(“reject”)也不能将p2的状态由resolved改变为rejected. 4.链式调用 var p = new Promise(function(resolve, reject){ resolve(1); }); p.then(function(value){ //第一个then console.log(value); return value*2; }).then(function(value){ //第二个then console.log(value); }).then(function(value){ //第三个then console.log(value); return Promise.resolve(&apos;resolve&apos;); }).then(function(value){ //第四个then console.log(value); return Promise.reject(&apos;reject&apos;); }).then(function(value){ //第五个then console.log(&apos;resolve: &apos;+ value); }, function(err){ console.log(&apos;reject: &apos; + err); }) 控制台输出： 1 2 undefined &quot;resolve&quot; &quot;reject: reject&quot; Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种： return 一个同步的值 ，或者 undefined（当没有返回一个有效值时，默认返回undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。return 另一个 Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。throw 一个同步异常，then方法将返回一个rejected状态的Promise, 值是该异常。根据以上分析，代码中第一个then会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个then输出的值是2。第二个then中没有返回值，因此将返回默认的undefined，于是在第三个then中输出undefined。第三个then和第四个then中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个then中成功的回调函数和第五个then中失败的回调函数处理。 5.Promise then() 回调异步性 var p = new Promise(function(resolve, reject){ resolve(&quot;success&quot;); }); p.then(function(value){ console.log(value); }); console.log(&quot;which one is called first ?&quot;); 控制台输出： &quot;which one is called first ?&quot; &quot;success&quot; Promise接收的函数参数是同步执行的，但then方法中的回调函数执行则是异步的，因此，”success”会在后面输出。 6.Promise 中的异常 var p1 = new Promise( function(resolve,reject){ foo.bar(); resolve( 1 ); }); p1.then( function(value){ console.log(&apos;p1 then value: &apos; + value); }, function(err){ console.log(&apos;p1 then err: &apos; + err); } ).then( function(value){ console.log(&apos;p1 then then value: &apos;+value); }, function(err){ console.log(&apos;p1 then then err: &apos; + err); } ); var p2 = new Promise(function(resolve,reject){ resolve( 2 ); }); p2.then( function(value){ console.log(&apos;p2 then value: &apos; + value); foo.bar(); }, function(err){ console.log(&apos;p2 then err: &apos; + err); } ).then( function(value){ console.log(&apos;p2 then then value: &apos; + value); }, function(err){ console.log(&apos;p2 then then err: &apos; + err); return 1; } ).then( function(value){ console.log(&apos;p2 then then then value: &apos; + value); }, function(err){ console.log(&apos;p2 then then then err: &apos; + err); } ); 控制台输出： p1 then err: ReferenceError: foo is not defined p2 then value: 2 p1 then then value: undefined p2 then then err: ReferenceError: foo is not defined p2 then then then value: 1 Promise中的异常由then参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，then返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级then的回调函数是交替执行的 ，这正是由Promise then回调的异步性决定的。 7.Promise.resolve() var p1 = Promise.resolve( 1 ); var p2 = Promise.resolve( p1 ); var p3 = new Promise(function(resolve, reject){ resolve(1); }); var p4 = new Promise(function(resolve, reject){ resolve(p1); }); console.log(p1 === p2); console.log(p1 === p3); console.log(p1 === p4); console.log(p3 === p4); p4.then(function(value){ console.log(&apos;p4=&apos; + value); }); p2.then(function(value){ console.log(&apos;p2=&apos; + value); }) p1.then(function(value){ console.log(&apos;p1=&apos; + value); }) 控制台输出： true false false false p2=1 p1=1 p4=1 Promise.resolve(…)可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的then最先调用，但在控制台上是最后输出结果的呢？因为p4的resolve中接收的参数是一个Promise对象p1，resolve会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。 8.resolve vs reject var p1 = new Promise(function(resolve, reject){ resolve(Promise.resolve(&apos;resolve&apos;)); }); var p2 = new Promise(function(resolve, reject){ resolve(Promise.reject(&apos;reject&apos;)); }); var p3 = new Promise(function(resolve, reject){ reject(Promise.resolve(&apos;resolve&apos;)); }); p1.then( function fulfilled(value){ console.log(&apos;fulfilled: &apos; + value); }, function rejected(err){ console.log(&apos;rejected: &apos; + err); } ); p2.then( function fulfilled(value){ console.log(&apos;fulfilled: &apos; + value); }, function rejected(err){ console.log(&apos;rejected: &apos; + err); } ); p3.then( function fulfilled(value){ console.log(&apos;fulfilled: &apos; + value); }, function rejected(err){ console.log(&apos;rejected: &apos; + err); } ); 控制台输出： p3 rejected: [object Promise] p1 fulfilled: resolve p2 rejected: reject Promise回调函数中的第一个参数resolve，会对Promise执行”拆箱”动作。即当resolve的参数是一个Promise对象时，resolve会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；p2”拆箱”后，获取到Promise对象的状态是rejected，因此rejected回调被执行。但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。 转载自掘金","pubDate":"Thu, 10 Aug 2017 02:54:48 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2017/08/10/promise/","category":"web,ES6"},{"title":"css3","link":"https://wangdabaoqq.github.io/hexo-back-up/2017/07/22/px转rem/","description":"Sass基础——Rem与Px的转换 rem是CSS3中新增加的一个单位值，他和em单位一样，都是一个相对单位。不同的是em是相对于元素的父元素的font-size进行计算；rem是相对于根元素html的font-size进行计算。这样一来rem就绕开了复杂的层级关系，实现了类似于em单位的功能。 Rem的使用 前面说了em是相对于其父元素来设置字体大小的，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小，在我们多次使用时，就会带来无法预知的错误风险。而rem是相对于根元素，这样就意味着，我们只需要在根元素确定一个参考值，这个参考值设置为多少，完全可以根据您自己的需求来定。 假设就使用浏览器默认的字号16px，来看一些px单位与rem之间的转换关系： | px | rem | ------------------------ | 12 | 12/16 = .75 | | 14 | 14/16 = .875 | | 16 | 16/16 = 1 | | 18 | 18/16 = 1.125 | | 20 | 20/16 = 1.25 | | 24 | 24/16 = 1.5 | | 30 | 30/16 = 1.875 | | 36 | 36/16 = 2.25 | | 42 | 42/16 = 2.625 | | 48 | 48/16 = 3 | ------------------------- 如果你要设置一个不同的值，那么需要在根元素中定义，为了方便计算，时常将在元素中设置font-size值为62.5%: html { font-size: 62.5%; /* 10 ÷ 16 × 100% = 62.5% */ } 相当于在中设置font-size为10px，此时，上面示例中所示的值将会改变： | px | rem | ------------------------- | 12 | 12/10 = 1.2 | | 14 | 14/10 = 1.4 | | 16 | 16/10 = 1.6 | | 18 | 18/10 = 1.8 | | 20 | 20/10 = 2.0 | | 24 | 24/10 = 2.4 | | 30 | 30/10 = 3.0 | | 36 | 36/10 = 3.6 | | 42 | 42/10 = 4.2 | | 48 | 48/10 = 4.8 | ------------------------- 由于rem是CSS3中的一个属性，很多人首先关注的就是浏览器对他的支持度，我截了一张caniuse对rem属性的兼容表：从上图可以清楚的知道，rem在众多浏览器中都已得到很好的支持，如果您的项目不用考虑IE低版本的话，你就可以放心的使用了，如果您的项目在IE低版本中还占有不少的比例，那么你还在担心使用rem不能兼容，而不敢使用。其实是没有必要的，可以针对低版本的IE浏览器做一定的处理： html { font-size: 62.5%; } body { font-size: 14px; font-size: 1.4rem; } /* =14px */ h1 { font-size: 24px; font-size: 2.4rem; } /* =24px */ 这样一来解决了IE低版本的不能兼容的问题，但生出另一个不足地方，就是增加了代码量。必竟鱼和熊掌很多时候不能兼得嘛。 如果你想更深入的了解rem如何使用，建议您阅读： CSS3的REM设置字体大小——viaw3cplus FONT SIZING WITH REM——viaJonathan Snook There’s more to the CSS rem unit than font sizing——viacss-tricks In Defense Of Rem Units——viaMatthew Lettini Font sizing with rem could be avoided——viaHarry 响应式十日谈第一日：使用 rem 设置文字大小——via一丝 为什么要使用rem 像em单位一样，在Responsive设计中使用rem单位非常有用。虽然他们都是相对单位，但使用rem单位可以避开很多层级的关系。因为em是相对于他的父元素的font-size，而rem是相对于根元素。比如说h1设置了font-size为1rem之后，只要不重置html的font-size大小，无论他的父元素设置多大，对h1都不会有任何的影响。 Sass中rem的使用 在CSS中，实现px和rem转换非常简单，但每次使用都需进行计算。虽然在html中设置font-size:62.5%;会给大家带来便利，但终究有些烦人，也不是长远之计。既然我们学习了Sass，就应该思考如何让Sass来帮助我们做这些计算的工作。接下来介绍如何使用Sass实现px和rem之间的计算。 rem在@function中的使用 Sass中也可以像使用em一样，实现px转换为rem。这个过程也同样是通过Sass的@function方法来实现。 根据rem的使用原理，可以知道px转rem需要在html根元素设置一个font-size值，因为rem是相对于html根元素。在Sass中定义一个px转rem的函数，先要设置一个默认变量： $browser-default-font-size: 16px !default;//变量的值可以根据自己需求定义而且需要在html根元素中显示的声明font-size： html { font-size: $browser-default-font-size; } 然后通过@function来实现px转为rem计算： @function pxTorem($px){//$px为需要转换的字号 @return $px / $browser-default-font-size * 1rem; } 定义好@function之后，实际使用中就简单多了： //SCSS html { font-size: $browser-default-font-size; } .header { font-size: pxTorem(12px); } //CSS html { font-size: 16px; } .header { font-size: 0.75rem; } 不过定义的这个函数pxTorem()虽然实现了px转换成rem的计算，但不能同时服务于多个属性值的计算： .header { font-size: pxTorem(12px); margin: pxTorem(5px 10px);//同时计算多个值将报错 } 如果这样使用，编译的时候将会报错： &gt;&gt;&gt; Change detected to: /Users/airen/Sites/testSass/style.scss error style.scss (Line 4: Undefined operation: &quot;5px 10px/16px times 1rem&quot;.) 这也就是说，如果样式同时需要设置多个属性值的时候，pxTorem()变得就局限性太大，换句话说，这个函数仅适合运用在具有单个属性值的属性上，例如font-size。如果要强行使用，只能同时使用多个pxTorem()： //SCSS .header { font-size: pxTorem(12px); margin: pxTorem(5px) pxTorem(10px) pxTorem(15px); border: pxTorem(1px) solid #f36; } //CSS .header { font-size: 0.75rem; margin: 0.3125rem 0.625rem 0.9375rem; border: 0.0625rem solid #ff3366; } Sass中mixin实现rem 除了使用@function实现px转换成rem之外，还可以使用Sass中的mixin实现px转rem功能。 font-size是样式中常见的属性之一，我们先来看一个简单mixin，用来实现font-size的px转rem： @mixin font-size($target){ font-size: $target; font-size: ($target / $browser-default-font-size) * 1rem; } 在实际使用中，可以通过@include调用定义好的@mixin font-size: //SCSS .footer { @include font-size(12px); } //CSS .footer { font-size: 12px; font-size: 0.75rem; } 可实际中，这个mixin太弱小了，根本无法实现我们需要的效果，因为我们很多样式属性中他可不只一个属性。为了实现多个属性能设置多值，就需要对mixin做出功能扩展： @mixin remCalc($property, $values...) { $max: length($values);//返回$values列表的长度值 $pxValues: &apos;&apos;; $remValues: &apos;&apos;; @for $i from 1 through $max { $value: strip-units(nth($values, $i));//返回$values列表中的第$i个值，并将单位值去掉 $browser-default-font-size: strip-units($browser-default-font-size); $pxValues: #{$pxValues + $value * $browser-default-font-size}px; @if $i &lt; $max { $pxValues: #{$pxValues + &quot; &quot;}; } } @for $i from 1 through $max { $value: strip-units(nth($values, $i)); $remValues: #{$remValues + $value}rem; @if $i &lt; $max { $remValues: #{$remValues + &quot; &quot;}; } } #{$property}: $pxValues; #{$property}: $remValues; } 在这个remCalc()中定义了两个参数$property和$values…。其中$property表示的是样式属性，而$values…表示一个或者多个属性值。 注：在上面定义的remCalc中使用了下自定义的函数strip-units，主要用来去除单位，详细的请参阅Sass基础——PX to EM Mixin和@function一文中的strip-units函数定义方法。 px转rem的mixin定义完成后，就可以通过@include来引用： //SCSS .wrapper { @include remCalc(width,45); @include remCalc(margin,1,.5,2,3); } //CSS .wrapper { width: 720px; width: 45rem; margin: 16px 8px 32px 48px; margin: 1rem 0.5rem 2rem 3rem; } 在实际使用中取值有一点非常重要在remCalc()取的$values值为rem值。 总结 在这篇文章中，简单介绍了在Sass中如何定义@function和@mixin来实现px转换成rem的计算。希望大家能在这篇文章中找到自己需要的灵感。 转载自© w3cplus.com","pubDate":"Sat, 22 Jul 2017 05:57:48 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2017/07/22/px转rem/","category":"综合,css3"},{"title":"music","link":"https://wangdabaoqq.github.io/hexo-back-up/2017/07/18/认错/","description":"认错-林志炫","pubDate":"Tue, 18 Jul 2017 10:30:48 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2017/07/18/认错/","category":"综合,music"},{"title":"windows-ubuntu","link":"https://wangdabaoqq.github.io/hexo-back-up/2017/06/29/windows-ubuntu/","description":"前段时间从windows服务器换到了ubuntu服务器,讲道理ubuntu是真的比windows好用,当然linux的也是类似的,没用过就不多BB,我强烈推荐一波,如果说你正好要买服务器,考虑下linux的系统的服务器,当然你说不会什么shell命令什么都没有关系,跟着视频撸一遍,这样下来新鲜感十足,如有神助。可能我bb一通,还是觉得没有实例来的痛快,我说下我用的ubuntu的部署的node项目。之前我用的也是windows的服务器,windows服务器本身是没有什么问题的。(只是对我而言)在windows上我采用的是本地更改项目代码然后通过ftp或者qq邮箱(呵呵)但是这两种方式,无论是哪一种都要去远程连接服务器,然后去重启服务,我觉得很麻烦,登来登去的很烦,很偶然看到ubuntu可以通过pm2部署,这样我给大家看下我pm2的代码 ecosystem.jsons { \"apps\":[{ \"name\":\"xiaomo\", \"script\":\"app.js\", \"env\":{ \"COMMON_VARIABLE\":\"true\" }, \"env_production\":{ \"NODE_ENV\":\"production\" } } ], \"deploy\":{ \"production\":{ \"user\":\"wangdabao\", \"host\":[\"47.94.153.153\"], \"ref\":\"origin/master\", \"repo\":\"git@git.oschina.net:wangdabaoqq/node-millet.git\", \"path\":\"/www/xiao/production\", \"ssh_options\":\"StrictHostKeyChecking=no\", \"post-deploy\":\"npm install --registry=https://registry.npm.taobao.org && pm2 startOrRestart ecosystem.json --env production\", \"env\":{ \"NODE_ENV\":\"production\" } } } } 当然我也是按照pm2官网的进行的编写,具体里面代表的意思可以看下pm2官网的部署http://pm2.keymetrics.io/docs/usage/deployment/我也贴下链接,如果有兴趣的可以看下,当然这个必须要配合的是github或者是码云,coding等等我在这里也不说了,因为可以从上面的代码中看到我们的代码是从码云拉取的所以,到这里又有一个问题了私钥或者公钥,当然关于私钥和公钥是和git有关系的,如果你没有配置或者生成可以百度下非常简单,生成完以后要把私钥放到git或者码云的ssh上面,这样写完以后还要在服务器上添加私钥和公钥,一上弄完以后,我们就可以通过命令 git add .git commit -m ‘update’git push origin master由于你是第一次使用所有要先git remote add origin +上你的ssh或者https的git项目地址第一次进行上传pm2 deploy ecosystem.json production setup以后每次都可以直接pm2 deploy ecosystem.json production setup 最后我推荐个慕课网上的一个视频叫Node.js项目的线上服务器部署与发布看完以后你会有一个全新的了解与认识。 ↓↓打下广告各位看官老爷们动动小手指给个start,我会继续努力让你们不喜欢的,先谢谢爸爸们,告辞. 传送门","pubDate":"Thu, 29 Jun 2017 05:30:48 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2017/06/29/windows-ubuntu/","category":"综合,服务器"},{"title":"技术贴","link":"https://wangdabaoqq.github.io/hexo-back-up/2017/04/15/技术贴/","description":"###五. 资源教程: 综合类 前端知识体系前端知识结构Web前端开发大系概览Web前端开发大系概览-中文版Web Front-end Stack v2.2En类资源汇总免费的编程中文书籍索引前端书籍前端免费书籍大全免费的编程中文书籍索引智能社 - 精通JavaScript开发重新介绍 JavaScript（JS 教程）麻省理工学院公开课：计算机科学及编程导论JavaScript中的this陷阱的最全收集–没有之一JS函数式编程指南JavaScript Promise迷你书（中文版）腾讯移动Web前端知识库Front-End-Develop-Guide 前端开发指南前端开发笔记本大前端工具集 - 聂微东前端开发者手册前端开发者手册JavaScript 资源大全中文版伯乐在线 - 资源大全伯乐在线 - 前端资源库入门类 前端入门教程瘳雪峰的Javascript教程jQuery基础教程前端工程师必备的PS技能——切图篇结合个人经历总结的前端入门方法效果类 弹出层焦点图轮播特效工具类 css sprite 雪碧图制作版本控制入门 – 搬进 GithubGrunt-beginner前端自动化工具慕课专题 张鑫旭 - 慕课系列lyn - 慕课系列艾伦 - 慕课系列碧仔 - Hello，移动WEBhaorooms - js/jquery宽高介绍周刊类 百度FEX技术周刊平安科技移动开发二队技术周报360奇舞周刊 ###六. API: ####1. 总目录 开发中心 mozilla js参考chrome开发中心（chrome的内核已转向blink）safari开发中心microsoft js参考js秘密花园js秘密花园w3help 综合Bug集合网站综合搜索 javascripting各种流行库搜索综合API runoob.com-包含各种API集合开源中国在线API文档合集devdocs 英文综合API网站devdocs 中文综合API网站overapi 英文综合API网站 ####2. jQuery jQuery API 中文文档hemin 在线版css88 jq apicss88 jqui api学习jqueryjquery 源码查找 ####3. Ecmascript Understanding ECMAScript 6 - Nicholas C. Zakasexploring-es6exploring-es6翻译exploring-es6翻译后预览阮一峰 es6阮一峰 JavascriptECMA-262，第 5 版es5 ####4. Js template template-chooserartTemplatetomdjs淘宝模板juicer模板Fxtpl v1.0 繁星前端模板引擎laytplmozilla - nunjucksJuicerdustjsetpltwitter-tpl ####5. 弹出层 artDialog 最新版artDialog 文档google code 下载地址贤心弹出层响应式用户交互组件库sweetalert-有css3动画弹出层 ####6. CSS CSS 语法参考CSS3动画手册alloyteam - CSS3 UI 库腾讯css3动画制作工具志爷css小工具集合css3 js 移动大杂烩bouncejs 触摸库css3 按钮动画animate.css全局CSS的终结(狗带) [译]ANIMATION - 大漠css选择器 ####7. Angularjs Angular.js 的一些学习资源angularjs中文社区Angular Style GuideAngularjs源码学习Angularjs源码学习angular对bootstrap的封装angularjs + nodejs吕大豹 AngularjsAngularJS 最佳实践Angular的一些扩展指令Angular数据绑定原理一些扩展Angular UI组件Ember和AngularJS的性能测试带你走近AngularJS - 基本功能介绍Angularjs开发指南Angularjs学习不要带着jQuery的思维去学习AngularJSangularjs 学习笔记angularjs 开发指南angularjs 英文资料angular bootstrapangular jq mobileangular ui整合jQuery Mobile+AngularJS经验谈有jQuery背景，该如何用AngularJS编程思想AngularJS在线教程angular学习笔记UI Bootstrap - AngularJS directives specific to BootstrapNG Bootstrap - Angular 2 directives specific to Bootstrap 4 ####8. React react海量资源react.js 中文论坛react.js 官方网址react.js 官方文档react.js material UIreact.js TouchstoneJS UIreact.js amazeui UIReact 入门实例教程 - 阮一峰React Native 中文版Webpack 和 React 小书 - 前端乱炖Webpack 和 React 小书 - gitbookReact原创实战视频教程React 入门教程react-webpack-starter基于react组件化开发React 编程规范(by Airbnb)React Webpack小说ant.design ####9. 移动端API API99移动端知识集合移动端前端开发知识库移动前端的一些坑和解决方法（外观表现）【原】移动web资源整理zepto 1.0 中文手册zepto 1.0 中文手册zepto 1.1.2zepto 中文注释jqmobile 手册移动浏览器开发集合移动开发大杂烩微信webview中的一些问题框架特色的HTML框架可以创建精美的iOS应用淘宝SUI ####10. avalon avalonjsAvalon新一代UI库： OniUIavalon.oniui-基于avalon的组件库 ####11. Requriejs Javascript模块化编程（一）：模块的写法Javascript模块化编程（二）：AMD规范Javascript模块化编程（三）：require.js的用法RequireJS入门（一）RequireJS入门（二）RequireJS进阶（三）requrie源码学习requrie 入门指南requrieJS 学习笔记requriejs 其一require backbone结合 ####12. Seajs seajsseajs 中文手册JavaScript模块化开发库之SeaJS ####13. Less,sass sasssass教程-sass中国Sass 中文文档less ####14. Markdown Markdown 语法说明 (简体中文版)markdown入门参考gitbook 国外的在线markdown可编辑成书mdeditor 一款国内的在线markdown编辑器stackedit 国外的在线markdown编辑器，功能强大，同步云盘mditor 一款轻量级的markdown编辑器lepture-editormarkdown-editorMarkdown 在线编辑器 ####15. D3 d3 TutorialsGallerylofteriteyeruanyifeng ####16. 兼容性 esma 兼容列表W3C CSS验证服务caniusecsscreatormicrosoft在线测兼容-移动端emulators ####17. UI相关 bootcssMetroUICSSsemanticButtonskitecsspintueramazeuiworldhellolinuxtoygitmagicrogerdudlergitrefbookgogojimmy ####18. HTTP HTTP API 设计指南 ####19. 其它API javascript流行库汇总验证apiunderscore 中文手册underscore源码分析underscore源码分析-亚里士朱德的博客underscrejs en apilodash - underscore的代替品ext4apibackbone 中文手册qwrap手册缓动函数svg 中文参考svg mdn参考svg 导出 canvassvg 导出 pngai-to-svglocalStorage 库 ####20. 图表类 Highcharts 中文APIHighcharts 英文APIECharts 百度的图表软件高德地图开源的矢量图脚本框架svg 地图jQuery Vector Map Library ####21. vue VueVue 论坛Vue 入门指南Vue 的一些资源索引 ####21. 正则 JS正则表达式元字符正则表达式30分钟入门教程MDN-正则表达式ruanyifeng - RegExp对象小胡子哥 - 进阶正则表达式is.js正则在线测试haorooms正则文章 ####22. ionic ionic ####23. 其它 Mock.js 是一款模拟数据生成器jsdoc 注释生成 - apidocjs ###七. 开发规范 前端 通过分析github代码库总结出来的工程师代码书写习惯HTML&amp;CSS编码规范 by @mdo前端编码规范之js - by yuwenhui前端编码规范之js - by 李靖前端开发规范手册Airbnb JavaScript 编码规范（简体中文版）AMD与CMD规范的区别AMD与CMD规范的区别KISSY 源码规范bt编码规范规范加强版前端代码规范 及 最佳实践百度前端规范百度前端规范百度前端规范ECMAScript6 编码规范–广发证券前端团队JavaScript 风格指南/编码规范（Airbnb公司版）网易前端开发规范css模块前端规范资源列表前端JavaScript规范Nodejs Node.js 风格指南PHP 最流行的PHP 代码规范最流行的PHP 代码规范Android 【敏捷开发】Android团队开发规范Android 开发规范与应用IOS Swift Style Guide ###八. 其它收集 ####1. 各大公司开源项目 Facebook Facebook Projects百度 Baidu 百度web前端研发部百度EFE百度github腾讯 qq alloyteamalloyteam-githuballoyteam-AlloyGameEngineAlloyDesigner 即时修改，即时保存，设计稿较正，其它开发辅助工具H5交互页编辑器AEditor介绍 H5动画交互页开发的工具介绍AEditor H5动画交互页开发的工具腾讯html5腾讯开源项目奇舞团 奇舞团开源项目去哪儿 Qunar UED其它 maka值得订阅的weekly ####2. Javascript 常用 ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性模拟键盘拼音中国个人身份证号验证算法 数据结构与算法 JavaScript 描述. 章节练习常见排序算法（JS版）经典排序常见排序算法-js版本JavaScript 算法与数据结构 精华集面试常考算法题精讲移动端 fastclickno-click-delayJSON 模拟生成JSON数据返回跨域JSONAPI ####3. Html5 HTML5 有哪些让你惊艳的 demo？html5 Canvas画图系列教程目录 ####4. CSS browserhacks ####5. jQuery 焦点图 myfocusmyfocus-官方演示站SuperSlidev2.1 – 大话主席soChange ####6. Ext, EasyUI, J-UI 及其它各种UI方案 Ext extjsext4英文apiext4中文apiEasyUI jquery easyui 未压缩源代码J-UI J-UIOther MUI-最接近原生APP体验的高性能前端框架Amaze UI | 中国首个开源 HTML5 跨屏前端框架淘宝 HTML5 前端框架KISSY - 阿里前端JavaScript库网易Nej - Nice Easy JavascriptKendo UI MVVM DemoBootstrapSmart UI雅虎UI - CSS UI ####7. 页面 社会化 分享功能 百度分享 pc端JiaThis pc端社会化分享组件 移动端ShareSDK 轻松实现社会化功能 移动端友盟分享 移动端addthis 国外社交分享一键分享到各种SNS ####8. 富文本编辑器 百度 ueditor经典的ckeditor经典的kindeditorwysiwyg一个有情怀的编辑器。Bach’s Editortower用的编辑器summernote 编辑器html5编辑器XEditorwangEditorwangEditor-mobile–移动端编辑器Trumbowyg - 轻量编辑器国外的一款编辑器 - tinymce ####9. 日历 PC 经典my97强大的独立日期选择器fullcalendarfullcalendar日历控件知识点集合中文api农历日历超酷的仿百度带节日日历老黄历控件日期格式化大牛日历控件我群某管理作品input按位替换-官网input按位替换-githubbootstrap-daterangepicker国外30个插件集合JavaScript datepickerDatepair.js一个风格多样的日历弹出层式的全日历jquery双日历bootstrap-datetimepicker/贤心-laydatePikaday-微型日历AngularJS datepicker directives周选择日历插件移动 大气实用jQuery手机移动端日历日期选择插件jQuery Mobile 移动开发中的日期插件MobiscrollDate library Datejssugarjs ####10. 综合效果搜索平台 效果网17素材常用的JavaScript代码片段 ####11. 前端工程化 概述 前端工具大全什么是前端工程化Gulp Gulp官网Gulp中文网gulp资料收集Gulp：任务自动管理工具 - ruanyifengGulp插件Gulp不完全入门教程为什么使用gulp?Gulp安装及配合组件构建前端开发一体化Gulp 入门指南Gulp 入门指南 - nimojsGulp入门教程Gulp in ActionGulp开发教程（翻译）前端构建工具gulpjs的使用介绍及技巧Grunt gruntjsGrunt中文网Grunt入门教程Fis fis 官网fiswebpack webpackWebpack 中文指南Webpack，101入门体验webpack入门教程基于webpack搭建前端工程解决方案探索Webpack傻瓜式指南（一）Webpack指南webpack指南webpack 教程资源收集 ####12. 轮播图 pc图轮 单屏轮播sochange左右按钮多图切换fullpage全屏轮播haorooms资源库轮播大全移动端 无缝切换滑屏效果全屏fullpage单个图片切换单个全屏切换百度的切换库单个全屏切换滑屏效果旋转拖动设置类似于swipe切换支持多种形式的触摸滑动滑屏效果大话主席pc移动图片轮换滑屏效果基于zepto的fullpage[WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应判断微信客户端的那些坑可以通过javascript直接调用原生分享的工具JiaThis 分享到微信代码聊聊移动端跨平台开发的各种技术前端自动化测试多种轮换图片滑动侧边栏 ####13. 文件上传 百度上传组件上传flash 头像上传图片上传预览图片裁剪图片裁剪-shearphotojQuery图片处理文件上传 ####14. 模拟select 糖饼 selectflexselect双selectselect2 ####15. 取色插件 类似 Photoshop 的界面取色插件jquery color取色插件集合farbtastic 圆环＋正方形 ####16. 城市联动 jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果移动端省市三级联动demo ####17. 剪贴板 剪贴板clipboard 最新的剪切方案 ####18. 简繁转换 简繁转换 ####19. 表格 Grid facebook表格类似于Excel编辑表格-handsontablebootstrap-table插件datatables不错的Grid ####20. 在线演示 js 在线编辑 - runjsjs 在线编辑 - jsbinjs 在线编辑 - codepenjs 在线编辑 - jsfiddlephpfiddlejava 在线编辑 - ideonejs 在线编辑 - hchartsjs 在线编辑 - jsdmsql 在线编辑 - sqlfiddlemozilla 在线编辑器 ####21. 播放器 Html5 VideoPlayer ####22. 粒子动画 Proton 烟花 ####23. 表单验证 ValidformformvalidatorjQuery formValidator表单验证完美解决方案 ####24. 表单美化 美化checkbox ###九. Nodejs Node.js 包教不包会篇幅比较少node express 入门教程nodejs定时任务一个nodejs博客【NodeJS 学习笔记04】新闻发布系统过年7天乐，学nodejs 也快乐七天学会NodeJSNodejs学习笔记（二）— 事件模块nodejs入门angularjs nodejs从零开始nodejs系列文章理解nodejsnodejs事件轮询node入门nodejs cmsNode初学者入门，一本全面的NodeJS教程NodeJS的代码调试和性能调优runs Node.js programs through Chromium DevTools ###十. 性能优化 常规优化 Javascript高性能动画与页面渲染移动H5前端性能优化指南5173首页前端性能优化实践给网页设计师和前端开发者看的前端性能优化复杂应用的 CSS 性能分析和优化建议张鑫旭——前端性能前端性能监控总结网站性能优化之CSS无图片技术web前端性能优化进阶路前端技术：网站性能优化之CSS无图片技术浏览器的加载与页面性能优化页面加载中的图片性能优化Hey——前端性能html优化99css——性能Yslow——性能优化YSLOW中文介绍转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化Yahoo!团队实践分享：网站性能网站性能优化指南：什么使我们的网站变慢？网站性能优化实践，减少加载时间，提高用户体验浅谈网站性能优化 前端篇前端重构实践之如何对网站性能优化？前端性能优化：使用媒体查询加载指定大小的背景图片网站性能系列博文加载，不只是少一点点前端性能的测试与优化分享网页加载速度优化的一些技巧？页面加载中的图片性能优化web前端优化(基于Yslow)网站性能优化工具大全【高性能前端1】高性能HTML【高性能前端2】高性能CSS由12306谈谈网站前端性能和后端性能优化AlloyTeam——前端优化毫秒必争，前端网页性能最佳实践网站性能工具Yslow的使用方法前端工程与性能优化（上）：静态资源版本更新与缓存前端工程与性能优化（下）：静态资源管理与模板框架HTTPS连接的前几毫秒发生了什么YslowEssential Web Performance Metrics — A Primer, Part 1Essential Web Performance Metrics — Part 2YUISlide,针对移动设备的动画性能优化Improving Site Performance让网站提速的最佳前端实践Why Website Speed is ImportantNeed for Speed – How to Improve your Website Performance阿里无线前端性能优化指南 (Pt.1 加载期优化)前端性能优化补充篇优化工具 JavaScript 性能分析新工具 OneProfileJavaScript 堆内存分析新工具 OneHeap在线工具 google在线工具阿里测阿里-免费测试服务阿里-F2etest多浏览器兼容性测试解决方案js性能测试轻松玩转PDF ###十一. 前端架构 技术架构前端架构如何成为前端架构师关于前端架构-张克军百度腾讯offer比较（腾讯游戏VS百度基础架构） ###十二. 个人作品 ####1. 推荐作品 winter代码片段需要翻墙fgm岑安作品集当耐特demo集合米空格 js作品myFocusSeaJS组件库颜海镜作品脚儿网作品javascript个人作品妙味的雷东升游戏作品javascript作品集云五笔，灰度产生生成工具项目主页个性的作品主页ucren js demos 集智能社实例陈列架zoye demo王员外平凡jyg 游戏案例很多jquery插件不羁虫 - soJs 作品系列frozenui黑白棋fromone ####2. 群员作品 MDialog - [合肥-M.J]轮播图 - [上海－冷静][广州—坚壳][成都 - 无痕] 感恩节专题[球霸天][北京-小数][ptf] Magix 工具[杭州-Pft] Magix 基于 MVC 结构和 Hash 驱动的 OPOA（One Page One Application）应用[上海-剧中人]-实验室[上海-豪情 ] 作品集合[成都-feeling][上海-angela][海南-hank]作品[上海-张力]博客[上海-zenki]作品移动端图案解锁[合肥-M.J] - MPreview 移动端图片预览组[合肥-M.J] - Mexam 移动端在线做题组[北京-苏瑞] - dancer小人[上海-玄沐]- 个人网站[厦门-二哲]- 个人博客 ####3. 国外大牛精品 pazguille ###十三. 简历 生成 MarkDown在线简历工具MarkDown在线简历工具模板 简历张伦简历翁天信动画方式的简历组件丰富简历简历池haorooms博客Justin Young各个程序员简历模板 ###十四. 面试题 前端 那几个月在找工作（百度，网易游戏）名企笔试大全2016校招内推 – 阿里巴巴前端 – 三面面试经历年后跳槽那点事：乐视+金山+360面试之行拉勾网js面试题前端面试前端开发面试题百度面试前端工作面试问题前端开发面试题5个经典的前端面试问题如何面试一名前端开发工程师？前端实习生面试总结史上最全 前端开发面试问题及答案整理BAT及各大互联网公司2014前端笔试面试题：JavaScript篇前端开发面试题大收集收集的前端面试题和答案如何面试前端工程师前端开发面试题牛客网-笔试面经Front End Developer Questions40 个重要的 HTML5 面试问题及答案java Java工程师笔试题整理[校招篇] ###十五. iconfont 中文字体淘宝字库字体制作教程zhangxinxu-icommonicommon用字体在网页中画ICON图标(推荐教程)字体压缩工具 感谢初级群 [深圳-小鱼] 的推荐 ###十六. 开发工具类 前端开发工具 IntelliJ IDEA 简体中文专题教程Webstorm,InterllIdea,PhpstormSublimeTextAtomAtom飞行手册（中文版）Atom-vue代码高亮visual studio codevisual studio code 使用指南Chrome, Firebug, Filddle 调试 Fiddler Fiddler调式使用知多少(一)深入研究微信fiddle微信fiddleChrome Google Chrome 官方Chrome - 基础Chrome - 进阶Chrome - 性能Chrome - 性能进阶Chrome - 移动Chrome - 使用技巧Chrome - Console控制台不完全指南Chrome - Workspace使浏览器变成IDEnetwork面板chrome开发工具快捷键chrome调试工具常用功能整理Chrome 开发工具 Workspace 使用Chrome神器Vimium快捷键学习记录sass调试-w3cplus如何更专业的使用Chrome开发者工具-w3cpluschrome调试canvaschrome profiles1chrome profiles2chrome profiles3chrome移动版调试chrome调试chrome的调试chrome console 命令详解查看事件绑定1查看事件绑定2神器——Chrome开发者工具(一)奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍)chrome 开发者工具的 15 个小技巧Chrome开发者工具不完全指南Chrome 开发者工具使用技巧Chrome渲染分析之Rendering工具使用(1)Chrome渲染分析之Rendering工具使用(2)Chrome渲染分析之Rendering工具使用(3)像 Sublime Text 一样使用 Chrome DevToolsChorme 35个开发者工具的小技巧Chrome 实用调试技巧Firebug firebug视频教程firefox 模拟器console.log 命令详解Firebug入门指南Firebug控制台详解移动,微信调试 微信调试的那些事微信调试官网微信公众号本地调试微信、手Q、Qzone之x5内核inspect调试解决方案浏览器端调试安卓移动端前端开发调试使用 Chrome 远程调试 Android 设备mac移动端调试mac移动端调试无线调试攻略无线调试攻略屌爆了,完美调试 微信webview(x5)远程console微信调试工具各种真机远程调试方法汇总手机测试自己写的web页面iOS Simulator SimulatorXcode中的iOS模拟器(iOS Simulator)的介绍和使用心得img loading img智图-图片优化平台在线png优化生成二维码 生成二维码浏览器同步 puerliveReloadf5File Watchers在线PPT制作 nodePPTPPTrevealslippy ###十七. 前端导航网站 前端导航前端网址导航前端名录前端导航前端开发资源前端开发仓库 - 众多效果的收集地前端资源导航F2E 前端导航前端收藏夹前端导航前端工具箱前端人俱乐部-灵感_Ideahaorooms前端导航 ###十八. 常用CDN 新浪CDN百度静态资源公共库360网站卫士常用前端公共库CDN服务Bootstrap中文网开源项目免费 CDN 服务开放静态文件 CDN - 七牛CDN加速 - jq22jQuery CDNGoogle jQuery CDN微软CDN ###十九. Git,SVN,Github Git git-scm廖雪峰-Git教程git-for-windowsGitHub 添加 SSH keysgogithubgit常规命令练习git的资料整理我所记录的git命令（非常实用）企业开发git工作流模式探索部分休整GitHub 漫游指南GitHub秘籍使用git和github进行协同开发流程动画方式练习git版本管理工具介绍—Git篇版本控制入门 – 搬进 GithubGit动画演示SVN 版本管理工具介绍—SVN篇 正文来自https://github.com/jsfront/src/blob/master/qq.md本文转载","pubDate":"Sat, 15 Apr 2017 05:30:48 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2017/04/15/技术贴/","category":"综合,技术"},{"title":"'福利 - 不过百行代码的爬虫爬取美女图'","link":"https://wangdabaoqq.github.io/hexo-back-up/2017/02/14/node爬虫/","description":"最近看到序言 闲的无聊，看到一个段子网站的美女福利还不错，迫于福利加载太慢看的不过瘾，就想用Nodejs写个简单爬虫全部爬下来看多好….. 此处省略5000字….. 准备 要爬，首先得要有目标，我呢，就把目标锁定到了 某哈，然后呢就是用浏览器来分析分析其中的规律 从中可以看到每一条段子都是一个 .joke-list-item, 当点击下一页的时候 url中地址的最后一位数就表示分页的页码。有些图片是缩略图，我们把缩略图和正常图的地址进行了比较，发现他们的地址格式是一样的，缩略图在small文件夹下，大图在big文件夹下。分析完了我们就可以写代码了。 开始 这个简单爬虫分两个部分，1、获取图片地址。2、进行下载。因为下载是一个耗时的操作，所以两个部分分开了，这样也有利于后期改动。 导入必要的模块，使用cheerio 是第三方模块，可以使用 npm install cheerio 进行安装12345678910111213141516171819202122232425262728293031323334353637383940 var http = require('http'); // http 网路 var cheerio = require('cheerio'); // html 解析 var fs = require(\"fs\"); // 流 var queryHref = \"http://www.haha.mx/topic/1/new/\"; // 设置被查询的目标网址 var querySearch = 1; // 设置分页位置 var urls = []; // 所有待下载的图片地址这个是解析图片地址方法/** * 根据url和参数获取分页内容 * @param &#123;String&#125;： url * @param &#123;int&#125;： serach */&lt;pre&gt;function getHtml(href, serach) &#123; var pageData = \"\"; var req = http.get(href + serach, function(res) &#123; res.setEncoding('utf8'); res.on('data', function(chunk) &#123; pageData += chunk; &#125;); res.on('end', function() &#123; $ = cheerio.load(pageData); var html = $(\".joke-list-item .joke-main-content a img\"); for(var i = 0; i &lt; html.length; i++) &#123; var src = html[i].attribs.src; // 筛选部分广告，不是真的段子 if (src.indexOf(\"http://image.haha.mx\") &gt; -1) &#123; urls.push(html[i].attribs.src) &#125; &#125; &#125;); &#125;);&#125; 这个是下载图片的方法 /** 下载图片 @param {String} imgurl：图片地址*/ 1234567891011121314151617181920212223function downImg(imgurl) &#123; var narr = imgurl.replace(\"http://image.haha.mx/\", \"\").split(\"/\") http.get(imgurl.replace(\"/small/\", \"/big/\"), function(res) &#123; var imgData = \"\"; //一定要设置response的编码为binary否则会下载下来的图片打不开 res.setEncoding(\"binary\"); res.on(\"data\", function(chunk) &#123; imgData += chunk; &#125;); res.on(\"end\", function() &#123; var savePath = \"./upload/topic1/\" + narr[0] + narr[1] + narr[2] + \"_\" + narr[4]; // 保存图片 fs.writeFile(savePath, imgData, \"binary\", function(err) &#123; if(err) &#123; console.log(err); &#125; &#125;); &#125;); &#125;);&#125; 好，到这里核心的东西就写完了，然后就是组装一下，让他运行起来 附一个完整代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var http = require('http'); // http 网路var cheerio = require('cheerio'); // html 解析var fs = require(\"fs\"); // 流var queryHref = \"http://www.haha.mx/topic/1/new/\"; // 设置被查询的目标网址var querySearch = 1; // 设置分页位置var urls = [];var sumConut = 0;var reptCount = 0; // 重复的var downCount = 0; // 实际下载的/** * 根据url和参数获取分页内容 * @param &#123;String&#125;： url * @param &#123;int&#125;： serach */function getHtml(href, serach) &#123; console.log(\"正在获取第 \"+serach + \" 页的图片\"); var pageData = \"\"; var req = http.get(href + serach, function(res) &#123; res.setEncoding('utf8'); res.on('data', function(chunk) &#123; pageData += chunk; &#125;); res.on('end', function() &#123; $ = cheerio.load(pageData); var html = $(\".joke-list-item .joke-main-content a img\"); for(var i = 0; i &lt; html.length; i++) &#123; var src = html[i].attribs.src; // 筛选部分广告，不是真的段子 if (src.indexOf(\"http://image.haha.mx\") &gt; -1) &#123; urls.push(html[i].attribs.src) &#125; &#125; // 递归调用 if (serach &lt; pagemax) &#123; getHtml(href, ++serach); &#125; else &#123; console.log(\"图片链接获取完毕！\"); sumConut = urls.length; console.log(\"链接总数量：\" + urls.length); console.log(\"开始下载......\"); downImg(urls.shift()); &#125; &#125;); &#125;);&#125; /** 下载图片 @param {String} imgurl：图片地址*/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function downImg(imgurl) &#123; var narr = imgurl.replace(\"http://image.haha.mx/\", \"\").split(\"/\") // 做一步优化，如果存在文件，则不下载 var filename = \"./upload/topic1/\" + narr[0] + narr[1] + narr[2] + \"_\" + narr[4]; fs.exists(filename, function(b)&#123; if (!b) &#123; // 文件不存则进行 下载 http.get(imgurl.replace(\"/small/\", \"/big/\"), function(res) &#123; var imgData = \"\"; //一定要设置response的编码为binary否则会下载下来的图片打不开 res.setEncoding(\"binary\"); res.on(\"data\", function(chunk) &#123; imgData += chunk; &#125;); res.on(\"end\", function() &#123; var savePath = \"./upload/topic1/\" + narr[0] + narr[1] + narr[2] + \"_\" + narr[4]; fs.writeFile(savePath, imgData, \"binary\", function(err) &#123; if(err) &#123; console.log(err); &#125; else &#123; console.log(narr[0] + narr[1] + narr[2] + \"_\" + narr[4]); if (urls.length &gt; 0) &#123; downImg(urls.shift()); downCount++; console.log(\"剩余图片数量....\"); &#125; &#125; &#125;); &#125;); &#125;); &#125; else &#123; // 统计重复的图片 console.log(\"该图片已经存在重复.\"); reptCount++; if (urls.length &gt; 0) &#123; downImg(urls.shift()); &#125; &#125; &#125;); if (urls.length &lt;= 0) &#123; console.log(\"下载完毕\"); console.log(\"重复图片：\" + reptCount); console.log(\"实际下载：\" + downCount); &#125;&#125;var pagemax = 30; // 获取到多少页的内容var startindex = 1; // 从多少页开始获取function start()&#123; console.log(\"开始获取图片连接\"); getHtml(queryHref, startindex);&#125;start(); 因为nodejs是异步的，所以在 start 方法中的for之后调用下载是不行，这个时候显示的 urls 中是没有数据的。 所以就是在 getHtml 中 等所有的连接分析完毕之后在调用 downImg，downImg下载完成之后在进行下一个下载。 项目目录很简单，如图： 然后我们切换到项目目录，执行 node app , 然后就静静的等待把，每次下载完一个会有对应的文件名打印出来的。 最后会出现 下载完毕！，之后就……. 你懂得…… 这个是一个很简单的，当然后续你可以加上数据库，数据更新之类的….. 放几张我爬到的图 。 。 。 。 。 。 。 。 。 注意前方高能 注意前方高能 注意前方高能 。 。 。 。 。 。 。 。 。 。 。 。 嘘… 不要告诉别人…. 原文地址:https://zhuanlan.zhihu.com/p/24730075","pubDate":"Tue, 14 Feb 2017 01:54:48 GMT","guid":"https://wangdabaoqq.github.io/hexo-back-up/2017/02/14/node爬虫/","category":"web,node"}]}