<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>o.o</title>
  <icon>https://www.gravatar.com/avatar/7d474fb471782a29372082c2d2649d01</icon>
  <subtitle>小儿无名,不耻而学。</subtitle>
  <link href="/me/atom.xml" rel="self"/>
  
  <link href="https://wangdabao.js.org/"/>
  <updated>2020-07-05T11:49:17.871Z</updated>
  <id>https://wangdabao.js.org/</id>
  
  <author>
    <name>o.o</name>
    <email>614692339@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&#39;underscore算法之二分查找&quot;&#39;</title>
    <link href="https://wangdabao.js.org/2020/03/26/underscore%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://wangdabao.js.org/2020/03/26/underscore之二分查找/</id>
    <published>2020-03-26T02:00:00.000Z</published>
    <updated>2020-07-05T11:49:17.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote><p>最近一直在看underscore.js, 刚好有看到我比较感兴趣的地方, 里面涉及到了二分查找, 索性拿出来记录下。</p></blockquote><h2 id="underscore-js之sortedIndex"><a href="#underscore-js之sortedIndex" class="headerlink" title="underscore.js之sortedIndex"></a>underscore.js之sortedIndex</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.sortedIndex = <span class="function"><span class="keyword">function</span>(<span class="params">array, obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">    iteratee = cb(iteratee, context, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> value = iteratee(obj);</span><br><span class="line">    <span class="keyword">var</span> low = <span class="number">0</span>, high = getLength(array);</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">      <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (iteratee(array[mid]) &lt; value) low = mid + <span class="number">1</span>; <span class="keyword">else</span> high = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>二分查找关键在于首先要保证要查找的元素是(有序的, 数组)！！</strong><br>二分查找比平常的按照顺序的方式查找效率更高(不用对去全部的元素进行遍历), 二分查找是选取一个中间值一分为二, 对中间值跟要查找的元素比对来决定向左或者向右查找, 如果当前值小于查找元素, 则向右查找, 当前值大于或者等于查找元素, 则向左查找。<br>直到条件不满足 =&gt; 返回</p><h2 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line">查找元素是 <span class="number">8</span></span><br><span class="line"><span class="keyword">var</span> low = <span class="number">0</span> 初始值</span><br><span class="line"><span class="keyword">let</span> high = sortArr.length</span><br><span class="line"><span class="keyword">while</span>(low &lt; high) 循环执行直到条件不满足</span><br><span class="line"><span class="keyword">while</span>内进行一分为二, </span><br><span class="line">向下取整获取中间值, <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>) mid = <span class="number">2</span></span><br><span class="line">sortArr(mid) =&gt; <span class="number">5</span></span><br><span class="line">条件判断(sortArr(mid) &lt; 进行查找的元素 =&gt; <span class="number">8</span>) </span><br><span class="line">执行三遍</span><br><span class="line">第一遍 <span class="number">5</span> &lt; <span class="number">8</span> low = <span class="number">3</span></span><br><span class="line">第二遍 <span class="number">12</span> &lt; <span class="number">8</span> high = <span class="number">4</span></span><br><span class="line">第三遍 <span class="number">10</span> &lt; <span class="number">8</span> high = <span class="number">3</span></span><br><span class="line">最后 返回 所在位置</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近一直在看underscore.js, 刚好有看到我比较感兴趣的地方, 里面涉及到了二分查找, 
      
    
    </summary>
    
    
      <category term="underscore.js" scheme="https://wangdabao.js.org/tags/underscore-js/"/>
    
  </entry>
  
  <entry>
    <title>&#39;复工记&#39;</title>
    <link href="https://wangdabao.js.org/2020/03/03/%E5%A4%8D%E5%B7%A5%E8%AE%B0/"/>
    <id>https://wangdabao.js.org/2020/03/03/复工记/</id>
    <published>2020-03-03T04:00:00.000Z</published>
    <updated>2020-07-05T11:49:17.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复工记"><a href="#复工记" class="headerlink" title="复工记"></a>复工记</h2><blockquote><p>复工的第二天, 本应该昨天写的, 因为一些原因, 拖到今天了。 因为疫情的原因, 导致开工的时间一拖再拖。也希望疫情可以快点过去。 说下我近况, 应该有好几个月没有写过博客了, 中间想过很多次要去写下, 写的时候就会无从下手。</p></blockquote><a id="more"></a><h2 id="个人近况"><a href="#个人近况" class="headerlink" title="个人近况"></a>个人近况</h2><p>之前提到的<code>underscore.js</code>源码解析, 在家的时候, 我也一直在持续产出, 我觉得读源码真的可以学到很多<code>奇技淫巧</code>, 而且设计的函数, 应用面既广泛、考虑事物的角度很多元。当然随之而来的就是读源码是一个长期性的任务规划, 不可能一蹴而就, 而且肯定会遇到不理解的地方。这些问题都是客观存在的, 需要自己去解决的。<br>但是当你明白后, 就会觉得异常的舒服, 这就是所谓的痛并快乐。<br><code>underscore.js</code>看了百分之60左右吧, 有些函数方法, 需要反复去看, 去了解。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>当前我还是会把<code>underscore.js</code>读完, 读完我会专门出一个<code>underscore</code>系列, 更加细致的去写下, 里面一些有意思的函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;复工记&quot;&gt;&lt;a href=&quot;#复工记&quot; class=&quot;headerlink&quot; title=&quot;复工记&quot;&gt;&lt;/a&gt;复工记&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;复工的第二天, 本应该昨天写的, 因为一些原因, 拖到今天了。 因为疫情的原因, 导致开工的时间一拖再拖。也希望疫情可以快点过去。 说下我近况, 应该有好几个月没有写过博客了, 中间想过很多次要去写下, 写的时候就会无从下手。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://wangdabao.js.org/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>&#39; 2019年中总结&#39;</title>
    <link href="https://wangdabao.js.org/2019/11/06/2019%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
    <id>https://wangdabao.js.org/2019/11/06/2019年中总结/</id>
    <published>2019-11-06T02:00:00.000Z</published>
    <updated>2020-07-05T11:49:17.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>单纯的想写点什么。我有很多时候都会去回头看看想想, 总结下某个时间点, 某件事情的处理方式是不是正确的。其实过去的事情, 也没有必要再去想, 但没有办法性格如此, 多愁善感。也有可能过去存有遗憾吧。我有时候觉得我活的好矛盾啊, 有时间特别想自己一个人待着， 可是我特别不喜欢自己一个人呆在密封的空间里。好像莫名的会让我发慌, 不知所措, 急于逃离。<br><a id="more"></a><br>关于近况:</p></blockquote><ul><li>有去解析了<code>underscore</code>的源码, 加了自己的一些理解, 但是有一些函数, 还是不太明白。再去分析吧。</li><li>有去看了<code>http权威指南</code>, 感觉前几章还好理解, 章数越往后, 我越感觉很吃力。 一些名字也只能边查边理解了。</li></ul><p>最近好像就是这样吧。</p><p>关于计划方面, 我可能还是会先把<code>underscore</code>看完把。 不想立flag。</p><p>有时候感觉自己太急于求成了, 越来越浮躁。无法沉下心去学习东西。</p><p>想学的又太多, 贪多嚼不烂。</p><p>也希望自己不要越走越窄, 思想出了问题。</p><p>诚如古诗词所言, 不积硅步无以至千里,不积小流无以成江海。</p><p>与君共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;单纯的想写点什么。我有很多时候都会去回头看看想想, 总结下某个时间点, 某件事情的处理方式是不是正确的。其实过去的事情, 也没有必要再去想, 但没有办法性格如此, 多愁善感。也有可能过去存有遗憾吧。我有时候觉得我活的好矛盾啊, 有时间特别想自己一个人待着， 可是我特别不喜欢自己一个人呆在密封的空间里。好像莫名的会让我发慌, 不知所措, 急于逃离。&lt;br&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://wangdabao.js.org/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>&#39;react-native热更新&#39;</title>
    <link href="https://wangdabao.js.org/2019/08/02/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>https://wangdabao.js.org/2019/08/02/热更新/</id>
    <published>2019-08-01T20:26:00.000Z</published>
    <updated>2020-07-05T11:49:17.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p> 最新做了app的业务, 由于之前没有做过热更新导致每次更新都要去更新app, 特别麻烦. 所以花了点时间, 接入了热更新的功能。<br>我选择的是<code>react-native-code-push</code>的npm包。 </p></blockquote><a id="more"></a> <h2 id="接入与安装"><a href="#接入与安装" class="headerlink" title="接入与安装"></a>接入与安装</h2><p>首先进行安装<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm || yarn </span><br><span class="line">react-native link react-native-code-push</span><br><span class="line">接入时选择跟自己的react-native匹配的react-native-code-push进行接入。</span><br></pre></td></tr></table></figure></p><h2 id="react-native-code-push接入"><a href="#react-native-code-push接入" class="headerlink" title="react-native-code-push接入"></a>react-native-code-push接入</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">全局安装cli</span><br><span class="line">npm || yarn  install -g code-push-cli</span><br><span class="line">注册账号</span><br><span class="line">code-push register</span><br><span class="line">登录</span><br><span class="line">code-push login</span><br></pre></td></tr></table></figure><h2 id="android接入"><a href="#android接入" class="headerlink" title="android接入"></a>android接入</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code-push app add appName(你要用的名字) Android react-native</span><br></pre></td></tr></table></figure><p><code>code-push deployment -k ls &lt;appName&gt;</code><br>查看生成app的key, key分为<code>Production</code>与<code>Staging</code><br>我这边用的是<code>Production</code>, 在<code>adnroid/app/src/main/java/com/你的app名称</code>的<code>MainApplication.java</code> 找到<code>new CodePush(第一个参数替换app-Production key)</code><br>还有就是把android当前版本修改为<code>1.0.0</code>, 修改版本的文件在<code>android/app/build.gradle</code>的versionName.<br>最后使用mkdir bundles创建目录打包所需文件,<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native bundle --platform android --entry-file index.js --bundle-output ./bundles/index.android.bundle --assets-dest ./bundles --dev <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>##ios接入</p><p>ios的操作步骤与android大部分是相似的, 不同的是<br>需要把ios的Production-key放到<code>xcode</code>的<br>以下所有的步骤都是在打开Xcode导入你的ios后进行操作的。<br><code>info.plistd</code>的<code>CodePushDeploymentKey</code>里。<br>还有就是在<code>appDelegate.m</code><br>在顶部加入<br><code>#import &lt;CodePush/CodePush.h&gt;</code><br>在最下面 else, 加入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">return</span> [CodePush bundleURL];</span><br><span class="line"><span class="comment">// return [[NSBundle mainBundle] URLForResource:@"assets/index.ios" withExtension:@"jsbundle"];</span></span><br><span class="line">注释掉这段代码。</span><br></pre></td></tr></table></figure></p><p>配置完以后生成ios的文件包, 上面已经创建过了, 就不在创建<br>在Xcode中记得修改版本。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native bundle --platform ios --entry-file index.ios.js --bundle-output ./bundles/main.jsbundle --assets-dest ./bundles --dev <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h2 id="最后上传"><a href="#最后上传" class="headerlink" title="最后上传"></a>最后上传</h2> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code-push release 你的android||ios的app名称 ./bundles/ <span class="number">1.0</span><span class="number">.0</span> --deploymentName Production  --description <span class="string">"1.修改标题颜色。"</span> --mandatory <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在对android或者ios更新的时候要注意当前你的包的版本,如果android||ios当前版本为1.0.2上传的版本也要是一一对应的。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>我觉得在使用的时候可以先使用官方的demo, 先测试下, 是否正常。<br><a href="&#39;https://github.com/microsoft/react-native-code-push&#39;">demo地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 最新做了app的业务, 由于之前没有做过热更新导致每次更新都要去更新app, 特别麻烦. 所以花了点时间, 接入了热更新的功能。&lt;br&gt;我选择的是&lt;code&gt;react-native-code-push&lt;/code&gt;的npm包。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="热更新" scheme="https://wangdabao.js.org/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>&#39;react-native-app&#39;</title>
    <link href="https://wangdabao.js.org/2019/07/08/react-native/"/>
    <id>https://wangdabao.js.org/2019/07/08/react-native/</id>
    <published>2019-07-07T19:02:00.000Z</published>
    <updated>2020-07-05T11:49:17.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>很长一段时间都没有更新博客了, 我从几个方面考虑下, 第一是, 我觉得我不知道我可以写什么内容了, 可是明明又有很多内容可以写。<br>  第二是, 我在很长时间, 都没有办法再去写博客。(可能是我懒把。)</p></blockquote><a id="more"></a><h2 id="react-native"><a href="#react-native" class="headerlink" title="react-native"></a>react-native</h2><p>  最近一直在做app的业务, 那么在选择采用什么去做app的时候, 可以考虑的有<code>hybrid</code>, <code>react-native</code>, <code>flutter</code>, 我首先没有考虑的是混合开发, 混合开发可能是对我而言开发效率最快的。由于我个人原因我没有选择。 那么flutter我考虑到, 它的年龄还太小, 社区相对于react-native不是那么的繁荣, 而且我看了下它的语法(dart), 感觉跟js没有什么关系。综上我最终选择了react-native, 但是万万没有想到, 有那么多的坑。关于坑的事情, 先按下不表。</p><p>  这里我想说下题外话, 对于前端去做<code>android</code>或者<code>ios</code>的一定一定是不会比专门做android或者iso的做得好。当然可能是废话, 我为什么还是会提到呢? 是因为我在用到第三方的npm包的时候, 发现在使用的时候, 需要用到ios或者android的知识, 来去引用这些npm包, 一步一步去按照<code>readme</code>去引用, 可是对于我而言, 我都不知道这是为什么, 一旦包本身出了错, 在打包的时候我都不知道错在哪里。<br>  一些第三方的npm包可能本身就有问题, 举个例子, 我使用下拉加载npm包的时候, ios上正常, 但是android就有问题, 我就带着问题去github issue 去查找, 发现对于最新版本的react-native是不兼容的, 那么我就只能弃用了。</p><p>  说这个问题的原因是, 对于react-native的npm包的开发者, 需要ios和android的知识来去进行开发。但是能把ios和android玩的好的人, 相对比较少。</p><h3 id="app成果"><a href="#app成果" class="headerlink" title="app成果"></a>app成果</h3><p>  兜兜转转App最后也是完成了, 过程什么的我就不说了, 喜忧参半吧, 喜的是解决问题的开心, 忧的是刚解决了一个, 有来了一个。<br>  最后我说的是, 前端真的是太大了, ‘大前端’的存在, 真的是名不副实。前端做的工作也是越来越多, 那么理所当然的是, 要学的也是越来越多。匍匐前进吧。<br>  就这样。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;很长一段时间都没有更新博客了, 我从几个方面考虑下, 第一是, 我觉得我不知道我可以写什么内容了, 可是明明又有很多内容可以写。&lt;br&gt;  第二是, 我在很长时间, 都没有办法再去写博客。(可能是我懒把。)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="react-native" scheme="https://wangdabao.js.org/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>&#39;underscore系列之函数防抖&quot;&#39;</title>
    <link href="https://wangdabao.js.org/2018/07/30/underscore%E7%B3%BB%E5%88%97%E4%B9%8B%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96/"/>
    <id>https://wangdabao.js.org/2018/07/30/underscore系列之函数防抖/</id>
    <published>2018-07-30T02:37:00.000Z</published>
    <updated>2020-07-05T11:49:17.872Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>   首先还是要明确概念, 什么是函数防抖, </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;函数防抖&quot;&gt;&lt;a href=&quot;#函数防抖&quot; class=&quot;headerlink&quot; title=&quot;函数防抖&quot;&gt;&lt;/a&gt;函数防抖&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="underscore.js" scheme="https://wangdabao.js.org/tags/underscore-js/"/>
    
  </entry>
  
  <entry>
    <title>&#39;underscore系列之throttle&quot;&#39;</title>
    <link href="https://wangdabao.js.org/2018/07/25/underscore%E7%B3%BB%E5%88%97%E4%B9%8B%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/"/>
    <id>https://wangdabao.js.org/2018/07/25/underscore系列之函数节流/</id>
    <published>2018-07-25T11:37:00.000Z</published>
    <updated>2020-07-05T11:49:17.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="underscore函数节流"><a href="#underscore函数节流" class="headerlink" title="underscore函数节流"></a>underscore函数节流</h2><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p> 在说underscore函数节流之前, 还是明确概念, 什么是函数节流。函数节流简单来说就是<code>&#39;开源节流&#39;</code>, 什么意思呢？就是减少某个函数调用的太频繁, 降低频次。一般来讲, 对于dom的频繁操作会引起浏览器的重绘或者重排, 这个时候我们就可以来使用节流不要让他过快的操作dom, 从而页面渲染起来也会更加流畅。<br>  举个场景: dom元素的移动与拖拽, 我默认都做过这个功能。对于dom元素的频繁拖拽, 对于一些性能不太好的浏览器(说的就是你<code>IE</code>)会有很大的损耗, 这个时候我们就可以适当的去降低这个事件的调用频次。 当然调用的频次也要有一个合适的阈值。不然也会引出意外的问题。。。</p></blockquote><h2 id="underscore函数throttle"><a href="#underscore函数throttle" class="headerlink" title="underscore函数throttle"></a>underscore函数throttle</h2><p>  上面提到了函数调用频次, 这个频次也就是调用时间, 所以在underscore中关于throttle函数是基于定时器与时间差来调用函数运行的频次。还有就是throttle函数接收三个参数, 关于最后一个参数我到最后再讲。<br>  我们看下源码:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="built_in">Date</span>.now || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : now();</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">    result = func.apply(context, args);</span><br><span class="line">    <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="keyword">this</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">    <span class="comment">// console.log(previous)</span></span><br><span class="line">    <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">    <span class="comment">// console.log(remaining);</span></span><br><span class="line">    <span class="comment">// console.log(remaining)</span></span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">//  remaining &gt; wait 表示客户端系统时间被调整过</span></span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//  timeout = null设置为null，不仅仅是为了防止内存泄漏，而是clearTimeout(timeout)后，timeout的值并不会清空，如果不设置为null，就不能根据!timeout设置下次的timeout</span></span><br><span class="line">      &#125;</span><br><span class="line">      previous = now;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      <span class="comment">// console.log(result)</span></span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;  <span class="comment">//  这里不太明白, timeout 不是已经赋值为null了吗</span></span><br><span class="line">      <span class="comment">//  context = args = null; 引用值为空, 防止内存泄露。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// console.log(remaining);</span></span><br><span class="line">      timeout = setTimeout(later, remaining);</span><br><span class="line">      <span class="comment">// console.log(later, remaining)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    previous = <span class="number">0</span>;</span><br><span class="line">    timeout = context = args = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'wangdaye'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle(func, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><p>  我从自己的角度分析下: 首先滚动进入<code>throttle</code>函数携带两个参数, 函数内定义变量先不管, 直接说<code>throttled</code>函数, 首先要获取当前时间, 然后就是计算时间差, 当然第一次调用我们肯定是不希望要延迟加载, 所以变量remaining一定是负值, 获取最新时间戳, 然后调用函数。当连续调用时, 变量remaining是一个正值, 然后定时器延迟调用<code>later</code>方法, 刷新时间戳, timeout为null。当等待一秒钟再次调用时remaining为负值, 且已经存在timeout, 所以清空上一次定时器, timeout并为null。</p><p>  我再说说关于第三个参数, 第三个参数有两种调用方式, 第一种是, <strong>{leading: false}</strong>, 当传递的方式的为{leading: false}就会忽略scroll开始前的回调。第二种方式是, <strong>{trailing: false}</strong>, 当传递方式为{trailing: false}时, scroll结束时会被忽略。</p><p>  最后我还是希望可以<strong>debugger</strong>或者<strong>console.log</strong>下, 自己多去理解下, 我相信就会更加明白关于函数节流的知识点。<br>  就到这了。。。。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/hanzichi/underscore-analysis/issues/22" target="_blank" rel="noopener">underscore 函数节流的实现-hanzichi</a></li><li><a href="http://www.alloyteam.com/2012/11/javascript-throttle/" target="_blank" rel="noopener">浅谈javascript的函数节流</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;underscore函数节流&quot;&gt;&lt;a href=&quot;#underscore函数节流&quot; class=&quot;headerlink&quot; title=&quot;underscore函数节流&quot;&gt;&lt;/a&gt;underscore函数节流&lt;/h2&gt;
    
    </summary>
    
    
      <category term="underscore.js" scheme="https://wangdabao.js.org/tags/underscore-js/"/>
    
  </entry>
  
  <entry>
    <title>&#39;underscore系列之无耦合函数&quot;&#39;</title>
    <link href="https://wangdabao.js.org/2018/07/20/underscore%E7%B3%BB%E5%88%97%E4%B9%8B%E6%97%A0%E8%80%A6%E5%90%88%E5%87%BD%E6%95%B0/"/>
    <id>https://wangdabao.js.org/2018/07/20/underscore系列之无耦合函数/</id>
    <published>2018-07-20T08:37:00.000Z</published>
    <updated>2020-07-05T11:49:17.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无耦合函数"><a href="#无耦合函数" class="headerlink" title="无耦合函数"></a>无耦合函数</h2><blockquote><p>无耦合函数: 叫无耦合函数可能不太准确, 之所以叫无耦合函数, 我想的是把underscore函数方法没有在其他函数中调用的方法, 所以就先暂时叫无耦合函数. 如果这样理解我在订正.</p></blockquote><a id="more"></a><h2 id="判断传入的参数是否为数组"><a href="#判断传入的参数是否为数组" class="headerlink" title="判断传入的参数是否为数组"></a>判断传入的参数是否为数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  当如果支持es5时, 采用Array.isArray。反之采用第二次。</span></span><br><span class="line"><span class="keyword">var</span> isArray = <span class="built_in">Array</span>.isArray || <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断为DOM元素"><a href="#判断为DOM元素" class="headerlink" title="判断为DOM元素"></a>判断为DOM元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isElement = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//  当obj为undefined或者null或者为空是, 转换为false返回。</span></span><br><span class="line">  <span class="comment">//  nodeType === 1时代表为一个元素节点如`&lt;p&gt;&lt;/p&gt;`和`&lt;div&gt;&lt;/div&gt;`</span></span><br><span class="line">  <span class="keyword">return</span> !!(obj &amp;&amp; obj.nodeType === <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;无耦合函数&quot;&gt;&lt;a href=&quot;#无耦合函数&quot; class=&quot;headerlink&quot; title=&quot;无耦合函数&quot;&gt;&lt;/a&gt;无耦合函数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;无耦合函数: 叫无耦合函数可能不太准确, 之所以叫无耦合函数, 我想的是把underscore函数方法没有在其他函数中调用的方法, 所以就先暂时叫无耦合函数. 如果这样理解我在订正.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="underscore.js" scheme="https://wangdabao.js.org/tags/underscore-js/"/>
    
  </entry>
  
  <entry>
    <title>&#39;Yellow + 流星&#39;</title>
    <link href="https://wangdabao.js.org/2018/07/19/yellow+%E6%B5%81%E6%98%9F/"/>
    <id>https://wangdabao.js.org/2018/07/19/yellow+流星/</id>
    <published>2018-07-19T04:37:00.000Z</published>
    <updated>2020-07-05T11:49:17.873Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=3&id=2060904923&auto=1&height=66"></iframe><a id="more"></a><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">作曲 : <span class="type">Coldplay</span></span><br><span class="line"></span><br><span class="line">作词 : <span class="type">Coldplay</span>/郑钧</span><br><span class="line"></span><br><span class="line">Look <span class="keyword">at</span> the stars</span><br><span class="line"></span><br><span class="line">Look how they shine <span class="keyword">for</span> you</span><br><span class="line"></span><br><span class="line"><span class="keyword">And</span> everything you <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">Yeah they were <span class="keyword">all</span> yellow</span><br><span class="line"></span><br><span class="line">I came along</span><br><span class="line"></span><br><span class="line">I wrote a song <span class="keyword">for</span> you</span><br><span class="line"></span><br><span class="line"><span class="keyword">And</span> <span class="keyword">all</span> the things you <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">And</span> it was called Yellow</span><br><span class="line"></span><br><span class="line">Your skin</span><br><span class="line"></span><br><span class="line">Oh yeah your skin <span class="keyword">and</span> bones</span><br><span class="line"></span><br><span class="line">Turn into something beautiful</span><br><span class="line"></span><br><span class="line"><span class="keyword">Do</span> you know you know I love you so</span><br><span class="line"></span><br><span class="line">You know I love you so</span><br><span class="line"></span><br><span class="line">我纵身跳</span><br><span class="line"></span><br><span class="line">跳进你的河流</span><br><span class="line"></span><br><span class="line">一直游到尽头</span><br><span class="line"></span><br><span class="line">那里多自由</span><br><span class="line"></span><br><span class="line">我许个愿</span><br><span class="line"></span><br><span class="line">我许个愿保佑</span><br><span class="line"></span><br><span class="line">让我的心凝固</span><br><span class="line"></span><br><span class="line">在最美的时候</span><br><span class="line"></span><br><span class="line">情愿坠落在你手中</span><br><span class="line"></span><br><span class="line">羽化成黑夜的彩虹</span><br><span class="line"></span><br><span class="line">情愿不见明媚的天</span><br><span class="line"></span><br><span class="line">不见明媚的天</span><br><span class="line"></span><br><span class="line">Look how they shine <span class="keyword">for</span> you</span><br><span class="line"></span><br><span class="line">Look how they shine <span class="keyword">for</span> you</span><br><span class="line"></span><br><span class="line">Look how they shine <span class="keyword">for</span></span><br><span class="line"></span><br><span class="line">Your skin</span><br><span class="line"></span><br><span class="line">Oh yeah your skin <span class="keyword">and</span> bones</span><br><span class="line"></span><br><span class="line">Turn into something beautiful</span><br><span class="line"></span><br><span class="line"><span class="keyword">Do</span> you know you know I love you so</span><br><span class="line"></span><br><span class="line">You know I love you so</span><br><span class="line"></span><br><span class="line">Look how they shine <span class="keyword">for</span> you</span><br><span class="line"></span><br><span class="line">Look how they shine <span class="keyword">for</span></span><br><span class="line"></span><br><span class="line">Look <span class="keyword">at</span> the stars</span><br><span class="line"></span><br><span class="line">Look how they shine <span class="keyword">for</span> you</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=3&amp;id=2060904923&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;
    
    </summary>
    
    
      <category term="yellow" scheme="https://wangdabao.js.org/tags/yellow/"/>
    
  </entry>
  
  <entry>
    <title>&#39;underscore系列之比较两个元素是否&quot;相同&quot;&#39;</title>
    <link href="https://wangdabao.js.org/2018/07/15/underscore%E7%B3%BB%E5%88%97%E4%B9%8B%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C/"/>
    <id>https://wangdabao.js.org/2018/07/15/underscore系列之比较两个元素是否相同/</id>
    <published>2018-07-15T07:37:00.000Z</published>
    <updated>2020-07-05T11:49:17.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比较两个元素是否相同"><a href="#比较两个元素是否相同" class="headerlink" title="比较两个元素是否相同"></a>比较两个元素是否相同</h2><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>之前就说过要读一下关于<code>underscore.js</code>的源码, 我就想先从某个函数开始读,  正好在github文章中(这里的文章我会在最后放上地址)提到了<code>underscore</code>中关于如何比较两个元素的是否相同, 我看完之后觉得很好玩。那么对于如何判断两个元素是否是相同呢？那么在什么程度上才算是相同, 举个例子: <code>1与1是相等的(当然他们前提是类型是一样的)</code>那么<code>1</code>和 <code>new Number(1)</code>也应该相等。<br>  underscore中有这么一个函数<code>_.isEqual</code>对没错, 就是这个。接下来我会以自己的知识来解释下, 这个函数的涉及的知识点。 如果有解释的不好的点, 请大家给我留言我一定改正。话不多说直接开始。</p></blockquote><h2 id="分析-isEqual"><a href="#分析-isEqual" class="headerlink" title="分析_.isEqual"></a>分析_.isEqual</h2><h3 id="Number类型判断"><a href="#Number类型判断" class="headerlink" title="Number类型判断"></a>Number类型判断</h3><p>  <code>console.log( _.isEqual(a, b));</code> </p><p>  我首先在 <code>_.isEqual</code>中传入了两个参数a, b。首先明确两个概念: 其一是a, b都是基本类型, 那么两个基本类型的值相同。其二是两个是引用类型, 那么引用类型相同。如果a === b为true, 我们是否可以说a和b是相等的。但是这里有个特殊的就是0, -0。0与-0被浏览器认为是相等的。正确来讲0与-0是不相等的(关于这里我是看了文章里面有提到, 我在控制台打印了下, 发现很神奇)。关于这里<code>_.isEqual</code>这样处理的。<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</span><br></pre></td></tr></table></figure></p><p>  我理解是这样的: 这里过滤了99%情况, 但是没有过滤掉0与-0的情况。但是return里面如果a是0, 直接就return false结束。还有就是a如果为-0呢？第一个条件满足, 我们看第二个 <code>1 / a(-0) === -Infinity</code>而<code>1 / b(0) === Infinity</code>;所以第二个条件也不满足, 那么直接返回return false. ——游戏结束。上面这种判断处理就是针对0与-0这种情况。<br>  接下来就是 a !== b<br>  如果a或者b其中有一个为<code>null</code>或者是<code>undefined</code>特殊处理。<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a === <span class="literal">null</span> || b === <span class="literal">null</span>) <span class="keyword">return</span> a === b;</span><br></pre></td></tr></table></figure></p><p>  文章中说这里的这里的判断条件有点多余, 因为根据上面的判断条件 a === b肯定返回false。关于这里我想了想也对, 如果a === b 直接在上面的判断条件哪里直接就返回了。 所以把return a === b 替换成 retun false, 会更加清晰吧。<br>  接下来用到了<code>Object.prototype.toString.call</code>, 如果判断的参数的类型不一样, 那么直接就返回return false。<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> className = toString.call(a)</span><br><span class="line"><span class="keyword">if</span> (className !== toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p><p>  如果a或者b都是Number类型, 但是这里又有一个特例就是<code>not a number</code>也就是<code>NaN</code>。这里我举个栗子:<br>  <code>var number = new Number(&#39;s&#39;)</code><br>  <code>var number2 = new Number(&#39;s&#39;);</code><br>  <code>console.log(_.isEqual(number, number2));</code><br>  这里的<code>number</code>与<code>number2</code>的值都是<code>Number{NaN}</code>,而且又都是<code>[object Number]</code>。 理应来讲<code>number</code>与<code>number2</code>应该是相等的, 因为都是NaN嘛。所以这里专门针对<code>NaN</code>的情况做了判断, 看case里的第一个判断条件: 如果+a不等于+a那么a就是NaN, 因为<code>NaN === NaN为false</code>。同理b也一样如果b为NaN那么返回为true。证明a, b相等(都为NaN)。如果+b === +b 返回false, 说明a, b不相等。<br>  下面的return这里又有一个特殊处理, 是关于0的。举个例子:<br>  <code>var s = new Number(-0);</code><br>  <code>var a = new Number(0);</code><br>  <code>console.log(_.isEqual(s, a));</code><br>  首先上面已经说过了0 === -0为true, 所以第一个条件为false。正确。同理把-0换成1, 走第二个条件也是一样, 返回false, 很明显不相等。<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'[object Number]'</span>:</span><br><span class="line">    <span class="comment">// console.log('1')</span></span><br><span class="line">      <span class="comment">// `NaN`s are equivalent, but non-reflexive.</span></span><br><span class="line">      <span class="comment">// Object(NaN) is equivalent to NaN</span></span><br><span class="line">      <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</span><br><span class="line">      <span class="comment">// console.log(+b !== +b);</span></span><br><span class="line">      <span class="comment">// An `egal` comparison is performed for other numeric values.</span></span><br><span class="line">      <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / b : +a === +b;</span><br></pre></td></tr></table></figure></p><p>关于对于Number类型的判断就到这里结束了。</p><h3 id="正则RegExp和String类型判断"><a href="#正则RegExp和String类型判断" class="headerlink" title="正则RegExp和String类型判断"></a>正则RegExp和String类型判断</h3><p>举个例子:<br><code>var a = /a/;</code><br><code>var b = new RegExp(&#39;a&#39;)</code><br><code>consolo.log(_.isEqual(s, a));</code><br>我们看下是如何处理这种情况的, 首先还是老样子判断属于什么类型, 发现是<code>RegExp</code>进入return 转换为字符串进行比较-也就是a与a进行比较为true。<br><code>String</code>也一样,<br><code>var a = new String(&#39;s&#39;);</code><br><code>var b = new String(&#39;s&#39;);</code><br>同上。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:</span><br><span class="line">  <span class="comment">// RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'[object String]'</span>:</span><br><span class="line">  <span class="comment">// Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is</span></span><br><span class="line">  <span class="comment">// equivalent to `new String("5")`.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> + b;</span><br></pre></td></tr></table></figure></p><h3 id="Date与Boolean类型判断"><a href="#Date与Boolean类型判断" class="headerlink" title="Date与Boolean类型判断"></a>Date与Boolean类型判断</h3><p>举个栗子:<br>还是根据数据类型选择进入:<br><code>var a = new Date(1);</code><br><code>var b = 1</code><br>这样进行判断就会发现通过使用<code>+new Date()</code>或者<code>+new Date</code>转换成1。这样就会发现返回true;<br>当然我觉得布尔类型也是如此,<br><code>var a = true;</code><br><code>var b = new Boolean(false);</code><br>a为true, 我们也知道true == 1, true为布尔类型进入进行隐士类型转换, b也是如此, 如果相等返回true, 否则反之。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'[object Date]'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:</span><br><span class="line">  <span class="comment">// Coerce dates and booleans to numeric primitive values. Dates are compared by their</span></span><br><span class="line">  <span class="comment">// millisecond representations. Note that invalid dates with millisecond representations</span></span><br><span class="line">  <span class="comment">// of `NaN` are not equivalent.</span></span><br><span class="line">  <span class="keyword">return</span> +a === +b;</span><br></pre></td></tr></table></figure></p><h3 id="数组与对象类型比较"><a href="#数组与对象类型比较" class="headerlink" title="数组与对象类型比较"></a>数组与对象类型比较</h3><p>关于数组的类型比较稍微比较麻烦, 因为涉及到数组有包括对象的情况。同理, 也有可能对象里面有数组的情况。还是老样子判断是否是<code>[&#39;object Array&#39;]</code>;</p><hr><p>未完待续</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/hanzichi/underscore-analysis" target="_blank" rel="noopener">underscore-1.8.3.js 源码解读</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;比较两个元素是否相同&quot;&gt;&lt;a href=&quot;#比较两个元素是否相同&quot; class=&quot;headerlink&quot; title=&quot;比较两个元素是否相同&quot;&gt;&lt;/a&gt;比较两个元素是否相同&lt;/h2&gt;
    
    </summary>
    
    
      <category term="underscore.js" scheme="https://wangdabao.js.org/tags/underscore-js/"/>
    
  </entry>
  
  <entry>
    <title>&#39;2018年中总结&#39;</title>
    <link href="https://wangdabao.js.org/2018/07/09/%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
    <id>https://wangdabao.js.org/2018/07/09/年中总结/</id>
    <published>2018-07-09T05:37:00.000Z</published>
    <updated>2020-07-05T11:49:17.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="年中总结"><a href="#年中总结" class="headerlink" title="年中总结"></a>年中总结</h2><a id="more"></a><blockquote><p> 距离上一个总结已经半年过去了, 上次的总结对于自己的要求和目标我还历历在目。说说我还在坚持的以及没有坚持到的, 看书这件事我今年开始了坚持, 因为我买了<code>kindle</code>, 目前<code>javascript</code>高程我看了80%, 但是有些知识点我还是很模糊, 我觉得在看的同时, 对于一些不太明白, 不太清晰的代码。一定要去敲下好吗, 我求你了。 因为我在看的时候有些没有敲, 相对与敲过代码的而言, 记忆薄弱了很多。<br>看了曾探写的<code>javascript设计模式与开发实践</code>, 这本书我没有看完, 但我受益匪浅, 忽然觉得js这门语言很好玩。等我觉得有些概念了, 我会去写关于这本书的一些设计模式的自己看法与见解。对于自己而言有时候还是会很焦躁, 感觉会的还是太少了。<br>对于博客我真的越来越懒, 更新频率越来越低下。说的是一个星期更新一篇, 拖到了一个月更新一次甚至更久。 健身方面的话, 中间另个一个健身房到期了, 又找了个便宜的。离得稍微近一点的。坚持锻炼吧。。。<br>说好的, 看一看<code>vue</code>源码的我也没看。我甚至在想我能不能先看<code>underscore</code>或者<code>jquery</code>的源码。我有时候在想是不是可以让自己适当的停一下,慢一点, 给我一点缓冲的时间给自己充充电。<br>我时常会感觉到自己的无力, 尤其对于在技术上, 本身前端技术的更新换代很快, 可能有时候稍微走了下神, 就会发现自己已经跟不上了。<br>对于做技术而言, 一定要保持初心, 对于技术一定要有求知欲, 这方面我就做的很不好。希望自己保持初心吧。</p></blockquote><h2 id="下半年计划"><a href="#下半年计划" class="headerlink" title="下半年计划"></a>下半年计划</h2><p>  下半年希望自己初心依旧。</p><ul><li>读一遍<code>underscore.js</code>源码。</li><li><code>vue</code>源码看看。</li><li><code>多学</code>, <code>多看</code>, <code>多听</code>。</li><li>想多看看关于<code>css</code>的一些书籍。 </li><li>可以的话, 学学<code>英语</code>。</li></ul><p>心太小, 不想装太多, 太累了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;年中总结&quot;&gt;&lt;a href=&quot;#年中总结&quot; class=&quot;headerlink&quot; title=&quot;年中总结&quot;&gt;&lt;/a&gt;年中总结&lt;/h2&gt;
    
    </summary>
    
    
      <category term="年中总结" scheme="https://wangdabao.js.org/tags/%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>&#39;我所知道的apply与call&#39;</title>
    <link href="https://wangdabao.js.org/2018/06/13/%E6%88%91%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84apoly%E4%B8%8Ecall/"/>
    <id>https://wangdabao.js.org/2018/06/13/我所知道的apoly与call/</id>
    <published>2018-06-13T06:24:00.000Z</published>
    <updated>2020-07-05T11:49:17.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我所知道的apply与call"><a href="#我所知道的apply与call" class="headerlink" title="我所知道的apply与call"></a>我所知道的apply与call</h2><a id="more"></a><blockquote><p>在我打算写这篇文章之前我徘徊了两分钟(没错就是两分钟), 徘徊的原因是我觉得以我当前的对于<code>js儿子-call与apply</code>的掌握, 还不足以我能够很好的去解释给自己或者读者去听, 尤其是在看了一些书里面讲到了很多关于apply与call的妙用. 很神奇没有想到还能这么用. 但写了这篇文章的一个原因是我蛮久没有写了博客, 也该写了(尽力微笑…). 另一个原因是我想通过我的角度去说下我对于apply和call的看法. 其实在刚刚认识call或者apply的时候, 我在想这两个货是到底干嘛的, 在没有认识他们之前, 我也完成了某些功能的开发呀, 这两个货色的作用到底是什么, 我觉得我有必要去好好了解下. </p></blockquote><h2 id="开始认识call与apply"><a href="#开始认识call与apply" class="headerlink" title="开始认识call与apply"></a>开始认识call与apply</h2><p>  我打开了熟悉的<code>mdn</code>恩, 他好像挂了. 算了我用手机打开吧. 其中描述中这样的说道: 可以让call或者apply中的对象调用当前<br>  对象所有的function. 你可以使用call()来实现继承: 写一个方法, 然后让另一个新的对象来继承它(而不是在新对象中再写一次这个方法).<br>  难道是这样:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">'wangdaye'</span>,</span><br><span class="line">  showName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  name: <span class="string">'liayi'</span></span><br><span class="line">&#125;</span><br><span class="line">foo.showName.call(bar);</span><br></pre></td></tr></table></figure></p><p>  我觉得这个栗子(栗子是我抄的_-_), 想表达的其实和上面描述里面提到的, 其实是一回事, 我觉得是这样, <code>bar</code>这个人想看下自己家的房产证名字写的是谁的, 但是没有梯子, 因为房产证放在需要梯子才能够到的地方, 所以他问了邻居foo, 嘿我用下你家梯子(showNmae方法), 行用吧, 然后就看到了自己的房产证是”老婆的名字”. 大概的的意思是, bar这个家伙没有自己方法, 但是他又想用, 怎么办那就借用了foo的方法. 就是这样. </p><h2 id="apply与apply的异同"><a href="#apply与apply的异同" class="headerlink" title="apply与apply的异同"></a>apply与apply的异同</h2><p>  同: <code>apply</code>与<code>call</code> 方法的第一个参数是在运行指定的<code>this</code>值. 需要注意的是, 指定的<code>this</code>值并不一定是该函数执行时真正的<code>this</code>值, 如果这个函数的处于非严格模式下, 则指定为<code>null</code>与<code>undefined</code>的<code>this</code>值会自动指向全局对象(浏览器中就是<code>window</code>对象), 同时值为原始值(数字, 字符串, 布尔值)的<code>this</code>会指向该原始值的自动包装对象.<br>  关于这句话, 我再举个栗子:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,array)</span><br></pre></td></tr></table></figure></p><p>  我在稍微说下: 这个栗子就很好的解释了上面提到的如果<code>apply</code>或者<code>call</code>的第一个参数, 我传递了<code>null</code>或者<code>undefined</code>那么这个时候<code>this</code>的指的就是上面提到的<code>window</code>, 而<code>window</code>里面有<code>Math.max</code>.<br>  再举个栗子:<br>  异: <code>call</code>参数是这样的形式(this, num1, num2, ….)<br>      <code>apply</code>参数是这样的形式(this, []) </p><h2 id="未完待续。。。。。。"><a href="#未完待续。。。。。。" class="headerlink" title="未完待续。。。。。。"></a>未完待续。。。。。。</h2><p>—————————————–更新———————————————————–</p><h2 id="this与bind"><a href="#this与bind" class="headerlink" title="this与bind"></a>this与bind</h2><p>  我觉得既然聊到了<code>apply</code>与<code>call</code>就多聊一些, 加上<code>this</code>与<code>bind</code>。要说明this到底指向谁, 我在掘金上看到一篇关于this指向的文章, 提到了<code>this永远指向最后调用它的那个对象</code>。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'wangda'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"wanger"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name);  <span class="comment">//  wangda</span></span><br><span class="line">&#125;</span><br><span class="line">aa();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;我所知道的apply与call&quot;&gt;&lt;a href=&quot;#我所知道的apply与call&quot; class=&quot;headerlink&quot; title=&quot;我所知道的apply与call&quot;&gt;&lt;/a&gt;我所知道的apply与call&lt;/h2&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://wangdabao.js.org/tags/js/"/>
    
      <category term="方法" scheme="https://wangdabao.js.org/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>&#39;Chrome扩展程序&#39;</title>
    <link href="https://wangdabao.js.org/2018/04/28/Chrome%E6%8F%92%E4%BB%B6/"/>
    <id>https://wangdabao.js.org/2018/04/28/Chrome插件/</id>
    <published>2018-04-28T06:54:48.000Z</published>
    <updated>2020-07-05T11:49:17.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chrome扩展程序"><a href="#Chrome扩展程序" class="headerlink" title="Chrome扩展程序"></a>Chrome扩展程序</h2><a id="more"></a><blockquote><p>一直想着做一期关于chrome扩展程序的文章,索性就做了一期。其中的一些扩展程序我会根据自己用过的喜爱程序与相关推荐来做排名, 因为<br>  其中有我没有用过的扩展程序。当然所有的相关程序都是需要进行翻墙来进行下载的。如果有需要可以联系我, 我会下载下来提供给你。</p></blockquote><h2 id="自用扩展程序"><a href="#自用扩展程序" class="headerlink" title="自用扩展程序"></a>自用扩展程序</h2><ul><li>Adblock Plus</li><li>JSON Viewer</li><li>Momentum</li><li>Noisli</li><li>One Tab</li><li>Postman</li><li>Stylish</li><li>Tampermonkey</li><li>uBlock Origin (关闭)</li><li>UI Stack</li><li>Vue.js devtools</li><li>WEB前端助手(FeHelper)</li><li>一键管理所有扩展</li><li><p>简悦 - SimpRead</p><p>目前就是这么多。</p><h2 id="扩展程序排行榜"><a href="#扩展程序排行榜" class="headerlink" title="扩展程序排行榜"></a>扩展程序排行榜</h2></li><li><a href="https://chrome.google.com/webstore/search/Adblock%20Plus?hl=zh-CN" target="_blank" rel="noopener">Adblock Plus</a><br><code>Adblock</code>是广告拦截软件。  目前chrome下载量: <code>161440</code>  推荐指数: <code>5颗星</code></li><li><a href="https://chrome.google.com/webstore/search/Tampermonkey?hl=zh-CN" target="_blank" rel="noopener">Tampermonkey</a><br><code>油猴脚本</code>是非常强大的扩展程序, 具体的用处建议自己去发掘下。说下令人感兴趣的如<code>破解VIP会员视频集合</code>。当然不是万能的有时候解析不出来视频, 而且不是清晰版, 其他还是可以的。<br>目前chrome下载量: <code>55276</code> 推荐指数 <code>4颗星</code></li><li><a href="https://chrome.google.com/webstore/search/Stylish?hl=zh-CN" target="_blank" rel="noopener">Stylish</a><br>强烈安利<code>Stylish</code>他的作用是更改网页主题如百度-google:<br><img src="https://qn.tyty.me/baidu.png" alt="百度"><br><img src="https://qn.tyty.me/google.png" alt="谷歌"><br>目前chrome下载量: <code>15896</code> 推荐指数: <code>4颗星</code></li><li><a href="https://chrome.google.com/webstore/search/Momentum?hl=zh-CN" target="_blank" rel="noopener">Momentum</a> <code>Momentum</code>是新的标签页面,但不单单是标签页,里面还有很多隐藏的彩蛋。自己去发现吧。图片特别特别好看。<br><img src="https://qn.tyty.me/im.png" alt="好看"><br>怎么样,还可以吧。这个插件我的使用率不是很高。所以分数不是很高。<br>目前chrome下载量: <code>12601</code> 推荐指数: <code>3颗星</code></li><li><a href="https://chrome.google.com/webstore/search/Noisli?hl=zh-CN" target="_blank" rel="noopener">Noisli</a><br><code>Noisli</code>是一款很小清新的插件。不知道大家喜不喜欢下雨打雷看书的声音。那感觉(肾宝味道好极了)棒极了。可以自己配置一款自己喜欢的, 里面的声音大概10多种。随心所欲的去配置吧。<br>此时的我就走在下着雨的森林,行走。除此以外, 好像没有别的用处。<br><img src="https://qn.tyty.me/qing.png" alt="小清新"><br>目前chrome下载量: <code>687</code> 推荐指数: <code>3颗星</code></li><li><a href="https://chrome.google.com/webstore/search/One%20Tab?hl=zh-CN" target="_blank" rel="noopener">One Tab</a> <code>One Tab</code>是一款与众不同的插件, 不知道你有没有烦恼过打开了’无数’的网站<br>但就是不想关闭, 因为你只要关闭, 接下来再想看的话, 就要到历史记录里面去翻找(说多了都是泪啊)此处为本人脑补: 可能有的同学会说,我们不用翻找可以在历史记录进行搜索。非常好，<br>同学你叫什么名字, 我叫<code>陈独秀</code>。陈同学你坐下。。。额 对, 用了这个插件我们可以十分顺畅,可以把所有的页面都集中在一个标签页上。<br><img src="https://qn.tyty.me/tab.png" alt="tab"><br>目前chrome下载量: <code>10312</code> 推荐指数: <code>4颗星</code></li><li><a href="https://chrome.google.com/webstore/search/JSON%20Viewer?hl=zh-CN" target="_blank" rel="noopener">JSON Viewer</a><br><code>JSON Viewer</code> 接口格式化工具,我觉得做<code>web前端</code>工作的应该人手一个, 看到没有安装这个插件的同学, 马上安利。瞬间大神,额。。。。我呸。<br><img src="https://qn.tyty.me/apibefore.png" alt="before"><br><img src="https://qn.tyty.me/apiafter.png" alt="after"><br>目前chrome下载量: <code>637</code> 推荐指数: <code>4颗星</code></li><li><a href="https://chrome.google.com/webstore/search/Postman?hl=zh-CN" target="_blank" rel="noopener">Postman</a><br><code>Postman</code>是接口调试工具。恩对。反正挺好用的。<br>目前chrome下载量: <code>652</code> 推荐指数<code>3颗星</code></li><li><a href="https://chrome.google.com/webstore/search/WEB%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8B(FeHelper" target="_blank" rel="noopener">WEB前端助手(FeHelper)</a>?hl=zh-CN<br>)<code>FeHelper</code>也是很不错的一款插件,它的功能比<code>JSON Viewer</code>会更多一些。随便说下,算了不说了。但是我把它关了。<code>好像是因为它长的不好看?</code><br>目前chrome下载量: <code>157</code> 推荐指数: <code>3颗星</code>  </li><li><a href="https://chrome.google.com/webstore/search/%E4%B8%80%E9%94%AE%E7%AE%A1%E7%90%86%E6%89%80%E6%9C%89%E6%89%A9%E5%B1%95?hl=zh-CN" target="_blank" rel="noopener">一键管理所有扩展</a><br><code>一键管理</code>插件真的对我来说作用不大。前提是如果你装了很多扩展插件,都是大部分都是摆着装13(麻烦帮我消下音), 这个时候可能在使用浏览器的过程中,可能会出现卡顿的现象。<br>目前chrome下载量: <code>183</code> 推荐指数 <code>2颗星</code>  </li></ul><p>  这一期就这样吧。如果你们需要某一类的扩展程序, 比如<code>打折</code>或者<code>划词翻译</code>等等系列的。可以留言给我。我会搜集更多好玩, 实用的插件给你们。<br>  我也会继续更新上面的插件,目前就想到这么多。</p><h2 id="相应网站"><a href="#相应网站" class="headerlink" title="相应网站"></a>相应网站</h2><ul><li><a href="https://www.zhihu.com/topic/19614065/top-answers" target="_blank" rel="noopener">更多知乎相应插件</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Chrome扩展程序&quot;&gt;&lt;a href=&quot;#Chrome扩展程序&quot; class=&quot;headerlink&quot; title=&quot;Chrome扩展程序&quot;&gt;&lt;/a&gt;Chrome扩展程序&lt;/h2&gt;
    
    </summary>
    
    
      <category term="插件" scheme="https://wangdabao.js.org/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>&#39;Javascript异步与同步&#39;</title>
    <link href="https://wangdabao.js.org/2018/04/23/Javascript%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
    <id>https://wangdabao.js.org/2018/04/23/Javascript异步与同步/</id>
    <published>2018-04-23T06:24:00.000Z</published>
    <updated>2020-07-05T11:49:17.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Javascipt异步与同步"><a href="#Javascipt异步与同步" class="headerlink" title="Javascipt异步与同步"></a>Javascipt异步与同步</h2>  <a id="more"></a><blockquote><p>我们都知道Javascript语言执行环境是<code>单线程</code>的,所谓<code>单线程</code>在程序执行时,按照前面先执行,后面再去执行的顺序,也就是所谓的先进先出。但是这样一来,如果某个任务的执行时间很久,那么后面的所有任务都要去等着前面任务执行完毕。可能会出现浏览器卡死。作为浏览器语言,Javascript的主要用途是与用户互动,以及操作DOM。</p></blockquote><p>  在开始之前我还是要明确下何为异步,何为同步。<br>  举个栗子：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'同步1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'同步2'</span>)</span><br></pre></td></tr></table></figure></p><p>  按照的JavaScript语言执行顺序,最终的打印顺序为<code>同步1</code>然后<code>同步2</code>。<br>  栗子2：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'完成'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'结束'</span>)</span><br></pre></td></tr></table></figure></p><p>  我们都知道setTimeout是起到延迟器的作用,那么这里他的执行打印顺序为结束-完成。<br>  这里可能有些迷惑,setTimeout不是0吗?为什么会是这样的打印结果。这里涉及到了一个关键词<br>  <code>Event Loop</code>关于这个关键词目前我太不适于去讲。以后单开一篇文章,单独去讲。<br>  这里我简单说下原理,我理解是这样的,javascript是单线程也是主线程,当出现异步操作时,它会等待主线程完成。然后进入。那么这时要等待执行console.log(‘结束’),然后再去执行setTimeout。  </p><p>  我在使用jquery ajax异步请求时面临到了这样一个问题：<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ccc = $(<span class="string">"#content"</span>)</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">'https://cnodejs.org/api/v1/topics'</span>,</span><br><span class="line">  type: <span class="string">'GET'</span>,</span><br><span class="line">  dataType: <span class="string">'json'</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    ccc.html(res.data[<span class="number">0</span>].content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> con = $(<span class="string">"#con"</span>)</span><br><span class="line">con.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  这种情况下我想给返回的数据里的某个id为con的添加点击事件,这种情况下肯定是会报错了,原因是<code>jquery-ajax</code>默认是异步的,哪这种情况下当执行到获取dom元素时,是获取不到的,因为ajax的没有执行。<br>  我想到的解决办法是:</p><ul><li><p>改为同步(把<code>async</code>: <code>false</code>)这样的话,就会按照顺序执行,从而获取到id为con的dom元素。可是这样又会面临一个问题: <code>阻塞</code>,如果返回的数据量很大的情况下,就会一直等待数据的返回,导致页面的卡顿。 哪有没有即是异步又可以获取dom的元素的呢。下面说第二种方法:</p></li><li><p>jquery中有如下事件可以实现:</p><ul><li>on</li><li>delegate</li><li>bind</li><li>live(最新jquery已删除)<h5 id="其中只测试了bind与on事件-如有其他需要请自行测试"><a href="#其中只测试了bind与on事件-如有其他需要请自行测试" class="headerlink" title="其中只测试了bind与on事件(如有其他需要请自行测试)"></a>其中只测试了bind与on事件(如有其他需要请自行测试)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#content'</span>).on(<span class="string">'click'</span>,<span class="string">'#con'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'成功获取#con'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果我不想使用jquey的on或者其他事件,我可以实现吗？答案是当然可以。我查了下jquery的on的实现,提到了两个关键词<code>事件代理</code>或<code>事件委托</code>。当然上面的事件用的是事件委托。关于事件委托我简单说下:<br>事件委托就是利用了事件冒泡的原理。举个栗子:  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>444<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">  oUl.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">var</span> target = ev.target || ev.srcElement;</span><br><span class="line">    <span class="keyword">if</span> (target.nodeName.toLowerCase() == <span class="string">'li'</span>) &#123;</span><br><span class="line">      alert(target.innerHTML);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的就是这样,我会再开一篇关于事件的文章。更系统的说下关于js的事件。<br>其实关于异步我觉得更多的关注点还是要放在Event Loop上。如果你能够明白Event Loop<br>那么异步也就不在话下。<br>这篇文章就到这了。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Javascipt异步与同步&quot;&gt;&lt;a href=&quot;#Javascipt异步与同步&quot; class=&quot;headerlink&quot; title=&quot;Javascipt异步与同步&quot;&gt;&lt;/a&gt;Javascipt异步与同步&lt;/h2&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://wangdabao.js.org/tags/js/"/>
    
      <category term="事件" scheme="https://wangdabao.js.org/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>&#39;近期状况(非技术)&#39;</title>
    <link href="https://wangdabao.js.org/2018/04/17/%E8%BF%91%E6%9C%9F%E7%8A%B6%E5%86%B5/"/>
    <id>https://wangdabao.js.org/2018/04/17/近期状况/</id>
    <published>2018-04-16T18:25:00.000Z</published>
    <updated>2020-07-05T11:49:17.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>时间过的挺快的, 感觉浑浑噩噩的, 这一年过了快一半的时间。谈谈最新的状态</p></blockquote><h2 id="我的状态"><a href="#我的状态" class="headerlink" title="我的状态"></a>我的状态</h2><p>  工作上: 我感觉还是在有条不紊的进行着, 有时候就会忽然跑出来一些奇奇怪怪的想法。会觉得很空虚, 觉得好像自己什么不是很牢固的样子, 对于什么都是一知半解。有过迷茫,有过失落, 也彷徨不可前, 很躁动。(难道时夏天到了?我看了看旁边在敲代码的同事。)<br>  个人技术: 最近写了写underscore源码解析, 看的时候会有蛮多的不太理解的地方, 也有让我觉得某些方法的设计很别出心裁。 觉得自己可以可以去尝试这样的思路。<br>  学习了react的语法, 练了练手, 写了react-todo.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;时间过的挺快的, 感觉浑浑噩噩的, 这一年过了快一半的时间。谈谈最新的状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
    
      <category term="总结" scheme="https://wangdabao.js.org/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>&#39;mousewheel与DOMMouseScroll&#39;</title>
    <link href="https://wangdabao.js.org/2018/03/20/%E9%BC%A0%E6%A0%87%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%E5%85%BC%E5%AE%B9/"/>
    <id>https://wangdabao.js.org/2018/03/20/鼠标滚动事件兼容/</id>
    <published>2018-03-20T14:26:00.000Z</published>
    <updated>2020-07-05T11:49:17.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mousewheel-DOMMouseScroll"><a href="#mousewheel-DOMMouseScroll" class="headerlink" title="mousewheel-DOMMouseScroll"></a>mousewheel-DOMMouseScroll</h2><p>  最近在写vue的项目中涉及到了鼠标滚轮事件,之前没有用到过,所以踩了踩坑,想了想就写了一篇关于滚轮事件的文章。<br><a id="more"></a></p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>  起先我是不知道关于滚轮事件是有兼容的,当时我只写了@mousewheel一种方法,满心欢喜去迎接马上到来的幸福生活。<br>  先测了测chrome,没有问题完美实现。接下来是firefox,哎没有反应,我想了下肯定是姿势不对,再来一遍,漂亮,还是<br>  没有反应,这个时候我想到了可能是有兼容,百度了下发现确实是有兼容,原来兼容分为两种,一种是firefox,一种是其他。<br>  其他用到的是<code>mousewheel</code>而firefox用的是<code>DOMMouseScroll</code>。<br>  下面是用到的部分代码<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">handleScroll (e) &#123;</span><br><span class="line">  <span class="keyword">let</span> type = e.type;</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'DOMMouseScroll'</span> || type === <span class="string">'mousewheel'</span>) &#123;</span><br><span class="line">    eventDelta = (e.wheelDelta) ? e.wheelDelta : -(e.detail || <span class="number">0</span>) * <span class="number">40</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (eventDelta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="built_in">Math</span>.min(<span class="number">0</span>, <span class="keyword">this</span>.left + eventDelta);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ($containerWidth - padding &lt; $wrapperWidth) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.left &lt; -($wrapperWidth - $containerWidth + padding)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">this</span>.left;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="built_in">Math</span>.max(<span class="keyword">this</span>.left + eventDelta, $containerWidth - $wrapperWidth - padding);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.left = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  我要说的是其他的滚动是根据<code>e.wheelDelta</code>作为判断条件,其中向上滚动是120,而向下滚动则取反是-120。而firefox判断滚轮方向<br>  <code>e.detail</code>,向上判断是-3,向上则取反为3。</p><p>  这个时间祭出大杀器推荐大家张鑫旭的博客关于鼠标滚动更好的总结。<br>  <a href="http://www.zhangxinxu.com/wordpress/2013/04/js-mousewheel-dommousescroll-event/" target="_blank" rel="noopener">张鑫旭-关于鼠标滚轮事件</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;mousewheel-DOMMouseScroll&quot;&gt;&lt;a href=&quot;#mousewheel-DOMMouseScroll&quot; class=&quot;headerlink&quot; title=&quot;mousewheel-DOMMouseScroll&quot;&gt;&lt;/a&gt;mousewheel-DOMMouseScroll&lt;/h2&gt;&lt;p&gt;  最近在写vue的项目中涉及到了鼠标滚轮事件,之前没有用到过,所以踩了踩坑,想了想就写了一篇关于滚轮事件的文章。&lt;br&gt;
    
    </summary>
    
    
      <category term="事件兼容" scheme="https://wangdabao.js.org/tags/%E4%BA%8B%E4%BB%B6%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>&#39;this的值到底是什么？&#39;</title>
    <link href="https://wangdabao.js.org/2018/03/02/this%E7%9A%84%E5%80%BC%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://wangdabao.js.org/2018/03/02/this的值到底是什么/</id>
    <published>2018-03-02T05:54:48.000Z</published>
    <updated>2020-07-05T11:49:17.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ob = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo;</span><br><span class="line">obj.foo();  <span class="comment">//  打印的this为obj</span></span><br><span class="line">bar();  <span class="comment">//  打印的this为window</span></span><br></pre></td></tr></table></figure><p>  请解释最后两行函数的值为什么不一样。<br><a id="more"></a><br>  初学者关于this的理解一直很模糊。今天这篇文章就要一次讲清楚了。<br>  而且这个解释, 你在别的地方看不到。看懂这篇文章, 所有关于this的面试题, 都是小菜。</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>  首先需要从函数的调用开始讲起。<br>  JS(ES5)里面有这种函数调用形式:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(p1, p2);</span><br><span class="line">obj.child.methods(p1, p2);</span><br><span class="line">func.call(context, p1, p2);</span><br></pre></td></tr></table></figure></p><p>  一般, 初学者都知道前两种形式, 而且认为前两种形式优于第三种形式。<br>  从看到这篇文章起, 你一定要记住, 第三种调用形式, 才是正常调用形式:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.call(context, p1, p2);</span><br></pre></td></tr></table></figure></p><p>  其他两种形式都是语法糖, 可以等价地变为call形式:</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func(p1, p2) 等价于</span><br><span class="line">func.call(<span class="literal">undefined</span>, p1, p2)</span><br><span class="line">obj.child.method(p1, p2) 等价于</span><br><span class="line">obj.child.method.call(obj.child, p1, p2);</span><br></pre></td></tr></table></figure><p>  请记下来。(我们称次代码为转换代码, 方便下文引用)<br>  至此我们的函数调用只有一种形式:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.call(context, p1, p2)</span><br></pre></td></tr></table></figure></p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this, 就是上面代码中的context。就这么简单。<br>this是你call一个函数时的context, 由于你从来不用call形式的函数调用,所以你一直不知道。</p><h3 id="先看func-p1-p2-中的this如何确定"><a href="#先看func-p1-p2-中的this如何确定" class="headerlink" title="先看func(p1, p2)中的this如何确定:"></a>先看func(p1, p2)中的this如何确定:</h3><p>  当你写下面代码时<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure></p><p>等价于<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">func.call(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure></p><p>按理说打印出来的this应该就是undefined了吧, 但是浏览器里有一条规则:<br>如果你传的context就null或者undefined, 那么window对象就是默认的context(严格模式下默认context是undefined)<br>因此上面的打印结果是window。<br>如果你希望这里的this不是window, 很简单:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">call</span><span class="params">(obj)</span></span>  <span class="comment">//  那么里面的this就是obj对象了</span></span><br></pre></td></tr></table></figure></p><p>再看obj.child.method(p1, p2)的this如何确定<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br></pre></td></tr></table></figure></p><p>按照转换代码, 我们将obj.foo()转换为<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj<span class="selector-class">.foo</span><span class="selector-class">.call</span>(obj)</span><br></pre></td></tr></table></figure></p><p>好了, this就是obj。</p><p>回到题目<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = ob.foo</span><br><span class="line">obj.foo(); 转换为obj.foo.call(obj) <span class="keyword">this</span>就是obj</span><br><span class="line">bar() 转换为bar.call() 不传默认为<span class="literal">undefined</span> 所以指向<span class="built_in">window</span></span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>this 就是你 call 一个函数时，传入的 context。</li><li>如果你的函数调用形式不是 call 形式，请按照「转换代码」将其转换为 call 形式。</li></ol><p>转载自<a href="https://juejin.im/post/5857dad461ff4b00686cf97a" target="_blank" rel="noopener">掘金</a><br>原作者<code>方应杭在饥人谷</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;  &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ob = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  foo: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bar = obj.foo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.foo();  &lt;span class=&quot;comment&quot;&gt;//  打印的this为obj&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bar();  &lt;span class=&quot;comment&quot;&gt;//  打印的this为window&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  请解释最后两行函数的值为什么不一样。&lt;br&gt;
    
    </summary>
    
    
      <category term="关于this" scheme="https://wangdabao.js.org/tags/%E5%85%B3%E4%BA%8Ethis/"/>
    
  </entry>
  
  <entry>
    <title>&#39;2017年度总结&#39;</title>
    <link href="https://wangdabao.js.org/2018/02/22/2017%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://wangdabao.js.org/2018/02/22/2017年总结/</id>
    <published>2018-02-22T07:54:48.000Z</published>
    <updated>2020-07-05T11:49:17.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017年度总结"><a href="#2017年度总结" class="headerlink" title="2017年度总结"></a>2017年度总结</h2><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>2017年7月我从学校毕业出来,开始正式的进入社会,对一切充满了未知。当时我没有第一时间去选择找工作而是觉得当时的自己对于自己的认知还不是特别的明确,当然其中包括我对于自己要选择工作的技能。我觉得以我当时的能力还不足以去让自己能够找到心仪的工作,所以我当时选择了回家去闭关静修。我到了9月初选择了去找工作,短短两个月的时间,讲道理在我闭关的时间里没有我想象当中的那么的辛苦,当然我还是要去感谢当时自己的两个月的努力。可能努力的结果没有达到我现在的要求。但是,还是让我找到了工作。</p></blockquote><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>  在公司工作了将近半年把,公司对于技术方面还是非常新颖的,一些相对来说比较久的相关采用的是angular.js,对于当时来说用的技术还是比较新的。之后的一些项目也是采用了比较火的框架<code>Vue</code>,因为之前在闭关的时候写了一个关于Vue的项目,所以对于上手还是相对比较轻松的。<br>  再到后来重构了某个比较大的项目,采用了Vue。我想了想对于踩坑还是比较多的,差点逼死我。当然对于技术的提升还是蛮大的。反正就是慢慢来吧。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>把javascipt高级程序设计重新再看一遍。</li><li>把vue源码读一遍,理解相关部分。</li><li>博客每个星期更新一次。</li><li>github更新与打卡的记录更多一些。</li><li>了解并熟悉Http。</li><li>健身。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  总的来说这一年感慨还蛮多的,加上自己是一个比较多愁善感的人,很容易被周围的情绪影响。所以更多的时间我反而是在做自己想做的事情。没有更多去和朋友多去接触。家里人更多的是让我去和朋友多去接触,扩展人际关系。还有就是家里人也着急起来我的婚姻大事,我想说的是(婚姻大事我从没有放下),但更多的我还是在说再等等。<br>  2018年努力努力再努力。<br>  加油。<br>  先到这,想到再更。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2017年度总结&quot;&gt;&lt;a href=&quot;#2017年度总结&quot; class=&quot;headerlink&quot; title=&quot;2017年度总结&quot;&gt;&lt;/a&gt;2017年度总结&lt;/h2&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://wangdabao.js.org/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>music</title>
    <link href="https://wangdabao.js.org/2018/01/14/%E6%88%91%E5%9C%A8%E6%9C%AA%E6%9D%A5%E7%AD%89%E4%BD%A0/"/>
    <id>https://wangdabao.js.org/2018/01/14/我在未来等你/</id>
    <published>2018-01-14T08:38:48.000Z</published>
    <updated>2020-07-05T11:49:17.875Z</updated>
    
    <content type="html"><![CDATA[<pre><code>好妹妹-我在未来等你</code></pre><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=526470685&auto=0&height=66"></iframe><br><a id="more"></a><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">作曲 : 好妹妹</span><br><span class="line">作词 : 刘同</span><br><span class="line">钢琴编曲、演奏：韩韵</span><br><span class="line">合音编曲：鱼椒盐</span><br><span class="line"></span><br><span class="line">课堂上 老师说写信</span><br><span class="line">写给 未来的自己</span><br><span class="line">握着笔 想了千言万语</span><br><span class="line">最后只剩心虚</span><br><span class="line"></span><br><span class="line">写不出 骄傲的字句</span><br><span class="line">写不出 满怀的期许</span><br><span class="line">写满了 很多疑惑和问题</span><br><span class="line">写满 年少的身影</span><br><span class="line"></span><br><span class="line">坐下吧 一起写封信</span><br><span class="line">写给 未来的自己</span><br><span class="line">望穿了 多少春来冬去</span><br><span class="line">跋涉光年的距离</span><br><span class="line"></span><br><span class="line">我写了 很多的问题</span><br><span class="line">像一首 自己的主题曲</span><br><span class="line">未来你会做着什么事情</span><br><span class="line">听着怎样的歌曲</span><br><span class="line"></span><br><span class="line">小心翼翼学会长大</span><br><span class="line">头破血流了吗</span><br><span class="line">奋不顾身了吗</span><br><span class="line">做了喜欢的事吗</span><br><span class="line">能不能找到他</span><br><span class="line">陌生世界虽然很大</span><br><span class="line">一个人也会好吧</span><br><span class="line">习惯寂寞了吗</span><br><span class="line">孤单身影 不再害怕</span><br><span class="line">呐喊就有回答</span><br><span class="line"></span><br><span class="line">我问未来的自己 （我想问自己）</span><br><span class="line">写了很多的问题 （会在哪里）</span><br><span class="line">我知道了我的目的地</span><br><span class="line">未来你会在哪里</span><br><span class="line">我会用尽全力 狂奔到那里</span><br><span class="line">我会在未来等你</span><br><span class="line"></span><br><span class="line">坐下吧 一起写封信</span><br><span class="line">写给 未来的自己</span><br><span class="line">望穿了 多少春来冬去</span><br><span class="line">跋涉光年的距离</span><br><span class="line"></span><br><span class="line">我写了 很多的问题</span><br><span class="line">像一首 自己的主题曲</span><br><span class="line">未来你会做着什么事情</span><br><span class="line">听着怎样的歌曲</span><br><span class="line"></span><br><span class="line">小心翼翼学会长大</span><br><span class="line">头破血流了吗</span><br><span class="line">奋不顾身了吗</span><br><span class="line">做了喜欢的事吗</span><br><span class="line">能不能找到他</span><br><span class="line">陌生世界虽然很大</span><br><span class="line">一个人也会好吧</span><br><span class="line">习惯寂寞了吗</span><br><span class="line">孤单身影 不再害怕</span><br><span class="line">呐喊就有回答</span><br><span class="line"></span><br><span class="line">我问未来的自己 （我想问自己）</span><br><span class="line">写了很多的问题 （会在哪里）</span><br><span class="line">我知道了我的目的地</span><br><span class="line">未来你会在哪里</span><br><span class="line">我会用尽全力 狂奔到那里</span><br><span class="line">我会在未来等你</span><br><span class="line"></span><br><span class="line">我会在未来等你</span><br><span class="line">在每一个路口拥抱你</span><br><span class="line"></span><br><span class="line">制作人：刘晓光</span><br><span class="line">合音：鱼椒盐、张恋歌、樊竹青</span><br><span class="line">萨克斯：刘晓光</span><br><span class="line">录音棚：<span class="number">55</span>T<span class="selector-class">.E</span><span class="selector-class">.C</span> Beijing</span><br><span class="line">录音师：张一白</span><br><span class="line">混音：李游</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;好妹妹-我在未来等你
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=526470685&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="综合" scheme="https://wangdabao.js.org/tags/%E7%BB%BC%E5%90%88/"/>
    
      <category term="music" scheme="https://wangdabao.js.org/tags/music/"/>
    
  </entry>
  
  <entry>
    <title>music</title>
    <link href="https://wangdabao.js.org/2018/01/12/%E4%BD%A0%E4%BC%9A%E7%88%B1%E6%88%91%E5%BE%88%E4%B9%85%E5%90%97/"/>
    <id>https://wangdabao.js.org/2018/01/12/你会爱我很久吗/</id>
    <published>2018-01-12T08:38:48.000Z</published>
    <updated>2020-07-05T11:49:17.874Z</updated>
    
    <content type="html"><![CDATA[<pre><code>秦昊-你会爱我很久吗</code></pre><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=34125723&auto=0&height=66"></iframe><br><a id="more"></a><br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">作曲 : 陈耀川</span><br><span class="line">作词 : 小虫</span><br><span class="line">我害怕你的柔 害怕如此对我</span><br><span class="line">到底还有什么给我</span><br><span class="line">不是我未曾心动 只是有些不懂</span><br><span class="line">这样的相爱还有多久</span><br><span class="line">教我如何不去想你承诺过的话</span><br><span class="line">声声的爱我分不清是真假</span><br><span class="line">啊你呀你 教我如何不牵挂</span><br><span class="line">倘若是真的你会爱我很久吗</span><br><span class="line">你总是这样的说教我别想太多</span><br><span class="line">你永远一直在我左右</span><br><span class="line">不是我故意不懂只是有些疑惑</span><br><span class="line">这样的相爱还有多久</span><br><span class="line">教我如何不去想你承诺过的话</span><br><span class="line">声声的爱我分不清是真假</span><br><span class="line">啊你呀你 教我如何不牵挂</span><br><span class="line">倘若是真的你会爱我很久吗</span><br><span class="line">教我如何不去想你承诺过的话</span><br><span class="line">声声的爱我分不清是真假</span><br><span class="line">啊你呀你教我如何不牵挂</span><br><span class="line">倘若是真的你会爱我很久吗</span><br><span class="line">倘若是真的你会爱我很久吗</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;秦昊-你会爱我很久吗
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=34125723&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="综合" scheme="https://wangdabao.js.org/tags/%E7%BB%BC%E5%90%88/"/>
    
      <category term="music" scheme="https://wangdabao.js.org/tags/music/"/>
    
  </entry>
  
  <entry>
    <title>&#39;javascript-数组去重&#39;</title>
    <link href="https://wangdabao.js.org/2018/01/10/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>https://wangdabao.js.org/2018/01/10/数组去重/</id>
    <published>2018-01-10T07:15:15.000Z</published>
    <updated>2020-07-05T11:49:17.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Javascipt数组去重"><a href="#Javascipt数组去重" class="headerlink" title="Javascipt数组去重"></a>Javascipt数组去重</h2><h3 id="方法一-双循环（时间复杂度比较高-性能一般。）"><a href="#方法一-双循环（时间复杂度比较高-性能一般。）" class="headerlink" title="方法一: 双循环（时间复杂度比较高, 性能一般。）"></a>方法一: 双循环（时间复杂度比较高, 性能一般。）</h3><a id="more"></a> <h4 id="测试用例一"><a href="#测试用例一" class="headerlink" title="测试用例一"></a>测试用例一</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">var</span> isRepeat;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    isPepeat = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// console.log(arr[i], 'arr[i]');</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="comment">// console.log(arr[j], '111');</span></span><br><span class="line">      <span class="built_in">console</span>.log(arr[i], <span class="string">'arr[i]'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(arr[j], <span class="string">'arr[j]'</span>);         </span><br><span class="line">      <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">        isPepeat = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isPepeat) &#123;</span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr)); <span class="comment">//  [2, 3, 1]</span></span><br></pre></td></tr></table></figure><h4 id="测试用例二"><a href="#测试用例二" class="headerlink" title="测试用例二"></a>测试用例二</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="comment">// console.log(j);</span></span><br><span class="line">      <span class="keyword">if</span> (arr[i] === arr[j]) &#123;   </span><br><span class="line">        j = ++i;  <span class="comment">//  不理解这里的意思,恕我愚钝</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(arr[i]);</span></span><br><span class="line">    newArr.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr)); <span class="comment">//  [2, 3, 1]</span></span><br></pre></td></tr></table></figure><p>  tip: j = ++i;等价于 j = j + 1; i = i + 1；<br>       整体思路就是如果是重复元素,则跳过重复元素,不对其进行push操作。</p><h3 id="方法二-Array-prototype-indexOf"><a href="#方法二-Array-prototype-indexOf" class="headerlink" title="方法二: Array.prototype.indexOf()"></a>方法二: Array.prototype.indexOf()</h3><h4 id="测试用例三"><a href="#测试用例三" class="headerlink" title="测试用例三"></a>测试用例三</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// console.log(item);</span></span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">    <span class="built_in">console</span>.log(arr.indexOf(item));</span><br><span class="line">    <span class="comment">//  其中indexOf代表着item里面第一次出现的位置,</span></span><br><span class="line">    <span class="comment">//  这样的话返回的也是所有第一次出现的元素。恩,对,没错。</span></span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(item) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr)); <span class="comment">//  [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>  tip: var new_array = arr.filter(callback, [thisArg])<br>       callback: 用来测试数组的每个元素的函数,调用时使用参数(element,index, array)。<br>       返回true表示保留该元素(通过测试),false则不保留。<br>       thiArg: 可选。执行callback时的用于this的值。<br>  <strong>整体思路就是索引不是第一个索引,说明是重复值。</strong></p><p>  详情见:<br>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="noopener">MDN-filter</a></p><h4 id="测试用例四"><a href="#测试用例四" class="headerlink" title="测试用例四"></a>测试用例四</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(newArr);</span><br><span class="line">    <span class="built_in">console</span>.log(newArr.indexOf(element));</span><br><span class="line">    <span class="keyword">if</span> (newArr.indexOf(element) === <span class="number">-1</span>) &#123;</span><br><span class="line">      newArr.push(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr)); <span class="comment">//  [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>  tip: indexOf在这里代表着,当newArr里没有这个元素所以返回了-1,<br>       而当newArr没有重复元素时,indexOf返回的都是-1。<br>  <strong>整体思路为当没有没有重复元素返回-1,满足条件成立返回出去</strong></p><p>  详情见:<br>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf" target="_blank" rel="noopener">MDN-indexOf</a></p><h3 id="方法三-Array-prototype-sort"><a href="#方法三-Array-prototype-sort" class="headerlink" title="方法三: Array.prototype.sort()"></a>方法三: Array.prototype.sort()</h3><h4 id="测试用例五"><a href="#测试用例五" class="headerlink" title="测试用例五"></a>测试用例五</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  arr.sort();</span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] !== arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">unique(arr); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>  tip: 原理就是按照排序的方式进行排序如[1, 2, 3, 1, 3]排序过后<br>       就会形成[1, 1, 2, 3, 3]。当然这里有一个问题是sort对于其他<br>       比如说[1, 11, 22, 18]就不会按照你设想的去排序,它会排序为<br>       [1, 11, 18, 22]。然后就是进行判断相邻的(相邻的比如1, 1)<br>       如果不相等就push然后返回。恩完美。</p><p>  详情见:<br>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener">MDN-sort</a></p><h4 id="测试用例六"><a href="#测试用例六" class="headerlink" title="测试用例六"></a>测试用例六</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  arr.sort();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// console.log(arr[i]);</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr[i], newArr[newArr.length - <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// console.log(arr[i]);              </span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] !== newArr[newArr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="comment">// console.log(arr[i]);                    </span></span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">unique(arr);  <span class="comment">//  [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>  tip: 这里利用到的是与数组的进行比对,如果匹配不成功则push。<br>       这里的点是进行第一次比对时因为数组为空那么它的长度-1就是undefined，<br>       然后push了1进入。第二次比对发现长度-1与arr[i]匹配成功,条件不满足。<br>       进行第三次匹配,以此类推。</p><h3 id="方法四-使用对象key来去重"><a href="#方法四-使用对象key来去重" class="headerlink" title="方法四: 使用对象key来去重"></a>方法四: 使用对象key来去重</h3><h4 id="测试用例7"><a href="#测试用例7" class="headerlink" title="测试用例7"></a>测试用例7</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">var</span> tmp = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(tmp);</span><br><span class="line">    <span class="keyword">if</span> (!tmp[arr[i]]) &#123;     </span><br><span class="line">      <span class="comment">// console.log(tmp[arr[i]]);</span></span><br><span class="line">      tmp[arr[i]] = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// console.log(tmp);</span></span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">unique(arr);</span><br></pre></td></tr></table></figure><p>  tip: 这里利用了对象(tmp)的key不可以重复的特性进行去重。<br>       当进行匹配的时候默认情况下,是不存在tmp[arr[i]]的,<br>       符合条件进行复制与push。循环往复。当有重复的元素时,<br>       条件不满足。结束。</p><p>  注意问题: // 更新一下问题明白了。<br>    //  这里我不太理解,希望有明白的能给解释下。</p><pre><code>- 无法区分隐式类型转换成字符后一样的值, 比如1和&apos;1&apos;。- 无法处理复杂数据类型, 比如对象(因为对象作为key会变成[object Object])。- 特殊数据, 比如&apos;_proto_&apos;会挂掉,因为tmp对象的_proto_属性无法被重写。</code></pre><p>  解决1, 3: 可以为对象的key增加一个类型,或者将类型放到对象的value中来解决:</p><h4 id="测试用例8"><a href="#测试用例8" class="headerlink" title="测试用例8"></a>测试用例8</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">var</span> tmp = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> tmpKey;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">      tmpKey = <span class="keyword">typeof</span> arr[i] + arr[i];</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(tmpKey); </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(!tmp[tmpKey])&#123;</span><br><span class="line">          tmp[tmpKey] = <span class="number">1</span>;</span><br><span class="line">          newArr.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr)); <span class="comment">//  [1,2,3]</span></span><br></pre></td></tr></table></figure><p>  <img src="https://qn.tyty.me/2018-01-12%2011-56-14%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="text"><br>  这里换成了 var arr = [{xiaoming:23,xiaoqing:45},{xiaoming:24,xiaoqing:45}];<br>  <img src="https://qn.tyty.me/2018-01-12%2011-51-32%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="text"></p><p>  解决问题二: 可以把对象序列化之后作为key来使用。这里使用了JSON.stringify()进行序列化。</p><h4 id="测试用例9"><a href="#测试用例9" class="headerlink" title="测试用例9"></a>测试用例9</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">var</span> tmp = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> tmpKey;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">      tmpKey = <span class="keyword">typeof</span> arr[i] + <span class="built_in">JSON</span>.stringify(arr[i]);</span><br><span class="line">      <span class="comment">// console.log(tmpKey); </span></span><br><span class="line">      <span class="keyword">if</span>(!tmp[tmpKey])&#123;</span><br><span class="line">          tmp[tmpKey] = <span class="number">1</span>;</span><br><span class="line">          newArr.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><p>  <img src="https://qn.tyty.me/2018-01-12%2012-01-00%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="text"></p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="方法一-Map"><a href="#方法一-Map" class="headerlink" title="方法一: Map"></a>方法一: Map</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tmp.get(arr[i])) &#123;</span><br><span class="line">      tmp.set(arr[i], <span class="number">1</span>);</span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">unique(arr);  <span class="comment">//  [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>  tip: 这里用的是ES6-Map,是一种新的数据类型,类似于对象, 也是键值对的集合, 但是”键”的范围不限于字符串,<br>       各种类型的值(包括对象)都可以当做键。可以把它想象成key类型没有限制的对象。它的存取使用单独的get()<br>       set()接口。<br>       这里的方法也是进行判断tmp数组get有没有key与value如果没有就push,如果有判断条件不成立。<br>  <img src="https://qn.tyty.me/2018-01-12%2014-41-01%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="">     </p><h3 id="方法二-Set"><a href="#方法二-Set" class="headerlink" title="方法二: Set"></a>方法二: Set</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(set);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr)); <span class="comment">//  [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>  tip: Set是一种新的数据结构。它类似与数组,但是成员的值都是唯一的,没有重复的值。<br>       Array.from方法从类似数组或可迭代对象创建一个新的数组实例。<br>       也可以使用扩展运算符 return […set]与Array.from同理。</p><h3 id="方法三-Array-prototype-includes"><a href="#方法三-Array-prototype-includes" class="headerlink" title="方法三: Array.prototype.includes"></a>方法三: Array.prototype.includes</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(newArr.includes(element));</span><br><span class="line">    <span class="keyword">if</span> (!newArr.includes(element)) &#123;</span><br><span class="line">      newArr.push(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr)); <span class="comment">//  [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>  tip: includes方法用来判断一个数组是否包含一个指定的值,如果包含则返回true,<br>       否则返回false。恩,就是这样。</p><h3 id="纯手打。"><a href="#纯手打。" class="headerlink" title="纯手打。"></a>纯手打。</h3><p>  加了一些自己的理解。后续还会加入更多关于数组去重的方法。 就这样,溜了。。。</p><h3 id="原文章"><a href="#原文章" class="headerlink" title="原文章"></a><a href="https://zhuanlan.zhihu.com/p/25545584" target="_blank" rel="noopener">原文章</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Javascipt数组去重&quot;&gt;&lt;a href=&quot;#Javascipt数组去重&quot; class=&quot;headerlink&quot; title=&quot;Javascipt数组去重&quot;&gt;&lt;/a&gt;Javascipt数组去重&lt;/h2&gt;&lt;h3 id=&quot;方法一-双循环（时间复杂度比较高-性能一般。）&quot;&gt;&lt;a href=&quot;#方法一-双循环（时间复杂度比较高-性能一般。）&quot; class=&quot;headerlink&quot; title=&quot;方法一: 双循环（时间复杂度比较高, 性能一般。）&quot;&gt;&lt;/a&gt;方法一: 双循环（时间复杂度比较高, 性能一般。）&lt;/h3&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://wangdabao.js.org/tags/js/"/>
    
      <category term="Array" scheme="https://wangdabao.js.org/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>&#39;git命令(全)&#39;</title>
    <link href="https://wangdabao.js.org/2017/10/01/git%E5%91%BD%E4%BB%A4%E5%9B%BE(%E5%85%A8)/"/>
    <id>https://wangdabao.js.org/2017/10/01/git命令图(全)/</id>
    <published>2017-10-01T14:02:12.000Z</published>
    <updated>2020-07-05T11:49:17.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><a id="more"></a><p><img src="https://wangdabaoqq.github.io/hexo-back-up/assets/img/git命令.jpg" alt="git"></p><p>转载自掘金,手打。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;git&quot;&gt;&lt;a href=&quot;#git&quot; class=&quot;headerlink&quot; title=&quot;git&quot;&gt;&lt;/a&gt;git&lt;/h2&gt;
    
    </summary>
    
    
      <category term="git命令" scheme="https://wangdabao.js.org/tags/git%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>&#39;移动端资源整合部分&#39;</title>
    <link href="https://wangdabao.js.org/2017/09/27/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    <id>https://wangdabao.js.org/2017/09/27/移动端/</id>
    <published>2017-09-27T15:09:56.000Z</published>
    <updated>2020-07-05T11:49:17.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="meta篇"><a href="#meta篇" class="headerlink" title="meta篇"></a>meta篇</h2><h3 id="1-视窗宽度"><a href="#1-视窗宽度" class="headerlink" title="1.视窗宽度"></a>1.视窗宽度</h3><a id="more"></a><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;, initial-scale=1.0, minimum-scale=1.0, maxinum-scale=1.0,user-scalable=no&quot;&quot;&gt;</code></p><p>其中width=device-width是设置视窗宽设备宽度,还可以固定宽度,例如:width=640则是640px的宽度(常见于微信);<br>initial-scale=1.0: 设置缩放比例为1.0;<br>minimum-scale=1.0和maximum-scale=1.0: 最大缩放比例和最大缩放比例;<br>user-scalable-no: 禁止用户自由缩放,user-scalable默认值为yes.</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initscale=1.0, user-scalable=no&quot;&gt;</code></p><h3 id="自动识别格式"><a href="#自动识别格式" class="headerlink" title="自动识别格式"></a>自动识别格式</h3><p><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</code></p><p>content里面的参数: telephone是禁止浏览器自动识别手机号码,email=no是禁止浏览器自动识别Email.</p><h3 id="完整模板"><a href="#完整模板" class="headerlink" title="完整模板"></a>完整模板</h3><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt;</code></p><p><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</code></p><p><code>&lt;meta name=&quot;formate-detection&quot; content=&quot;email=no&quot;&gt;</code></p><h2 id="CSS篇"><a href="#CSS篇" class="headerlink" title="CSS篇"></a>CSS篇</h2><pre>body {  font-family: "Helvetica Neue",  Helvetica, STHeiTi, sans-serif;  /* 使用无衬线字体 */}a, img {  -webkit-touch-callout: none;  /* 禁止长按链接与图片弹出菜单 */}html, body {  -webkit-user-slect: none;  /* 禁止选中文中 */  user-select: none;}button, input, optgroup, select, textarea {  -webkit-tap-highlight-color: rgab(0, 0, 0, 0);  /* 去掉a, input和button点击时的蓝色外边框和灰色半透明背景 */}input::-webkit-input-placeholder {  color: #ccc;  /* 修改webkit中input的planceholder样式 */  }input:focus::-webkit-input-placeholder {  color: #f00;  /* 修改webkit中focus状态下input的planceholder样式 */}body {  -webkit-text-size-adjust: 100%!important;  /* 禁止Ios调整字体大小 */}input::-webkit-input-speech-button {  display: none;  /* 隐藏Android的语音输入按钮 */}</pre><h2 id="flex基础篇"><a href="#flex基础篇" class="headerlink" title="flex基础篇"></a>flex基础篇</h2><p>这里假设flex容器为.box, 子元素为item</p><h3 id="定义容器为flex布局"><a href="#定义容器为flex布局" class="headerlink" title="定义容器为flex布局"></a>定义容器为flex布局</h3>  <pre>    .box {      display: -webkit-flex;       display: flex;    }    /* 行内flex */    .box {      display: -webkit-inline-flex;      display: inline-flex;    }  </pre><h3 id="容器样式"><a href="#容器样式" class="headerlink" title="容器样式"></a>容器样式</h3>  <pre>  .box {    flex-direction: row | row-reverse | column | column-reverse;    /* 主轴方向: 从左到右(默认) | 从右到左 | 上到下 | 下到上 -->    flex-wrap: norwap | wrap | wrap-reverse;    /* 换行: 不换行(默认) | 换行 | 换行并第一行在下方 */    flex-flow: flex-direction | flex-wrap;    /* 主轴方向和换行简写 */    justify-content: flex-start | flex-end | center | space-between | space-argound;    /* 主轴对齐方式: 左对齐(默认) | 右对齐 | 居中对齐 | 两端对齐 | 平均分布 */    align-items: flex-start | flex-end | center | baseline | stretch;    /* 交叉轴对齐方式: 顶部对齐(默认) 顶部对齐 居中对齐 | 上下对齐并铺满 | 文本基线对齐 */    align-content: flex-start | flex-end | cneter | space-between | space-around | strech;    /* 多主轴对齐: 顶部对齐(默认) | 顶部对齐 | 居中对齐 | 上下对齐并铺满 | 上下平均分布 */  }  </pre><h3 id="子元素样式"><a href="#子元素样式" class="headerlink" title="子元素样式"></a>子元素样式</h3><pre>  item {    order: integer;    /* 排序: 数值越小,越排前,默认为0 */    flex-grow: <number>      /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/    flex-shrink: <number>    /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/    flex-basis: <length> | auto; /* default auto */    /*固定大小：默认为0，可以设置px值，也可以设置百分比大小*/    flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]    /*flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，*/    align-self: auto | flex-start | flex-end | center | baseline | stretch;    /*单独对齐方式：自动（默认） | 顶部对齐 | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/  }</'flex-basis'></'flex-shrink'></'flex-grow'></length></number></number></pre><h2 id="小技巧篇"><a href="#小技巧篇" class="headerlink" title="小技巧篇"></a>小技巧篇</h2><h3 id="自定义苹果图标"><a href="#自定义苹果图标" class="headerlink" title="自定义苹果图标"></a>自定义苹果图标</h3><p>在网站文件根目录放一个 apple-touch-icon.png 文件，苹果设备保存网站为书签或桌面快捷方式时，就会使用这个文件作为图标，文件尺寸建议为：180px × 180px。</p><h3 id="自定义favicon"><a href="#自定义favicon" class="headerlink" title="自定义favicon"></a>自定义favicon</h3><p><code>&lt;link rel=&quot;icon&quot; href=&quot;favicon.icon&quot; mce_href=&quot;favicon.icon&quot; type=&quot;image/x-icon&quot;&gt;</code></p><h3 id="定义浏览器点击行为"><a href="#定义浏览器点击行为" class="headerlink" title="定义浏览器点击行为"></a>定义浏览器点击行为</h3><p><code>&lt;a href=&quot;tel: 020-10086&quot;&gt;打电话: 020-10086&lt;/a&gt;</code></p><p><code>&lt;a href=&quot;sms: 10086&quot;&gt;发短信&lt;/a&gt;</code></p><p><code>&lt;a href=&quot;mailto:me@22.clue&gt;发送邮件&lt;/a&gt;</code></p><h3 id="定义上传文件类型和格式"><a href="#定义上传文件类型和格式" class="headerlink" title="定义上传文件类型和格式"></a>定义上传文件类型和格式</h3><p><code>&lt;input type=&quot;file&quot; accept=&quot;image/*&quot;&gt;</code></p><p>上面的文件上传框中,accept可以限制上传文件的类型,参数image/<em>是所有图片类型,点击会弹出图库,也可以指定图片格式,参数设置成image/png则可以限制图片类型png,参数如果为video/</em>则是选择视频的意思;accept还可以设置多个文件格式,语法为accept=”image/gif, image/jpeg”;</p><h3 id="使用box-shadow改变-挡住-表单自动填充后的黄色"><a href="#使用box-shadow改变-挡住-表单自动填充后的黄色" class="headerlink" title="使用box-shadow改变(挡住)表单自动填充后的黄色"></a>使用box-shadow改变(挡住)表单自动填充后的黄色</h3><pre>  input:-webkit-autofill, textarea: -webkit-autofill, select:-webkit-autofill {    box-shadow: inset 0 0 0 1000px #fff;  }</pre><h3 id="用CSS实现省略号截断"><a href="#用CSS实现省略号截断" class="headerlink" title="用CSS实现省略号截断"></a>用CSS实现省略号截断</h3><p><code>white-space: nowrap;text-overflow: elipsis;</code></p><h3 id="使用border绘制小三角"><a href="#使用border绘制小三角" class="headerlink" title="使用border绘制小三角"></a>使用border绘制小三角</h3><p>原理是:上下和左右的边框对接其实是个斜角,利用这个特性,使其中一边的边框透明,另外一边写成想要的颜色并隐藏对边,就可以变成小箭头形状。</p><p><img src="https://qn.tyty.me/三角形.png" alt="text"></p><pre>  border-width: 10px 10px 10px 0;  /* 三角形 */  border-color: transparent #fff;  border-style: solid;  width: 0; </pre><p>Toptips写法</p><p><code>&lt;div class=&quot;box&quot;&gt;嗨！点击菜单就可以关注兮兮公众号了哟</code></p><pre>.box {  position: relative;  padding: 0 20px;  width: 380px;  height: 80px;  border-radius: #efefef;  font-size: 18px;  line-height: 80px;}.box:after {  position: absolute;  top: 50%;  left: -15px;  z-index: 1;  display: block;  margin-top: -15px;  width: 0;  border-color: transparent #efefef;  border-style: solid;  border-width: 15px 15px 15px 0;  content: '';}</pre><p><img src="https://qn.tyty.me/toptips.png" alt="text"></p><p>以上内容绝对纯手打,没有任何机打痕迹。<br>转载自作者Heleth</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;meta篇&quot;&gt;&lt;a href=&quot;#meta篇&quot; class=&quot;headerlink&quot; title=&quot;meta篇&quot;&gt;&lt;/a&gt;meta篇&lt;/h2&gt;&lt;h3 id=&quot;1-视窗宽度&quot;&gt;&lt;a href=&quot;#1-视窗宽度&quot; class=&quot;headerlink&quot; title=&quot;1.视窗宽度&quot;&gt;&lt;/a&gt;1.视窗宽度&lt;/h3&gt;
    
    </summary>
    
    
      <category term="web" scheme="https://wangdabao.js.org/tags/web/"/>
    
      <category term="移动端" scheme="https://wangdabao.js.org/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>&#39;Javascript数组方法(ES5-ES6)&#39;</title>
    <link href="https://wangdabao.js.org/2017/09/20/Javascript%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <id>https://wangdabao.js.org/2017/09/20/Javascript的数组方法/</id>
    <published>2017-09-20T14:30:12.000Z</published>
    <updated>2020-07-05T11:49:17.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="join-ES5"><a href="#join-ES5" class="headerlink" title="join() ES5"></a>join() ES5</h2><a id="more"></a><p>join(speparator):将数组的元素组起一个字符串,spearator为分隔符,省略的话则用默认用逗号为分隔符,该方法只接收一个参数,即分隔符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.join());</span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">'-'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure></p><p>通过join()方法可以重复字符串,只需传入字符串以及重复的次数,就能返回重复后的字符串,函数如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatString</span>(<span class="params">str, n</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).join(str));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).join(str);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(repeatString(<span class="string">'abc'</span>, <span class="number">3</span>)); <span class="comment">// abcabcabc</span></span><br></pre></td></tr></table></figure></p><h2 id="push-和pop-ES5"><a href="#push-和pop-ES5" class="headerlink" title="push()和pop() ES5"></a>push()和pop() ES5</h2><p>push()：可以接收任意数量的参数，把他们逐个添加到数组末尾,并返回修改后数组的长度。<br>pop()：数组末尾移除最后,减少数组的length值,然后返回移除的项。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'mi'</span>, <span class="string">'to'</span>, <span class="string">'you'</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr.push(<span class="string">'yao'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="keyword">var</span> sd = arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(sd);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure></p><h2 id="shift-和unshift"><a href="#shift-和unshift" class="headerlink" title="shift()和unshift()"></a>shift()和unshift()</h2><p>shift(): 删除原数组第一项,并返回删除元素的值,如果数组为空则返回undefind.<br>unshift():将参数添加到原数组开头,并返回数组的长度。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'ss'</span>, <span class="string">'ll'</span>, <span class="string">'tt'</span>];</span><br><span class="line"><span class="keyword">var</span> cc = arr.unshift(<span class="string">'cc'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cc);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="keyword">var</span> ii = arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(ii);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure></p><h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><p>sort():按照升序数组项-即最小的值位于最前面,最大的值排在最后面。<br>在排序时,sort()方法会调用每个数组项的toString()转型方法,然后比较得到的字符串,以确定如何排序。即使数组中的每一项都是数值,sort()方法比较的也是字符串,因此会出现一下情况:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort());</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.sort());</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// 原数组被改变</span></span><br></pre></td></tr></table></figure></p><p>为了解决上述问题,sort()可以接收一个比较函数作为参数,以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数,如果第一个参数应该位于第二个之前则返回一个负数,如果两个参数相等则返回0,如果第一个参数位于第二个之后则返回一个正数。<br>升序：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span> (<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">23</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">333</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort(compare));</span><br></pre></td></tr></table></figure></p><p>降序：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span> (<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">89</span>, <span class="number">23</span>, <span class="number">45</span>, <span class="number">99</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(compare));</span><br></pre></td></tr></table></figure></p><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h2><p>reserve():反转数组项的顺序<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>, <span class="number">34</span>, <span class="number">546</span>, <span class="number">333</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.reverse());</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">//  原数组改变</span></span><br></pre></td></tr></table></figure></p><h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h2><p>concat()：将参数添加到原数组中。这个方法会先创建当前数组的一个副本,然后将接收到的参数添加这个副本的末尾,最后返回新构建的数组。在没有concat()方法传递参数的情况下,它只是复制当前数组并返回副本。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> ss = arr.concat(<span class="number">98</span>, [<span class="number">23</span>, <span class="number">78</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ss);</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">//  原数组未改变</span></span><br></pre></td></tr></table></figure></p><p>传入的不是数组,则直接把参数添加到原数组的后面,传入的数组也是添加到原数组的后面。<br>传入的二维数组？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cv = arr.concat([<span class="number">0</span>, [<span class="number">11</span>, <span class="number">89</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(cv);  <span class="comment">//  [1, 5, 9, 0, [11, 89]];</span></span><br><span class="line"><span class="built_in">console</span>.log(cv[<span class="number">4</span>]); <span class="comment">//  [11, 89]</span></span><br></pre></td></tr></table></figure></p><p>上述代码中,cv的第4项是一个包含两项的数组,也就是说concat方法只能将传入数组中的每一项添加到数组中,如果传入数组中有些项是数组,那么也会把这一数组项当作一项添加到cv中。</p><h2 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h2><p>slice(): 返回从原数组中指定开始下标和结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数,即要返回项的起始和结束位置。在只有一个参数的情况下,slice()方法返回从该参数指定位置开始到当前数组的末尾的所有项,如果有两个参数,该方法返回起始位置和结束位置之间的项-但不包括结束的位置的项。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">90</span>, <span class="number">81</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr.slice(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);</span><br><span class="line"><span class="keyword">var</span> count1 = arr.slice(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count1);</span><br><span class="line"><span class="keyword">var</span> count2 = arr.slice(<span class="number">1</span>, <span class="number">-2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count2);</span><br><span class="line"><span class="keyword">var</span> count3 = arr.slice(<span class="number">-2</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count3);</span><br></pre></td></tr></table></figure></p><p>count只设置了一个参数,也就是起始下标为1,所以返回的数组为下标,(包括下标)开始到数组的最后。</p><p>count2只设置了两个参数,返回起始下标(包括1)开始到终止下标(不包括4)。</p><p>count3只设置了两个参数,终止下标为负数,当出现负数时,将负数加上数组的长度的值(5)来替换该位置的数,因此就是1开始到3。<br>count4中两个参数都是负数,所以都加上数组的长度5转换成正数,因此相当于slice(3, 4);</p><h2 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h2><p>splice()：很强大的数组方法,它有很多用法,可以实现删除，插入和替换。</p><p>删除：可以删除任意数量的项,它只需指定两个参数,要删除的第一项的位置和要删除的项数,例如,splice(0, 2)会删除数组中的前两项。</p><p>插入:可以向指定位置插入任意数量的项,只需提供两个参数：其实位置,0(要删除的项数)和要插入的项。例如,splice(2, 0, 4, 6)会从当前的位置2开始插入4和6。</p><p>替换:可以向指定位置插入任意数量的项,且同时删除任意数量的项,只需指定3个参数,起始位置,要删除的项数和要插入的任意数量的项,插入的项数不必与删除的项数相等。例如,splice(2, 1, 4, 6)会删除当前数组位置2的项,然后再从位置2开始插入4和6.<br>splice()方法始终都会返回一个数组,该数组中包含从原始数组中删除的项, 如果没有删除任何项,则返回一个空数值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">90</span>, <span class="number">45</span>];</span><br><span class="line"><span class="keyword">var</span> ss = arr.splice(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(ss);</span><br><span class="line"><span class="keyword">var</span> ss1 = arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//原数组已经改变</span></span><br><span class="line"><span class="built_in">console</span>.log(ss1);</span><br><span class="line"><span class="keyword">var</span> count3 = arr.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(count);</span><br></pre></td></tr></table></figure><h2 id="indexOf-和lastIndexOf"><a href="#indexOf-和lastIndexOf" class="headerlink" title="indexOf()和lastIndexOf()"></a>indexOf()和lastIndexOf()</h2><p>indexof():接收两个参数：要查找的项和(可选的)表示查找起点的位置的索引。其中,从数组的开头(位置0)开始向后查找。</p><p>lastIndexOf():接收两个参数：要查找的项和(可选的)表示查找起点位置的索引。其中,从数组的末尾开始向前查找。</p><p>这两个方法都返回要查找的项在数组中的位置,或者在没找到的情况下返回-1,在比较第一个参数与书中的每一项时,会使用全等操作符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">5</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h2><p>forEach(): 对数组进行遍历循环,对数组的每一项进行给定函数。这个方法没有返回值。参数function类型,默认有传参,参数分别为：遍历的数组内容，对应的数组索引，数组本身。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'wa'</span>, <span class="string">'ng'</span>, <span class="string">'li'</span>, <span class="string">'si'</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, li</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(item);</span><br><span class="line"><span class="built_in">console</span>.log(index);</span><br><span class="line"><span class="built_in">console</span>.log(li);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>map():指’映射’,对数组中的每一项运行给定函数,返回每次函数调用的结果组成的数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item * item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br></pre></td></tr></table></figure></p><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><p>fliter():’过滤’功能,数组中的每一项运行给定函数,返回满足过滤条件组成的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x, index</span>) </span>&#123;</span><br><span class="line"><span class="comment">// console.log(x);</span></span><br><span class="line"><span class="comment">// console.log(index);</span></span><br><span class="line"><span class="keyword">return</span> index % <span class="number">3</span> == <span class="number">0</span> || x &gt;= <span class="number">6</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br></pre></td></tr></table></figure><h2 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h2><p>every():判断数组中的每一项都是否满足条件,只有所有满足条件,才会返回true.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br><span class="line"><span class="keyword">var</span> arr3 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br></pre></td></tr></table></figure><h2 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h2><p>some(): 判断数组中是否存在满足条件的项,只要有一项满足条件,就会返回true.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br><span class="line"><span class="keyword">var</span> arr3 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br></pre></td></tr></table></figure><h2 id="reduce-和reduceRight"><a href="#reduce-和reduceRight" class="headerlink" title="reduce()和reduceRight()"></a>reduce()和reduceRight()</h2><p>这两个方法都会实现迭代数组的所有项,然后构建一个最终返回的值。reduce()方法从数组的第一项开始,逐个遍历到最后。而reduceRight()则从数组的最后一项开始,向前遍历到第一项。<br>这两个方法都接收两个参数:一个在每一项上调用的函数和(可选的)作为归并基础的初始值。</p><p>传给reduce()和reduceRight()的函数接收4个参数:前一个值,当前值,项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项,因此第一个参数是数组的第一项,第二个参数就是数组的第一项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">p, c, i, a</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'prev'</span>, p);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'c'</span>, c);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'i'</span>, i);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>, a);    </span><br><span class="line"><span class="keyword">return</span> p + c;</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展运算符(spread)是三个点(…).它好比reset参数的逆运算,将一个数组转为用逗号分隔的参数序列。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>);</span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br></pre></td></tr></table></figure></p><p>该运算符用于函数的调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  array.push(...items);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>上面代码中,array.push(…items)和add(…numbers)这两行,都是函数的调用,它们都使用了扩展运算符,该运算将一个数组,变为参数序列。</p><p>扩展运算符与正常的函数参数可以结合使用,非常灵活。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">z, x, c, v</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">f(<span class="number">-1</span>, ...args, <span class="number">2</span> ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure></p><p>扩展运算符后面还可以放置表达式。</p><p><code>const arr = [  ...(x &gt; 0 ? [&#39;a&#39;] : []),  &#39;b&#39;,    ];</code></p><p>如果扩展运算符后面是一个空数组,则不产生任何效果。</p><p><code>[...[], 1]</code></p><h2 id="替代数组的apply方法"><a href="#替代数组的apply方法" class="headerlink" title="替代数组的apply方法"></a>替代数组的apply方法</h2><p>由于扩展运算符可以展开数组,所以不再需要apply方法,将数组转为函数的参数了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ES5的写法</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"><span class="comment">//  ES6的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure></p><p>下面是扩展运算符取代apply方法的一个实例的例子,应用Math.max方法,简化求出一个数组最大元素的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  ES5的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure><p>上面的代码中,由于javascript不提供数组最大元素的函数,所以只能套用Math.max函数,将数组转为一个参数序列,然后求最大值。有了扩展运算符以后,就可以直接用Math.max了。</p><p>另一个例子是通用push函数,将一个数组添加到另一个数组的尾部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">Array</span>.protype.push.apply(arr1, arr2);</span><br><span class="line"><span class="comment">//  ES6的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure><p>上面代码的ES5写法中,push方法的参数不能是数组,所以只好通过apply方法变通使用push方法。</p><p>有了扩展运算符,就可以直接将数组传入push方法。</p><p><code>new (Date.bind.apply(Date, [null, 2015, 1, 1]));</code></p><p><code>new Date(...[2015, 1, 1]);</code></p><h2 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h2><h3 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h3><p>扩展运算符提供了数组合并的新写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  [1, 2].concat(more)</span></span><br><span class="line"><span class="comment">//  [1, 2, ...more]</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">'a'</span>, ,<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 =  [<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"><span class="comment">//  ES5的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line"><span class="comment">//  ['a', 'b', 'c', 'd', 'e']</span></span><br><span class="line"><span class="comment">//  ES6的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure></p><h3 id="与结构赋值结合"><a href="#与结构赋值结合" class="headerlink" title="与结构赋值结合"></a>与结构赋值结合</h3><p>扩展运算符可以解构赋值结合起来,用于生成数组<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">a = list[<span class="number">0</span>], rest = list.slice(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//  ES6</span></span><br><span class="line">[a, ...rest] = list</span><br></pre></td></tr></table></figure></p><p>下面是另一些例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first   <span class="comment">//  1</span></span><br><span class="line">rest    <span class="comment">//  [2, 3, 4, 5]</span></span><br><span class="line"><span class="keyword">const</span>   [first, ...rest] = [];</span><br><span class="line">first   <span class="comment">//  undefined</span></span><br><span class="line">rest    <span class="comment">//  []</span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">'foo'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first);</span><br><span class="line"><span class="built_in">console</span>.log(rest);</span><br></pre></td></tr></table></figure><p>如果扩展运算符用于数组赋值,只能放在参数的最后一位,否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">//  报错</span></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> [first, last,  ...middle] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first);</span><br><span class="line"><span class="built_in">console</span>.log(last);</span><br><span class="line"><span class="built_in">console</span>.log(middle);</span><br><span class="line"><span class="comment">//  不抱错</span></span><br></pre></td></tr></table></figure><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>javascript的函数只能返回一个值,如果需要返回多个值,只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法.</p><p> <code>var dateFields = readDateFields(database);</code><br>  <code>var d = new Date(...dateFields);</code></p><p> 上面代码从数据库取出一行数据,通过扩展运算符,直接将其传入构造函数的Date.</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p> 扩展运算符还可以将字符串转为真正的数组<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">console</span>.log([...<span class="string">'hello'</span>]);</span><br><span class="line"> <span class="comment">// [ "h", "e", "l", "l", "o" ]</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"> 上面的写法,有一个重要的好处,那就是能够正确识别32位的Unicode字符。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> `</span><span class="string">``</span>js</span><br><span class="line"> <span class="string">'x\uD83D\uDE80y'</span>.length <span class="comment">// 4</span></span><br><span class="line">[...<span class="string">'x\uD83D\uDE80y'</span>].length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>上面代码的第一种写法，JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...str].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>length(&#39;x\uD83D\uDE80y&#39;) // 3</code></p><p>凡是涉及到操作32位 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'x\uD83D\uDE80y'</span>;</span><br><span class="line"></span><br><span class="line">str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line"><span class="comment">// 'y\uDE80\uD83Dx'</span></span><br><span class="line"></span><br><span class="line">[...str].reverse().join(<span class="string">''</span>)</span><br><span class="line"><span class="comment">// 'y\uD83D\uDE80x'</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。</p><h3 id="实现了-Iterator-接口的对象"><a href="#实现了-Iterator-接口的对象" class="headerlink" title="实现了 Iterator 接口的对象"></a>实现了 Iterator 接口的对象</h3><p>任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p><p><code>var nodeList = document.querySelectorAll(&#39;div&#39;);</code></p><p><code>var array = [...nodeList];</code></p><p>上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。</p><p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// TypeError: Cannot spread non-iterable object.</span></span><br><span class="line"><span class="keyword">let</span> arr = [...arrayLike];</span><br></pre></td></tr></table></figure><p>上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。</p><h3 id="Map-和-Set-结构，Generator-函数"><a href="#Map-和-Set-结构，Generator-函数" class="headerlink" title="Map 和 Set 结构，Generator 函数"></a>Map 和 Set 结构，Generator 函数</h3><p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line">[...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p><p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [...obj]; <span class="comment">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p><p>下面是一个类似数组的对象,Array.from将他转为真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> arrays = &#123;</span><br><span class="line">  <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  ES5</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrays);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">//  ES6</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrays);</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br></pre></td></tr></table></figure><p>实际应用中,常见的类似数组的对象是DOM操作返回的NodeList集合,以及函数内部的arguments对象。</p><p>Array.from 都可以将他们转为真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(ps).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中,querySelectorAll方法返回的是一个类似数组的对象,可以将这个对象转为真正的数组,在使用forEach方法。</p><p>只要是部署了Iterator接口的数据结构,Array.from都能将其转为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="string">'hello'</span>));</span><br><span class="line"><span class="comment">//  ["h", "e", "l", "l", "o"]</span></span><br><span class="line"><span class="keyword">let</span> nameSet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(nameSet));</span><br><span class="line"><span class="comment">// (2) ["a", "b"]</span></span><br></pre></td></tr></table></figure><p>上面代码中,字符串和Set结构都具有Iterator接口,因此可以被Array.from转为真正的数组。</p><p>如果参数是一个真正的数组,Array.from会返回一个一模一样的新数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line">值的提醒的是,扩展运算符(...)也可以将某些数据结构转为数组。</span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [...arguments];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br></pre></td></tr></table></figure><p>扩展运算符背后调用的是遍历器接口(Symbol.iterator),如果一个对象没有部署这个接口,就无法转换。Array.from方法还可以支持数组的对象。所谓类似数组的对象,本质特征只有一点,即必须有length属性。因此,任何length属性的对象,都可以通过Array.from方法转为数组,而此时扩展运算符就无法转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// [ undefined, undefined, undefined ]</span></span><br></pre></td></tr></table></figure><p>上面的代码中,Array.from返回了一个具有三个成员的数组,每个位置的值都是undefind。扩展运算符转换不了这个对象。</p><p>对于还没有部署该方法的浏览器,可以用Array.prototype.slice方法替代。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toArray = <span class="function">(<span class="params">(</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.from ? <span class="built_in">Array</span>.from : <span class="function"><span class="params">obj</span> =&gt;</span> [].slice.call(obj)</span><br><span class="line">)();</span><br></pre></td></tr></table></figure><p>Array.from 还可以接受第二个参数,作用类似与数组的map方法,用来对每个元素进行处理,将处理后的值放入返回的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, x =&gt; x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x))</span><br></pre></td></tr></table></figure><p>下面的例子是取出一组Dom节点的文本内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> spans = <span class="built_in">document</span>.querySelectorAll(<span class="string">'span.name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map()</span></span><br><span class="line"><span class="keyword">let</span> names1 = <span class="built_in">Array</span>.prototype.map.call(spans, s =&gt; s.textContent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from()</span></span><br><span class="line"><span class="keyword">let</span> names2 = <span class="built_in">Array</span>.from(spans, s =&gt; s.textContent)</span><br></pre></td></tr></table></figure><p>下面的例子将数组中布尔值为false的成员转为0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from([<span class="number">1</span>, , , <span class="number">2</span>], (n) =&gt; n || <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p> 另一个例子是返回各种数据的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeOf</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, value =&gt; <span class="keyword">typeof</span> value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(typeOf(<span class="literal">null</span>, [], <span class="literal">NaN</span>))</span><br><span class="line"><span class="comment">//  ["object", "object", "number"]</span></span><br></pre></td></tr></table></figure><p>如果map函数里面用到了this关键字,还可以传入Array.from的第三个参数,用来绑定this.</p><p>Array.from()可以将各种值转为真正的数组,并且还提供map功能。这实际上意味着,只要有一个原始的数据结构,你就可以先对它的值进行处理,然后专程规范的数组结构,进而就可以使用数量众多的数组方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">2</span>&#125;, () =&gt; <span class="string">'jack'</span>))</span><br><span class="line"><span class="comment">// ['jack', 'jack']</span></span><br></pre></td></tr></table></figure><p>上面的代码中,Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法非常灵活。</p><p>Array.from()的另一个应用是,将字符串转为数组,然后返回字符串的长度。因为它能正确处理各种Unicode字符,可以避免Javascript将大于\uFFFF的Unicode字符,算做两个字符的bug.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSymbols</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(string).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p>Array.of方法用于将一组值,转换为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>).length);</span><br></pre></td></tr></table></figure><p>这个方法的目的,是弥补数组构造函数的Array()的不足.因为参数个数的不同,会导致Array()行为差异。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><p>上面的代码中,Array方法没有参数,一个参数,三个参数时,返回的结果都不一样。只有当参数不小于2个时,Array()才会返回由参数组成的新数组,参数个数只有一个时,实际上是指定数组的长度。</p><p>Array.of基本上可以替代Array()或new Array(),并且不存在由于参数不同而导致的重载.它的行为非常统一。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="literal">undefined</span>) <span class="comment">// [undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>Array.of总是返回参数组成的数组。如果没有参数,就返回一个空数组。</p><p>Array.of方法可以用下面的代码模拟实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组实例的-copyWithin"><a href="#数组实例的-copyWithin" class="headerlink" title="数组实例的 copyWithin()"></a>数组实例的 copyWithin()</h3><p>数组实例的copyWithin方法,在当前数组内部,将指定位置的成员复制到其他位置(会覆盖原有成员),然后返回当前数组。也就是说,使用这个方法,会修改当前数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="keyword">this</span>.length)</span><br><span class="line"> 它接受三个参数。</span><br><span class="line">  - target(必需): 从该位置开始替换数据。</span><br><span class="line">  - start(可选): 从该位置开始读取数据,默认是<span class="number">0.</span>如果为负值,表示倒数。</span><br><span class="line">  - end(可选):到该位置前停止读取数据,默认等于数组长度,如果为负值,表示倒数。 </span><br><span class="line">这三个参数都应该是数值,如果不是,会自动转换为数值。  </span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].copyWithin(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">//  [2, 3, 3]</span></span><br></pre></td></tr></table></figure></p><p>上面的代码表示将从3号位直到数组结束的成员(4和5),复制到从0号位开始的位置,结果覆盖了原来了1和2.</p><p>下面是更多的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].copyWithin(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment">//  [2, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -2相当于3号位，-1相当于4号位</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-1</span>));</span><br><span class="line">[<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有理解如下:</span></span><br><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[].copyWithin.call(&#123;<span class="attr">length</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// &#123;0: 1, 3: 1, length: 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将2号位到数组结束，复制到0号位</span></span><br><span class="line"><span class="keyword">var</span> i32a = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">i32a.copyWithin(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// Int32Array [3, 4, 5, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于没有部署 TypedArray 的 copyWithin 方法的平台</span></span><br><span class="line"><span class="comment">// 需要采用下面的写法</span></span><br><span class="line">[].copyWithin.call(<span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// Int32Array [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h3 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h3><p>数组实例的find方法,用于找出第一个符合条件的数组成员.它的参数是一个回调函数,所有的数组成员依次执行该回调函数,直到找出第一个返回值为true的成员,然后返回该成员。如果没有符合条件,则返回undefined.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ss = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ss);</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure><p>上面代码找出数组中第一个小于0的成员。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">//  9</span></span><br></pre></td></tr></table></figure><p>上面代码中,find方法的回调函数可以接受三个参数,以此为当前的值,当前的位置和原数组。</p><p>数组实例的findIndex方法的用法与find方法类似,返回第一个符合条件的数组成员的位置,如果所有成员都不符合条件,则返回-1.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这两个方法都可以接受第二个参数,用来绑定回调函数的this对象<br>另外,这两个方法都可以发现NaN,弥补了数组的IndexOf方法的不足。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>上面的代码中,indexOf方法无法识别数组的NaN成员,但是findIndex方法可以借助Object.is方法做到。</p><h3 id="数组实例的fill"><a href="#数组实例的fill" class="headerlink" title="数组实例的fill()"></a>数组实例的fill()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">7</span>));</span><br><span class="line"><span class="comment">//  [7, 7, 7]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>));</span><br><span class="line"><span class="comment">//  [7, 7, 7]</span></span><br></pre></td></tr></table></figure><p>上面代码表明,fill方法用于空数组的初始化非常方便.数组中已有的元素,会被全部抹去。</p><p>fill方法还可以接受第二个参数和第三个参数,用于指定填充起始位置和结束位置.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">//  ["a", 7, "c"]</span></span><br></pre></td></tr></table></figure><p>上面代码表示,fill方法从1号位开始,向原数组填充7,到2号位之前结束。</p><h3 id="数组实例的entries-keys-和values"><a href="#数组实例的entries-keys-和values" class="headerlink" title="数组实例的entries(),keys()和values()"></a>数组实例的entries(),keys()和values()</h3><p>ES6提供了三个新的方法–entries(),keys()和values()–用于遍历数组.它们都返回一个遍历器对象(详见《Iterator》一章),可以用for…of循环进行遍历,唯一的区别是keys()是对键名的遍历,entries()是对键值对的遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  ["a","b"].values(...) is not iterable</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  0 "a"</span></span><br><span class="line"><span class="comment">//  1 "b"</span></span><br></pre></td></tr></table></figure><p>如果不使用for…of循环,可以手动调用循环遍历器对象的next方法,进行遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value);</span><br><span class="line"><span class="comment">//  [0, "a"]</span></span><br><span class="line"><span class="comment">//  [1, "b"]</span></span><br><span class="line"><span class="comment">//  [2, "c"]</span></span><br></pre></td></tr></table></figure><h3 id="数组实例的includes"><a href="#数组实例的includes" class="headerlink" title="数组实例的includes()"></a>数组实例的includes()</h3><p>Array.prototype.includes方法返回一个布尔值,表示某个数组是否包含给定的值,与字符串的includes方法类似。ES2016引入了该方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)); </span><br><span class="line"><span class="comment">//  true</span></span><br><span class="line"><span class="comment">//  false</span></span><br><span class="line"><span class="comment">//  true</span></span><br></pre></td></tr></table></figure></p><p>该方法的第二个参数的表搜索的起始位置,默认为0。如果第二个参数为负数,则表示倒数的位置。如果这时它大于数组的长度(比如第二个参数为-4,但数组长度为3)则会重置它从0开始。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">-1</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>没有该方法之前,我们通常使用数组的indexOf方法,检查是否包含某个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) !== <span class="number">-1</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indexOf方法有两个缺点,一是不够语义化,它的含义是找到参数值的第一个出现位置,所以要去比较是否不等于-1,表达起来不够直观。二是,它内部使用严格相等运算符(===)进行判断,这会导致NaN的误判。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].index(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">//  -1</span></span><br></pre></td></tr></table></figure><p>includes使用的是不一样的判断算法,就没有这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">//  true</span></span><br></pre></td></tr></table></figure><p>下面代码用来检查当前环境是否支持该方法,如果不支持,部署一个简易的替代版本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> = contains = <span class="function">(<span class="params">(</span>) =&gt;</span> </span><br><span class="line">  <span class="built_in">Array</span>.prototype.includes ? <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.includes(value) : <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.some(<span class="function"><span class="params">el</span> =&gt;</span> el ===value))();</span><br><span class="line">  contains([<span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="string">'baz'</span>);</span><br><span class="line">  <span class="comment">//  false</span></span><br></pre></td></tr></table></figure><p>另外,Map和Set数据结构有一个has方法,需要注意includes区分。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="built_in">Map</span>结构的has方法,用来查找键名的,比如<span class="built_in">Map</span>.prototype.has(key)</span><br><span class="line">webkMap.prototype.has(key),<span class="built_in">Reflect</span>.has(target, prototypeKey).</span><br><span class="line">-<span class="built_in">Set</span>结构的has方法,用来查找值的,比如<span class="built_in">Set</span>.prototype.has(value),</span><br><span class="line"><span class="built_in">WeakSet</span>.prototype.has(value).</span><br></pre></td></tr></table></figure></p><h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><p>数组的空位指,数组的某一位置没有任何值。比如,Array构造函数返回的数组都是空位。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>(<span class="number">3</span>))</span><br><span class="line"><span class="comment">//  [empty × 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中,Array(3)返回一个具有3个空位的数组。<br>注意,空位不是undefined,一个位置等于undefined,依然是有值的。空位是没有任何值,in运算符可以说明这一点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>]) <span class="comment">//  true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> <span class="keyword">in</span> [, , ,]) <span class="comment">//  false</span></span><br></pre></td></tr></table></figure><p>上面代码说明,第一个数组的0号位置是有值的,第二个数组的0号位置。<br>ES5对空位的处理,已经很不一致,大多数情况下会忽略空位。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- forEach(), filter(), every()和some()都会跳过空位。</span><br><span class="line">- map()会跳过空位,但会保留这个值</span><br><span class="line">- join()和toString()会将空位视为<span class="literal">undefined</span>,而<span class="literal">undefined</span>和<span class="literal">null</span>会被处理成空字符串。</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  forEach方法</span></span><br><span class="line">[, <span class="string">'a'</span>].forEach(<span class="function">(<span class="params">x, i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//  1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//  filter方法</span></span><br><span class="line"> <span class="built_in">console</span>.log([<span class="string">'a'</span>, , <span class="string">'b'</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">//   ["a", "b"]</span></span><br><span class="line"><span class="comment">//  every方法</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="string">'a'</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x === <span class="string">'a'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="comment">//  some方法</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="string">'a'</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x!== <span class="string">'a'</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="comment">//  map方法</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="string">'a'</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>)) <span class="comment">// [empty × 1, 1]</span></span><br><span class="line"><span class="comment">//  join方法</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="string">'a'</span>, <span class="literal">undefined</span>, <span class="literal">null</span>].join(<span class="string">'#'</span>)) <span class="comment">//  #a##</span></span><br><span class="line"><span class="comment">//  toString方法</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="string">'a'</span>, <span class="literal">undefined</span>, <span class="literal">null</span>].toString()) <span class="comment">//  ,a,,</span></span><br></pre></td></tr></table></figure><p>ES6则是明确将空位转为undefined.<br>Array.from方法会将数组的空位,转为undefined,也就是说,这个方法不会忽略空位。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from([<span class="string">'a'</span>, , <span class="string">'b'</span>]))</span><br><span class="line"><span class="comment">// ["a", undefined, "b"]</span></span><br></pre></td></tr></table></figure><p>扩展运算符(…[‘a’ , , ‘b’])也会把空位转为undefined.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([...[<span class="string">'a'</span>, , <span class="string">'b'</span>]]) <span class="comment">// ["a", undefined, "b"]</span></span><br></pre></td></tr></table></figure><p>copyWithin()会连空位一起拷贝。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([, <span class="string">'a'</span>, <span class="string">'b'</span>, ,].copyWithin(<span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment">//  [empty × 1, "a", empty × 1, "a"]</span></span><br></pre></td></tr></table></figure><p>fill()会将空位视为正常的数组位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">'a'</span>))</span><br></pre></td></tr></table></figure><p>for…of循环也会遍历空位。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [, ,];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//  undefined*2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中,数组arr有两个空位,for…of并没有忽略他们。如果改成map方法遍历,空位是会跳过。<br>entries(),keys(),values(),find()和findIndex()会将空位处理成undefined.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  entries()</span></span><br><span class="line"><span class="built_in">console</span>.log([...[, <span class="string">'a'</span>].entries()]) <span class="comment">//  [0, undefined] [1, "a"]</span></span><br><span class="line"><span class="comment">//  keys()</span></span><br><span class="line"><span class="built_in">console</span>.log([...[, <span class="string">'a'</span>].keys()])  <span class="comment">//  [0, 1]</span></span><br><span class="line"><span class="comment">//  values()</span></span><br><span class="line"><span class="built_in">console</span>.log([...[,<span class="string">'a'</span>].values()] ) <span class="comment">// [(intermediate value),"a"].values(...) is not iterable</span></span><br><span class="line"><span class="comment">//  find()</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="string">'a'</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>)) <span class="comment">//  undefined</span></span><br><span class="line"><span class="comment">//  findIndex()</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="string">'a'</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>)) <span class="comment">//  0</span></span><br></pre></td></tr></table></figure></p><p>由于空位的处理规则非常不统一,所以建议避免出现空位。</p><p>纯手打,没有任何机打痕迹。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;join-ES5&quot;&gt;&lt;a href=&quot;#join-ES5&quot; class=&quot;headerlink&quot; title=&quot;join() ES5&quot;&gt;&lt;/a&gt;join() ES5&lt;/h2&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://wangdabao.js.org/tags/javascript/"/>
    
      <category term="Array方法" scheme="https://wangdabao.js.org/tags/Array%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>&#39;面试题目&#39;</title>
    <link href="https://wangdabao.js.org/2017/08/31/%E9%9D%A2%E8%AF%95/"/>
    <id>https://wangdabao.js.org/2017/08/31/面试/</id>
    <published>2017-08-30T16:00:00.000Z</published>
    <updated>2020-07-05T11:49:17.878Z</updated>
    
    <content type="html"><![CDATA[<p>2017年08月31日又开始上班了,我总结下我面试的一些题目,当然有些我没有回答上来。<br>面试的第一天天气很不好,下着大雨,今天要面试三家公司,公司都相距很远,面试的第一家是做管理系统的后台是用php的,到了以后填写了相关信息,面试岗位,等等。给了一份面试题,上面就三个大题,第一道题目是关于迭代。<br><a id="more"></a></p><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>用迭代实现1+2+3+4+5+…+n求值<br>写的时候就忘了迭代与循环的什么关系这道题没有写出来<br>回去以后就查了查迭代与循环的关系<br>迭代是循环的一种。</p><p><pre><br>  var n = 100;<br>  var s = 0;<br>  for (var i = 1; i &lt;= n; i++ ) {<br>    s += i;<br>    console.log(s)<br>  }<br></pre></p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>第二道题是类似杨辉三角形<br>也没有做出来,具体题目我不大记得了,等我回想然后再去上传题目</p><p>##题目三<br>第三道题目类似有个字符串把他进行倒叙输出再把<br>首字母转换为大写。</p><p><pre><br>var reverse = function (str) {<br>  return str.split(‘ ‘).reverse().join(‘ ‘);<br>}<br>function titleCase(str) {<br>  str = str.toLowerCase().split(‘ ‘);<br>  for (var i in str) {<br>     str[i] = str[i].replace(str[i].charAt(0), str[i].charAt(0).toUpperCase());<br>    };<br>return str.join(‘ ‘);<br>}<br>console.log(titleCase(reverse(‘this is apple’))); //“Hello World” 著作权归作者所有。<br></pre><br>三道题一道题目也没有做出来,内心很难受,就意识到基础知识的薄弱,我也希望有同学看到我的面试经历,自己会去思考自己哪方面的知识稍微薄弱,可以去加深下。</p><p>这是第一家面试公司,结果失败,很糟糕接下来的面试说实话都不想去了,但是已经约了人家了就硬着头皮去了。<br>——————————————第一家结束—————————————-<br>第二家开始,第二家做的是一些汽车的网站。<br>第二家面试的题目</p><h2 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h2><p>面试的技术跟我说了这样一个问题,比如说现在有这样一个问题项目已经完成并打包上线,但是出现个问题比如说有个汽车的价格写的不对,运营方面就直接修改了线上的价格,但是这样就出现了一个问题,如果运营直接把线上的修改了就会和本地的产生了差异,怎么才能不出现这个问题(大概是这个意思),那我就说,先给用户去看,如果没有问题了,再去把本地的去做更改,再去打包,部署到线上。然后他就点点头。(?).</p><h2 id="题目二-1"><a href="#题目二-1" class="headerlink" title="题目二"></a>题目二</h2><p>说说git与svn的区别<br>我没有回答出来,面试官告诉我的是git是分布式的自己可以玩,而svn不能自己玩(大概就是这个意思)<br>回去百度了下<br>答案如下:<br>1.GIT是分布式的，SVN不是：</p><p>这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。如果你能理解这个概念，那么你就已经上手一半了。需要做一点声明，GIT并不是目前第一个或唯一的分布式版本控制系统。还有一些系统，例如Bitkeeper, Mercurial等，也是运行在分布式模式上的。但GIT在这方面做的更好，而且有更多强大的功能特征。</p><p>GIT跟SVN一样有自己的集中式版本库或服务器。但，GIT更倾向于被使用于分布式模式，也就是每个开发人员从中心版本库/服务器上chect out代码后会在自己的机器上克隆一个自己的版本库。可以这样说，如果你被困在一个不能连接网络的地方时，就像在飞机上，地下室，电梯里等，你仍然能够提交文件，查看历史版本记录，创建项目分支，等。对一些人来说，这好像没多大用处，但当你突然遇到没有网络的环境时，这个将解决你的大麻烦。</p><p>同样，这种分布式的操作模式对于开源软件社区的开发来说也是个巨大的恩赐，你不必再像以前那样做出补丁包，通过email方式发送出去，你只需要创建一个分支，向项目团队发送一个推请求。这能让你的代码保持最新，而且不会在传输过程中丢失。GitHub.com就是一个这样的优秀案例。</p><p>有些谣言传出来说subversion将来的版本也会基于分布式模式。但至少目前还看不出来。</p><p>2.GIT把内容按元数据方式存储，而SVN是按文件：</p><p>所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。如果你把.git目录的体积大小跟.svn比较，你会发现它们差距很大。因为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。</p><p>3.GIT分支和SVN的分支不同：</p><p>分支在SVN中一点不特别，就是版本库中的另外的一个目录。如果你想知道是否合并了一个分支，你需要手工运行像这样的命令svn propget svn:mergeinfo，来确认代码是否被合并。感谢Ben同学指出这个特征。所以，经常会发生有些分支被遗漏的情况。</p><p>然而，处理GIT的分支却是相当的简单和有趣。你可以从同一个工作目录下快速的在几个分支间切换。你很容易发现未被合并的分支，你能简单而快捷的合并这些文件。</p><p>Git logo</p><p>4.GIT没有一个全局的版本号，而SVN有：</p><p>目前为止这是跟SVN相比GIT缺少的最大的一个特征。你也知道，SVN的版本号实际是任何一个相应时间的源代码快照。我认为它是从CVS进化到SVN的最大的一个突破。因为GIT和SVN从概念上就不同，我不知道GIT里是什么特征与之对应。如果你有任何的线索，请在评论里奉献出来与大家共享。</p><p>更新：有些读者指出，我们可以使用GIT的SHA-1来唯一的标识一个代码快照。这个并不能完全的代替SVN里容易阅读的数字版本号。但，用途应该是相同的。</p><p>5.GIT的内容完整性要优于SVN：</p><p>GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p>说说webpack与grunt或gulp的异同<br>同:我回答的是这三个都是打包自动化工具,都是为了提升工作效率.<br>异:我回答的是webpack可以对一些图片或者js css等进行打包压缩,而gulp或grunt不能。<br>grunt与gulp是自动化工具,而webpack是前端模块化工具。</p><p>##题目四<br>说说var和let的区别<br>我回答的是作用域的不一样,在作用域外var可以在作用域内访问到而let不可以,let只能在那里定义在那里访问。<br>使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；<br>使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；<br>使用const声明的是常量，在后面出现的代码中不能再修改该常量的值。</p><h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><p>说一个div元素距离顶部为10像素在其内部也有个div距离上一个div的距离也是10像素,那么内部的div元素距离顶部是多少像素。<br>我回答的是20像素,面试官告诉我是10像素,我问他为什么他说这是一个坑。</p><h2 id="题目五-1"><a href="#题目五-1" class="headerlink" title="题目五"></a>题目五</h2><p>说下vue是不是适合像政府类的网站<br>我回答的是不适合,因为我觉得vue是轻量级的,而政府类的一般都是内容比较多的,特别的臃肿,所以我觉得不太适合。</p><h2 id="题目五-2"><a href="#题目五-2" class="headerlink" title="题目五"></a>题目五</h2><p>用jquery和vue分别实现导航高亮显示<br>jquery就是选择元素当鼠标点击时当前的元素给他添加一个class样式,而他的兄弟节点进行removClass保持正常。<br>vue我回答的不好,或者说不对。就不说了。</p><h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><p>第二家公司大体就是这样,最后跟我说一两天给我消息,我就走了,走的时候忘了拿伞又回去拿伞碰到了他们老板,他们老板让我去他办公司聊聊,聊了聊发现他认识我以前的同事,最后问了我薪资要求.(乌龙)</p><p>—————————————–第二家结束——————————————<br>赶去第三家,第三家比较远,做公交车,坐了一个小时多点,到了地方进行简单的自我介绍.<br>开始面试的不是技术,就稍微问了我基本情况,过了一会让我进行了电话面试。</p><h2 id="题目一-2"><a href="#题目一-2" class="headerlink" title="题目一"></a>题目一</h2><p>说下怎么jquery怎么跨域<br>讲道理之前看了跨域的实现方式有8种,我就回答可能是用的最多的一种jsonp</p><h2 id="题目二-2"><a href="#题目二-2" class="headerlink" title="题目二"></a>题目二</h2><p>vue和jquery的区别<br>我回答的是:我觉得vue他本身是框架,而jquery他是库,框架他制定了一种自己的规则,你想要使用他你就要去按照他的方式去使用,而jquery他是一个库,引入就可以使用,我觉得他们两个不能进行比较。</p><p>过了一会他们老板进来了问了我平常喜欢做什么,我就说喜欢coding(抖个机灵),然后就问了一些个人情况,最后问我,面试几家了,我说好几家了(其实想博一下)然后跟我说来我们公司吧,其他的就不用去了,我说我考虑下,跟我说不用考虑了,我说你们公司现在前端多少人,他说都是新招的,我又问了他们用的什么框架,用的是can我不知道。<br>然后跟我说,他是从阿里出来的,然后又是说了马云爸爸的激励人生的名言。</p><p>回去以后五点左右,开始继续投递,然后约了第二天面试的公司。。。<br>————————————–第三家结束———————————————<br>第二天去了离我住的很近的一个公司,但是要求很多,心理很虚.<br>第一家公司题目</p><h2 id="题目一-3"><a href="#题目一-3" class="headerlink" title="题目一"></a>题目一</h2><p>等我整理下再来补充</p><p>——————————————第四家结束—————————————–<br>第五家<br>简单问了问你用什么编辑器,我说了某某,然后跟我说了公司的基本情况,然后等等,公司是用vue的,然后给他看了看我打包的app但流畅性不好,最后问了问薪资,等等。</p><p>————————————第五家结束———————————————–<br>第六家</p><h2 id="题目一-4"><a href="#题目一-4" class="headerlink" title="题目一"></a>题目一</h2><p>说说怎么让一个函数怎么页面一加载就立即执行,我说了让window.onload等于那个函数,这样页面一加载函数就会立即执行,我问他这样可不可以,他说不行,我又说写个立即执行函数可以吗,他说也不行。</p><h2 id="题目二-3"><a href="#题目二-3" class="headerlink" title="题目二"></a>题目二</h2><p>问了我关于怎么让页面一加载就调用数据,说实话我是不理解的。</p><h2 id="题目三-1"><a href="#题目三-1" class="headerlink" title="题目三"></a>题目三</h2><p>问了html接近满了,说实话很心虚(当时写的有点多,呵呵)。友情提示:关于技能方面不要写那么多,那么满。</p><h2 id="题目五-3"><a href="#题目五-3" class="headerlink" title="题目五"></a>题目五</h2><p>问了我psd图能还原多少,我说我没有办法做到100%还原。。。GG<br>还有问了我看了什么书我说权威指南与你不知道的javascript他说权威指南不好….?(为啥)<br>还有几个但是我给忘了,想起来再补充。<br>人事给我说了薪资,等等一些方面,说给我打电话。</p><p>——————————————-面试结束——————————————<br>最后我去了第三家,因为离我很近, 而且技术方面我觉得可能更合适我。<br>就先这样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年08月31日又开始上班了,我总结下我面试的一些题目,当然有些我没有回答上来。&lt;br&gt;面试的第一天天气很不好,下着大雨,今天要面试三家公司,公司都相距很远,面试的第一家是做管理系统的后台是用php的,到了以后填写了相关信息,面试岗位,等等。给了一份面试题,上面就三个大题,第一道题目是关于迭代。&lt;br&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://wangdabao.js.org/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>&#39;Promise&#39;</title>
    <link href="https://wangdabao.js.org/2017/08/10/promise/"/>
    <id>https://wangdabao.js.org/2017/08/10/promise/</id>
    <published>2017-08-10T02:54:48.000Z</published>
    <updated>2020-07-05T11:49:17.870Z</updated>
    
    <content type="html"><![CDATA[<h2>1.Promise的立即执行性 </h2><br>    <a id="more"></a><br>    var p = new Promise(function(resolve, reject){<br>      console.log(“create a promise”);<br>      resolve(“success”);<br>    });<br><br>    console.log(“after new Promise”);<br><br>    p.then(function(value){<br>      console.log(value);<br>    });<br>控制台输出：<br><br>    “create a promise”<br>    “after new Promise”<br>    “success”<br>Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。<br><h2>2.Promise 三种状态</h2><pre><code>var p1 = new Promise(function(resolve,reject){  resolve(1);});var p2 = new Promise(function(resolve,reject){  setTimeout(function(){    resolve(2);    }, 500);      });var p3 = new Promise(function(resolve,reject){  setTimeout(function(){    reject(3);    }, 500);      });console.log(p1);console.log(p2);console.log(p3);setTimeout(function(){  console.log(p2);}, 1000);setTimeout(function(){  console.log(p3);}, 1000);p1.then(function(value){  console.log(value);});p2.then(function(value){  console.log(value);});p3.catch(function(err){  console.log(err);});</code></pre><p>控制台输出：</p><pre><code>Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 1}Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined}Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined}123Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 2}Promise {[[PromiseStatus]]: &quot;rejected&quot;, [[PromiseValue]]: 3}</code></pre><p>Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。</p><p>p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个setTimeout函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。</p><h2>3.Promise 状态的不可逆性</h2><pre><code>var p1 = new Promise(function(resolve, reject){  resolve(&quot;success1&quot;);  resolve(&quot;success2&quot;);});var p2 = new Promise(function(resolve, reject){  resolve(&quot;success&quot;);  reject(&quot;reject&quot;);});p1.then(function(value){  console.log(value);});p2.then(function(value){  console.log(value);});</code></pre><p>控制台输出：</p><pre><code>&quot;success1&quot;&quot;success&quot;</code></pre><p>Promise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中resolve(“success2”)并不能将p1的值更改为success2，p2中reject(“reject”)也不能将p2的状态由resolved改变为rejected.</p><h2>4.链式调用</h2><pre><code>var p = new Promise(function(resolve, reject){  resolve(1);});p.then(function(value){               //第一个then  console.log(value);  return value*2;}).then(function(value){              //第二个then  console.log(value);}).then(function(value){              //第三个then  console.log(value);  return Promise.resolve(&apos;resolve&apos;); }).then(function(value){              //第四个then  console.log(value);  return Promise.reject(&apos;reject&apos;);}).then(function(value){              //第五个then  console.log(&apos;resolve: &apos;+ value);}, function(err){  console.log(&apos;reject: &apos; + err);})</code></pre><p>控制台输出：</p><pre><code>12undefined&quot;resolve&quot;&quot;reject: reject&quot;</code></pre><p>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：</p><p>return 一个同步的值 ，或者 undefined（当没有返回一个有效值时，默认返回undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。<br>return 另一个 Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。<br>throw 一个同步异常，then方法将返回一个rejected状态的Promise, 值是该异常。<br>根据以上分析，代码中第一个then会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个then输出的值是2。第二个then中没有返回值，因此将返回默认的undefined，于是在第三个then中输出undefined。第三个then和第四个then中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个then中成功的回调函数和第五个then中失败的回调函数处理。</p><h2>5.Promise then() 回调异步性</h2><pre><code>var p = new Promise(function(resolve, reject){  resolve(&quot;success&quot;);});p.then(function(value){  console.log(value);});console.log(&quot;which one is called first ?&quot;);</code></pre><p>控制台输出：</p><pre><code>&quot;which one is called first ?&quot;&quot;success&quot;</code></pre><p>Promise接收的函数参数是同步执行的，但then方法中的回调函数执行则是异步的，因此，”success”会在后面输出。</p><h2>6.Promise 中的异常</h2><pre><code>var p1 = new Promise( function(resolve,reject){  foo.bar();  resolve( 1 );      });p1.then(  function(value){    console.log(&apos;p1 then value: &apos; + value);  },  function(err){    console.log(&apos;p1 then err: &apos; + err);  }).then(  function(value){    console.log(&apos;p1 then then value: &apos;+value);  },  function(err){    console.log(&apos;p1 then then err: &apos; + err);  });var p2 = new Promise(function(resolve,reject){  resolve( 2 );    });p2.then(  function(value){    console.log(&apos;p2 then value: &apos; + value);    foo.bar();  },   function(err){    console.log(&apos;p2 then err: &apos; + err);  }).then(  function(value){    console.log(&apos;p2 then then value: &apos; + value);  },  function(err){    console.log(&apos;p2 then then err: &apos; + err);    return 1;  }).then(  function(value){    console.log(&apos;p2 then then then value: &apos; + value);  },  function(err){    console.log(&apos;p2 then then then err: &apos; + err);  });</code></pre><p>控制台输出：</p><pre><code>p1 then err: ReferenceError: foo is not definedp2 then value: 2p1 then then value: undefinedp2 then then err: ReferenceError: foo is not definedp2 then then then value: 1</code></pre><p>Promise中的异常由then参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，then返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级then的回调函数是交替执行的 ，这正是由Promise then回调的异步性决定的。</p><h2>7.Promise.resolve()</h2><pre><code>var p1 = Promise.resolve( 1 );var p2 = Promise.resolve( p1 );var p3 = new Promise(function(resolve, reject){  resolve(1);});var p4 = new Promise(function(resolve, reject){  resolve(p1);});console.log(p1 === p2); console.log(p1 === p3);console.log(p1 === p4);console.log(p3 === p4);p4.then(function(value){  console.log(&apos;p4=&apos; + value);});p2.then(function(value){  console.log(&apos;p2=&apos; + value);})p1.then(function(value){  console.log(&apos;p1=&apos; + value);})</code></pre><p>控制台输出：</p><pre><code>truefalsefalsefalsep2=1p1=1p4=1</code></pre><p>Promise.resolve(…)可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的then最先调用，但在控制台上是最后输出结果的呢？因为p4的resolve中接收的参数是一个Promise对象p1，resolve会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。</p><h2>8.resolve vs reject</h2><pre><code>var p1 = new Promise(function(resolve, reject){  resolve(Promise.resolve(&apos;resolve&apos;));});var p2 = new Promise(function(resolve, reject){  resolve(Promise.reject(&apos;reject&apos;));});var p3 = new Promise(function(resolve, reject){  reject(Promise.resolve(&apos;resolve&apos;));});p1.then(  function fulfilled(value){    console.log(&apos;fulfilled: &apos; + value);  },   function rejected(err){    console.log(&apos;rejected: &apos; + err);  });p2.then(  function fulfilled(value){    console.log(&apos;fulfilled: &apos; + value);  },   function rejected(err){    console.log(&apos;rejected: &apos; + err);  });p3.then(  function fulfilled(value){    console.log(&apos;fulfilled: &apos; + value);  },   function rejected(err){    console.log(&apos;rejected: &apos; + err);  });</code></pre><p>控制台输出：</p><pre><code>p3 rejected: [object Promise]p1 fulfilled: resolvep2 rejected: reject</code></pre><p>Promise回调函数中的第一个参数resolve，会对Promise执行”拆箱”动作。即当resolve的参数是一个Promise对象时，resolve会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；p2”拆箱”后，获取到Promise对象的状态是rejected，因此rejected回调被执行。但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。</p><h2><a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="noopener">转载自掘金</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;1.Promise的立即执行性 &lt;/h2&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="web" scheme="https://wangdabao.js.org/tags/web/"/>
    
      <category term="ES6" scheme="https://wangdabao.js.org/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>css3</title>
    <link href="https://wangdabao.js.org/2017/07/22/px%E8%BD%ACrem/"/>
    <id>https://wangdabao.js.org/2017/07/22/px转rem/</id>
    <published>2017-07-22T05:57:48.000Z</published>
    <updated>2020-07-05T11:49:17.871Z</updated>
    
    <content type="html"><![CDATA[<p>Sass基础——Rem与Px的转换<br><a id="more"></a><br>rem是CSS3中新增加的一个单位值，他和em单位一样，都是一个相对单位。不同的是em是相对于元素的父元素的font-size进行计算；rem是相对于根元素html的font-size进行计算。这样一来rem就绕开了复杂的层级关系，实现了类似于em单位的功能。</p><h2>Rem的使用</h2><p>前面说了em是相对于其父元素来设置字体大小的，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小，在我们多次使用时，就会带来无法预知的错误风险。而rem是相对于根元素<html>，这样就意味着，我们只需要在根元素确定一个参考值，这个参考值设置为多少，完全可以根据您自己的需求来定。</html></p><p>假设就使用浏览器默认的字号16px，来看一些px单位与rem之间的转换关系：</p><pre><code>|  px  |     rem       |------------------------|  12  | 12/16 = .75   ||  14  | 14/16 = .875  ||  16  | 16/16 = 1     ||  18  | 18/16 = 1.125 ||  20  | 20/16 = 1.25  ||  24  | 24/16 = 1.5   ||  30  | 30/16 = 1.875 ||  36  | 36/16 = 2.25  ||  42  | 42/16 = 2.625 ||  48  | 48/16 = 3     |-------------------------        </code></pre><p>如果你要设置一个不同的值，那么需要在根元素<html>中定义，为了方便计算，时常将在<html>元素中设置font-size值为62.5%:</html></html></p><pre><code>html {    font-size: 62.5%; /* 10 ÷ 16 × 100% = 62.5% */}</code></pre><p>相当于在<html>中设置font-size为10px，此时，上面示例中所示的值将会改变：</html></p><pre><code>|  px  |     rem        |-------------------------|  12  | 12/10 = 1.2    ||  14  | 14/10 = 1.4    ||  16  | 16/10 = 1.6    ||  18  | 18/10 = 1.8    ||  20  | 20/10 = 2.0    ||  24  | 24/10 = 2.4    ||  30  | 30/10 = 3.0    ||  36  | 36/10 = 3.6    ||  42  | 42/10 = 4.2    ||  48  | 48/10 = 4.8    |-------------------------        </code></pre><p>由于rem是CSS3中的一个属性，很多人首先关注的就是浏览器对他的支持度，我截了一张caniuse对rem属性的兼容表：<br><img src="http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2013/sass/sass-px-rem-1.jpg" alt="CSS"><br>从上图可以清楚的知道，rem在众多浏览器中都已得到很好的支持，如果您的项目不用考虑IE低版本的话，你就可以放心的使用了，如果您的项目在IE低版本中还占有不少的比例，那么你还在担心使用rem不能兼容，而不敢使用。其实是没有必要的，可以针对低版本的IE浏览器做一定的处理：</p><pre><code>html { font-size: 62.5%; } body { font-size: 14px; font-size: 1.4rem; } /* =14px */h1   { font-size: 24px; font-size: 2.4rem; } /* =24px */    </code></pre><p>这样一来解决了IE低版本的不能兼容的问题，但生出另一个不足地方，就是增加了代码量。必竟鱼和熊掌很多时候不能兼得嘛。</p><div><br>如果你想更深入的了解rem如何使用，建议您阅读：<br><br><br> <a href="http://www.w3cplus.com/css3/define-font-size-with-css3-rem" target="_blank" rel="noopener">CSS3的REM设置字体大小</a>——viaw3cplus<br><br> <a href="http://snook.ca/archives/html_and_css/font-size-with-rem" target="_blank" rel="noopener">FONT SIZING WITH REM</a>——viaJonathan Snook<br><br> <a href="http://css-tricks.com/theres-more-to-the-css-rem-unit-than-font-sizing/" target="_blank" rel="noopener">There’s more to the CSS rem unit than font sizing</a>——viacss-tricks<br><br> <a href="http://techtime.getharvest.com/blog/in-defense-of-rem-units" target="_blank" rel="noopener">In Defense Of Rem Units</a>——viaMatthew Lettini<br><br> <a href="http://csswizardry.com/2011/05/font-sizing-with-rem-could-be-avoided/" target="_blank" rel="noopener">Font sizing with rem could be avoided</a>——viaHarry<br><br> <a href="http://ued.taobao.com/blog/2013/05/rem-font-size/" target="_blank" rel="noopener">响应式十日谈第一日：使用 rem 设置文字大小</a>——via一丝<br></div><h2>为什么要使用rem</h2><p>像em单位一样，在Responsive设计中使用rem单位非常有用。虽然他们都是相对单位，但使用rem单位可以避开很多层级的关系。因为em是相对于他的父元素的font-size，而rem是相对于根元素<html>。比如说h1设置了font-size为1rem之后，只要不重置html的font-size大小，无论他的父元素设置多大，对h1都不会有任何的影响。</html></p><h4>Sass中rem的使用</h4><p>在CSS中，实现px和rem转换非常简单，但每次使用都需进行计算。虽然在html中设置font-size:62.5%;会给大家带来便利，但终究有些烦人，也不是长远之计。既然我们学习了Sass，就应该思考如何让Sass来帮助我们做这些计算的工作。接下来介绍如何使用Sass实现px和rem之间的计算。</p><p>rem在@function中的使用</p><p>Sass中也可以像使用em一样，实现px转换为rem。这个过程也同样是通过Sass的@function方法来实现。</p><p>根据rem的使用原理，可以知道px转rem需要在html根元素设置一个font-size值，因为rem是相对于html根元素。在Sass中定义一个px转rem的函数，先要设置一个默认变量：</p><p>$browser-default-font-size: 16px !default;//变量的值可以根据自己需求定义<br>而且需要在html根元素中显示的声明font-size：</p><pre><code>html {    font-size: $browser-default-font-size;}</code></pre><p>然后通过@function来实现px转为rem计算：</p><pre><code>@function pxTorem($px){//$px为需要转换的字号    @return $px / $browser-default-font-size * 1rem;}</code></pre><p>定义好@function之后，实际使用中就简单多了：</p><pre><code>//SCSShtml {    font-size: $browser-default-font-size;}.header {    font-size: pxTorem(12px);}//CSShtml {  font-size: 16px; }.header {  font-size: 0.75rem; }</code></pre><p>不过定义的这个函数pxTorem()虽然实现了px转换成rem的计算，但不能同时服务于多个属性值的计算：</p><pre><code>.header {    font-size: pxTorem(12px);    margin: pxTorem(5px 10px);//同时计算多个值将报错}</code></pre><p>如果这样使用，编译的时候将会报错：</p><pre><code>&gt;&gt;&gt; Change detected to: /Users/airen/Sites/testSass/style.scss      error style.scss (Line 4: Undefined operation: &quot;5px 10px/16px times 1rem&quot;.)这也就是说，如果样式同时需要设置多个属性值的时候，pxTorem()变得就局限性太大，换句话说，这个函数仅适合运用在具有单个属性值的属性上，例如font-size。如果要强行使用，只能同时使用多个pxTorem()：</code></pre><pre>//SCSS.header {    font-size: pxTorem(12px);    margin: pxTorem(5px) pxTorem(10px) pxTorem(15px);    border: pxTorem(1px) solid #f36;}//CSS.header {  font-size: 0.75rem;  margin: 0.3125rem 0.625rem 0.9375rem;  border: 0.0625rem solid #ff3366; }</pre><h2>Sass中mixin实现rem</h2><p>除了使用@function实现px转换成rem之外，还可以使用Sass中的mixin实现px转rem功能。</p><p>font-size是样式中常见的属性之一，我们先来看一个简单mixin，用来实现font-size的px转rem：</p><pre><code>@mixin font-size($target){    font-size: $target;    font-size: ($target / $browser-default-font-size) * 1rem;}</code></pre><p>在实际使用中，可以通过@include调用定义好的@mixin font-size:</p><pre><code>//SCSS.footer {    @include font-size(12px);}//CSS.footer {  font-size: 12px;  font-size: 0.75rem; }</code></pre><p>可实际中，这个mixin太弱小了，根本无法实现我们需要的效果，因为我们很多样式属性中他可不只一个属性。为了实现多个属性能设置多值，就需要对mixin做出功能扩展：</p><pre><code>@mixin remCalc($property, $values...) {  $max: length($values);//返回$values列表的长度值  $pxValues: &apos;&apos;;  $remValues: &apos;&apos;;  @for $i from 1 through $max {    $value: strip-units(nth($values, $i));//返回$values列表中的第$i个值，并将单位值去掉    $browser-default-font-size: strip-units($browser-default-font-size);    $pxValues: #{$pxValues + $value * $browser-default-font-size}px;    @if $i &lt; $max {      $pxValues: #{$pxValues + &quot; &quot;};    }  }   @for $i from 1 through $max {    $value: strip-units(nth($values, $i));    $remValues: #{$remValues + $value}rem;    @if $i &lt; $max {      $remValues: #{$remValues + &quot; &quot;};    }  }   #{$property}: $pxValues;   #{$property}: $remValues; }</code></pre><p>在这个remCalc()中定义了两个参数$property和$values…。其中$property表示的是样式属性，而$values…表示一个或者多个属性值。</p><p>注：在上面定义的remCalc中使用了下自定义的函数strip-units，主要用来去除单位，详细的请参阅Sass基础——PX to EM Mixin和@function一文中的strip-units函数定义方法。</p><p>px转rem的mixin定义完成后，就可以通过@include来引用：</p><pre><code>//SCSS.wrapper {    @include remCalc(width,45);    @include remCalc(margin,1,.5,2,3);}//CSS.wrapper {  width: 720px;  width: 45rem;  margin: 16px 8px 32px 48px;  margin: 1rem 0.5rem 2rem 3rem; }</code></pre><p>在实际使用中取值有一点非常重要在remCalc()取的$values值为rem值。</p><p>总结</p><p>在这篇文章中，简单介绍了在Sass中如何定义@function和@mixin来实现px转换成rem的计算。希望大家能在这篇文章中找到自己需要的灵感。</p><p> <a href="http://www.w3cplus.com/preprocessor/sass-px-to-rem-with-mixin-and-function.html" target="_blank" rel="noopener">转载自© w3cplus.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sass基础——Rem与Px的转换&lt;br&gt;
    
    </summary>
    
    
      <category term="综合" scheme="https://wangdabao.js.org/tags/%E7%BB%BC%E5%90%88/"/>
    
      <category term="css3" scheme="https://wangdabao.js.org/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>music</title>
    <link href="https://wangdabao.js.org/2017/07/18/%E8%AE%A4%E9%94%99/"/>
    <id>https://wangdabao.js.org/2017/07/18/认错/</id>
    <published>2017-07-18T10:30:48.000Z</published>
    <updated>2020-07-05T11:49:17.877Z</updated>
    
    <content type="html"><![CDATA[<pre><code>认错-林志炫</code></pre><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27537217&auto=1&height=66"></iframe><br><a id="more"></a></p><pre><code>认错-林志炫I Don&apos;t Believe IT 是我放弃了你只为了一个没有理由的决定以为这次我可以 承受你离我而去故意让你伤心 却刺痛自己一个人常在傍晚七点的台北CITY 等着心痛就像黑夜一样来临I Hate Myself 又整夜追逐梦中的你　而明天只剩哭泣的心怎么才能让我告诉你　我不愿意　教彼此都在孤独里忍住伤心我又怎么告诉你　我还爱你　是我自己错误的决定我要告诉你　我不愿意教彼此都在孤独里忍住伤心我又怎么告诉你　我还爱你　是我自己错误的决定             </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;认错-林志炫
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=27537217&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="综合" scheme="https://wangdabao.js.org/tags/%E7%BB%BC%E5%90%88/"/>
    
      <category term="music" scheme="https://wangdabao.js.org/tags/music/"/>
    
  </entry>
  
  <entry>
    <title>windows-ubuntu</title>
    <link href="https://wangdabao.js.org/2017/06/29/windows-ubuntu/"/>
    <id>https://wangdabao.js.org/2017/06/29/windows-ubuntu/</id>
    <published>2017-06-29T05:30:48.000Z</published>
    <updated>2020-07-05T11:49:17.873Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间从windows服务器换到了ubuntu服务器,讲道理ubuntu是真的比<br>windows好用,当然linux的也是类似的,没用过就不多BB,我强烈推荐一波,如果说你正好要买服务器,考虑下linux的系统的服务器,当然你说不会什么shell命令什么都没有关系,跟着视频撸一遍,这样下来新鲜感十足,如有神助。<br>可能我bb一通,还是觉得没有实例来的痛快,我说下我用的ubuntu的部署的node项目。之前我用的也是windows的服务器,windows服务器本身是没有什么问题的。(只是对我而言)在windows上我采用的是本地更改项目代码然后通过ftp或者qq邮箱(呵呵)但是这两种方式,无论是哪一种都要去远程连接服务器,然后去重启服务,我觉得很麻烦,登来登去的很烦,很偶然看到ubuntu可以通过pm2部署,这样我给大家看下我pm2的代码<br><a id="more"></a></p><pre>ecosystem.jsons  {    "apps":[{          "name":"xiaomo",            "script":"app.js",          "env":{            "COMMON_VARIABLE":"true"        },        "env_production":{            "NODE_ENV":"production"        }    }    ],    "deploy":{        "production":{            "user":"wangdabao",            "host":["47.94.153.153"],            "ref":"origin/master",            "repo":"git@git.oschina.net:wangdabaoqq/node-millet.git",            "path":"/www/xiao/production",            "ssh_options":"StrictHostKeyChecking=no",            "post-deploy":"npm install --registry=https://registry.npm.taobao.org && pm2 startOrRestart ecosystem.json --env production",            "env":{                "NODE_ENV":"production"            }        }    }}</pre>   <p>当然我也是按照pm2官网的进行的编写,具体里面代表的意思可以看下pm2官网的部署<a href="http://pm2.keymetrics.io/docs/usage/deployment/" target="_blank" rel="noopener">http://pm2.keymetrics.io/docs/usage/deployment/</a>我也贴下链接,如果有兴趣的可以看下,当然这个必须要配合的是github或者是码云,coding等等我在这里也不说了,因为可以从上面的代码中看到我们的代码是从码云拉取的所以,到这里又有一个问题了私钥或者公钥,当然关于私钥和公钥是和git有关系的,如果你没有配置或者生成可以百度下非常简单,生成完以后要把私钥放到git或者码云的ssh上面,这样写完以后还要在服务器上添加私钥和公钥,一上弄完以后,我们就可以通过命令</p><p><pre><br>git add .<br>git commit -m ‘update’<br>git push origin master<br>由于你是第一次使用所有要先<br>git remote add origin +上你的ssh或者https的git项目地址<br>第一次进行上传<br>pm2 deploy ecosystem.json production setup<br>以后每次都可以直接<br>pm2 deploy ecosystem.json production setup<br></pre></p><p><pre><br><img src="https://qn.tyty.me/Screenshot.png"><br></pre><br>最后我推荐个慕课网上的一个视频叫</p><h3><a href="http://coding.imooc.com/class/95.html" target="_blank" rel="noopener">Node.js项目的线上服务器部署与发布</a></h3><i style="font-weight:bold">看完以后你会有一个全新的了解与认识。</i><p></p><p><b style="font-size:14px; color:red;">↓↓<br>打下广告各位看官老爷们动动小手指给个start,我会继续努力让你们不喜欢的,先谢谢爸爸们,告辞.</b></p><h1><a href="https://github.com/wangdabaoqq/node-millet" target="_blank" rel="noopener">传送门</a></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间从windows服务器换到了ubuntu服务器,讲道理ubuntu是真的比&lt;br&gt;windows好用,当然linux的也是类似的,没用过就不多BB,我强烈推荐一波,如果说你正好要买服务器,考虑下linux的系统的服务器,当然你说不会什么shell命令什么都没有关系,跟着视频撸一遍,这样下来新鲜感十足,如有神助。&lt;br&gt;可能我bb一通,还是觉得没有实例来的痛快,我说下我用的ubuntu的部署的node项目。之前我用的也是windows的服务器,windows服务器本身是没有什么问题的。(只是对我而言)在windows上我采用的是本地更改项目代码然后通过ftp或者qq邮箱(呵呵)但是这两种方式,无论是哪一种都要去远程连接服务器,然后去重启服务,我觉得很麻烦,登来登去的很烦,很偶然看到ubuntu可以通过pm2部署,这样我给大家看下我pm2的代码&lt;br&gt;
    
    </summary>
    
    
      <category term="综合" scheme="https://wangdabao.js.org/tags/%E7%BB%BC%E5%90%88/"/>
    
      <category term="服务器" scheme="https://wangdabao.js.org/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>技术贴</title>
    <link href="https://wangdabao.js.org/2017/04/15/%E6%8A%80%E6%9C%AF%E8%B4%B4/"/>
    <id>https://wangdabao.js.org/2017/04/15/技术贴/</id>
    <published>2017-04-15T05:30:48.000Z</published>
    <updated>2020-07-05T11:49:17.876Z</updated>
    
    <content type="html"><![CDATA[<p>###五. 资源教程:</p><p>综合类<br><a id="more"></a><br>前端知识体系<br>前端知识结构<br>Web前端开发大系概览<br>Web前端开发大系概览-中文版<br>Web Front-end Stack v2.2<br>En类资源汇总<br>免费的编程中文书籍索引<br>前端书籍<br>前端免费书籍大全<br>免费的编程中文书籍索引<br>智能社 - 精通JavaScript开发<br>重新介绍 JavaScript（JS 教程）<br>麻省理工学院公开课：计算机科学及编程导论<br>JavaScript中的this陷阱的最全收集–没有之一<br>JS函数式编程指南<br>JavaScript Promise迷你书（中文版）<br>腾讯移动Web前端知识库<br>Front-End-Develop-Guide 前端开发指南<br>前端开发笔记本<br>大前端工具集 - 聂微东<br>前端开发者手册<br>前端开发者手册<br>JavaScript 资源大全中文版<br>伯乐在线 - 资源大全<br>伯乐在线 - 前端资源库<br>入门类</p><p>前端入门教程<br>瘳雪峰的Javascript教程<br>jQuery基础教程<br>前端工程师必备的PS技能——切图篇<br>结合个人经历总结的前端入门方法<br>效果类</p><p>弹出层<br>焦点图轮播特效<br>工具类</p><p>css sprite 雪碧图制作<br>版本控制入门 – 搬进 Github<br>Grunt-beginner前端自动化工具<br>慕课专题</p><p>张鑫旭 - 慕课系列<br>lyn - 慕课系列<br>艾伦 - 慕课系列<br>碧仔 - Hello，移动WEB<br>haorooms - js/jquery宽高介绍<br>周刊类</p><p>百度FEX技术周刊<br>平安科技移动开发二队技术周报<br>360奇舞周刊</p><p>###六. API:</p><p>####1. 总目录</p><p>开发中心</p><p>mozilla js参考<br>chrome开发中心（chrome的内核已转向blink）<br>safari开发中心<br>microsoft js参考<br>js秘密花园<br>js秘密花园<br>w3help 综合Bug集合网站<br>综合搜索</p><p>javascripting<br>各种流行库搜索<br>综合API</p><p>runoob.com-包含各种API集合<br>开源中国在线API文档合集<br>devdocs 英文综合API网站<br>devdocs 中文综合API网站<br>overapi 英文综合API网站</p><p>####2. jQuery</p><p>jQuery API 中文文档<br>hemin 在线版<br>css88 jq api<br>css88 jqui api<br>学习jquery<br>jquery 源码查找</p><p>####3. Ecmascript</p><p>Understanding ECMAScript 6 - Nicholas C. Zakas<br>exploring-es6<br>exploring-es6翻译<br>exploring-es6翻译后预览<br>阮一峰 es6<br>阮一峰 Javascript<br>ECMA-262，第 5 版<br>es5</p><p>####4. Js template</p><p>template-chooser<br>artTemplate<br>tomdjs<br>淘宝模板juicer模板<br>Fxtpl v1.0 繁星前端模板引擎<br>laytpl<br>mozilla - nunjucks<br>Juicer<br>dustjs<br>etpl<br>twitter-tpl</p><p>####5. 弹出层</p><p>artDialog 最新版<br>artDialog 文档<br>google code 下载地址<br>贤心弹出层<br>响应式用户交互组件库<br>sweetalert-有css3动画弹出层</p><p>####6. CSS</p><p>CSS 语法参考<br>CSS3动画手册<br>alloyteam - CSS3 UI 库<br>腾讯css3动画制作工具<br>志爷css小工具集合<br>css3 js 移动大杂烩<br>bouncejs 触摸库<br>css3 按钮动画<br>animate.css<br>全局CSS的终结(狗带) [译]<br>ANIMATION - 大漠<br>css选择器</p><p>####7. Angularjs</p><p>Angular.js 的一些学习资源<br>angularjs中文社区<br>Angular Style Guide<br>Angularjs源码学习<br>Angularjs源码学习<br>angular对bootstrap的封装<br>angularjs + nodejs<br>吕大豹 Angularjs<br>AngularJS 最佳实践<br>Angular的一些扩展指令<br>Angular数据绑定原理<br>一些扩展Angular UI组件<br>Ember和AngularJS的性能测试<br>带你走近AngularJS - 基本功能介绍<br>Angularjs开发指南<br>Angularjs学习<br>不要带着jQuery的思维去学习AngularJS<br>angularjs 学习笔记<br>angularjs 开发指南<br>angularjs 英文资料<br>angular bootstrap<br>angular jq mobile<br>angular ui<br>整合jQuery Mobile+AngularJS经验谈<br>有jQuery背景，该如何用AngularJS编程思想<br>AngularJS在线教程<br>angular学习笔记<br>UI Bootstrap - AngularJS directives specific to Bootstrap<br>NG Bootstrap - Angular 2 directives specific to Bootstrap 4</p><p>####8. React</p><p>react海量资源<br>react.js 中文论坛<br>react.js 官方网址<br>react.js 官方文档<br>react.js material UI<br>react.js TouchstoneJS UI<br>react.js amazeui UI<br>React 入门实例教程 - 阮一峰<br>React Native 中文版<br>Webpack 和 React 小书 - 前端乱炖<br>Webpack 和 React 小书 - gitbook<br>React原创实战视频教程<br>React 入门教程<br>react-webpack-starter<br>基于react组件化开发<br>React 编程规范(by Airbnb)<br>React Webpack小说<br>ant.design</p><p>####9. 移动端API</p><p>API<br>99移动端知识集合<br>移动端前端开发知识库<br>移动前端的一些坑和解决方法（外观表现）<br>【原】移动web资源整理<br>zepto 1.0 中文手册<br>zepto 1.0 中文手册<br>zepto 1.1.2<br>zepto 中文注释<br>jqmobile 手册<br>移动浏览器开发集合<br>移动开发大杂烩<br>微信webview中的一些问题<br>框架<br>特色的HTML框架可以创建精美的iOS应用<br>淘宝SUI</p><p>####10. avalon</p><p>avalonjs<br>Avalon新一代UI库： OniUI<br>avalon.oniui-基于avalon的组件库</p><p>####11. Requriejs</p><p>Javascript模块化编程（一）：模块的写法<br>Javascript模块化编程（二）：AMD规范<br>Javascript模块化编程（三）：require.js的用法<br>RequireJS入门（一）<br>RequireJS入门（二）<br>RequireJS进阶（三）<br>requrie源码学习<br>requrie 入门指南<br>requrieJS 学习笔记<br>requriejs 其一<br>require backbone结合</p><p>####12. Seajs</p><p>seajs<br>seajs 中文手册<br>JavaScript模块化开发库之SeaJS</p><p>####13. Less,sass</p><p>sass<br>sass教程-sass中国<br>Sass 中文文档<br>less</p><p>####14. Markdown</p><p>Markdown 语法说明 (简体中文版)<br>markdown入门参考<br>gitbook 国外的在线markdown可编辑成书<br>mdeditor 一款国内的在线markdown编辑器<br>stackedit 国外的在线markdown编辑器，功能强大，同步云盘<br>mditor 一款轻量级的markdown编辑器<br>lepture-editor<br>markdown-editor<br>Markdown 在线编辑器</p><p>####15. D3</p><p>d3 Tutorials<br>Gallery<br>lofter<br>iteye<br>ruanyifeng</p><p>####16. 兼容性</p><p>esma 兼容列表<br>W3C CSS验证服务<br>caniuse<br>csscreator<br>microsoft<br>在线测兼容-移动端<br>emulators</p><p>####17. UI相关</p><p>bootcss<br>MetroUICSS<br>semantic<br>Buttons<br>kitecss<br>pintuer<br>amazeui<br>worldhello<br>linuxtoy<br>gitmagic<br>rogerdudler<br>gitref<br>book<br>gogojimmy</p><p>####18. HTTP</p><p>HTTP API 设计指南</p><p>####19. 其它API</p><p>javascript流行库汇总<br>验证api<br>underscore 中文手册<br>underscore源码分析<br>underscore源码分析-亚里士朱德的博客<br>underscrejs en api<br>lodash - underscore的代替品<br>ext4api<br>backbone 中文手册<br>qwrap手册<br>缓动函数<br>svg 中文参考<br>svg mdn参考<br>svg 导出 canvas<br>svg 导出 png<br>ai-to-svg<br>localStorage 库</p><p>####20. 图表类</p><p>Highcharts 中文API<br>Highcharts 英文API<br>ECharts 百度的图表软件<br>高德地图<br>开源的矢量图脚本框架<br>svg 地图<br>jQuery Vector Map Library</p><p>####21. vue</p><p>Vue<br>Vue 论坛<br>Vue 入门指南<br>Vue 的一些资源索引</p><p>####21. 正则</p><p>JS正则表达式元字符<br>正则表达式30分钟入门教程<br>MDN-正则表达式<br>ruanyifeng - RegExp对象<br>小胡子哥 - 进阶正则表达式<br>is.js<br>正则在线测试<br>haorooms正则文章</p><p>####22. ionic</p><p>ionic</p><p>####23. 其它</p><p>Mock.js 是一款模拟数据生成器<br>jsdoc 注释生成 - apidocjs</p><p>###七. 开发规范</p><p>前端</p><p>通过分析github代码库总结出来的工程师代码书写习惯<br>HTML&amp;CSS编码规范 by @mdo<br>前端编码规范之js - by yuwenhui<br>前端编码规范之js - by 李靖<br>前端开发规范手册<br>Airbnb JavaScript 编码规范（简体中文版）<br>AMD与CMD规范的区别<br>AMD与CMD规范的区别<br>KISSY 源码规范<br>bt编码规范<br>规范加强版<br>前端代码规范 及 最佳实践<br>百度前端规范<br>百度前端规范<br>百度前端规范<br>ECMAScript6 编码规范–广发证券前端团队<br>JavaScript 风格指南/编码规范（Airbnb公司版）<br>网易前端开发规范<br>css模块<br>前端规范资源列表<br>前端JavaScript规范<br>Nodejs</p><p>Node.js 风格指南<br>PHP</p><p>最流行的PHP 代码规范<br>最流行的PHP 代码规范<br>Android</p><p>【敏捷开发】Android团队开发规范<br>Android 开发规范与应用<br>IOS</p><p>Swift Style Guide</p><p>###八. 其它收集</p><p>####1. 各大公司开源项目</p><p>Facebook</p><p>Facebook Projects<br>百度 Baidu</p><p>百度web前端研发部<br>百度EFE<br>百度github<br>腾讯 qq</p><p>alloyteam<br>alloyteam-github<br>alloyteam-AlloyGameEngine<br>AlloyDesigner 即时修改，即时保存，设计稿较正，其它开发辅助工具<br>H5交互页编辑器AEditor介绍 H5动画交互页开发的工具介绍<br>AEditor H5动画交互页开发的工具<br>腾讯html5<br>腾讯开源项目<br>奇舞团</p><p>奇舞团开源项目<br>去哪儿</p><p>Qunar UED<br>其它</p><p>maka<br>值得订阅的weekly</p><p>####2. Javascript</p><p>常用</p><p>ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性<br>模拟键盘<br>拼音<br>中国个人身份证号验证<br>算法</p><p>数据结构与算法 JavaScript 描述. 章节练习<br>常见排序算法（JS版）<br>经典排序<br>常见排序算法-js版本<br>JavaScript 算法与数据结构 精华集<br>面试常考算法题精讲<br>移动端</p><p>fastclick<br>no-click-delay<br>JSON</p><p>模拟生成JSON数据<br>返回跨域JSONAPI</p><p>####3. Html5</p><p>HTML5 有哪些让你惊艳的 demo？<br>html5 Canvas画图系列教程目录</p><p>####4. CSS</p><p>browserhacks</p><p>####5. jQuery</p><p>焦点图</p><p>myfocus<br>myfocus-官方演示站<br>SuperSlidev2.1 – 大话主席<br>soChange</p><p>####6. Ext, EasyUI, J-UI 及其它各种UI方案</p><p>Ext</p><p>extjs<br>ext4英文api<br>ext4中文api<br>EasyUI</p><p>jquery easyui 未压缩源代码<br>J-UI</p><p>J-UI<br>Other</p><p>MUI-最接近原生APP体验的高性能前端框架<br>Amaze UI | 中国首个开源 HTML5 跨屏前端框架<br>淘宝 HTML5 前端框架<br>KISSY - 阿里前端JavaScript库<br>网易Nej - Nice Easy Javascript<br>Kendo UI MVVM Demo<br>Bootstrap<br>Smart UI<br>雅虎UI - CSS UI</p><p>####7. 页面 社会化 分享功能</p><p>百度分享 pc端<br>JiaThis pc端<br>社会化分享组件 移动端<br>ShareSDK 轻松实现社会化功能 移动端<br>友盟分享 移动端<br>addthis 国外社交分享<br>一键分享到各种SNS</p><p>####8. 富文本编辑器</p><p>百度 ueditor<br>经典的ckeditor<br>经典的kindeditor<br>wysiwyg<br>一个有情怀的编辑器。Bach’s Editor<br>tower用的编辑器<br>summernote 编辑器<br>html5编辑器<br>XEditor<br>wangEditor<br>wangEditor-mobile–移动端编辑器<br>Trumbowyg - 轻量编辑器<br>国外的一款编辑器 - tinymce</p><p>####9. 日历</p><p>PC</p><p>经典my97<br>强大的独立日期选择器<br>fullcalendar<br>fullcalendar日历控件知识点集合<br>中文api<br>农历日历<br>超酷的仿百度带节日日历老黄历控件<br>日期格式化<br>大牛日历控件<br>我群某管理作品<br>input按位替换-官网<br>input按位替换-github<br>bootstrap-daterangepicker<br>国外30个插件集合<br>JavaScript datepicker<br>Datepair.js<br>一个风格多样的日历<br>弹出层式的全日历<br>jquery双日历<br>bootstrap-datetimepicker/<br>贤心-laydate<br>Pikaday-微型日历<br>AngularJS datepicker directives<br>周选择日历插件<br>移动</p><p>大气实用jQuery手机移动端日历日期选择插件<br>jQuery Mobile 移动开发中的日期插件Mobiscroll<br>Date library</p><p>Datejs<br>sugarjs</p><p>####10. 综合效果搜索平台</p><p>效果网<br>17素材<br>常用的JavaScript代码片段</p><p>####11. 前端工程化</p><p>概述</p><p>前端工具大全<br>什么是前端工程化<br>Gulp</p><p>Gulp官网<br>Gulp中文网<br>gulp资料收集<br>Gulp：任务自动管理工具 - ruanyifeng<br>Gulp插件<br>Gulp不完全入门教程<br>为什么使用gulp?<br>Gulp安装及配合组件构建前端开发一体化<br>Gulp 入门指南<br>Gulp 入门指南 - nimojs<br>Gulp入门教程<br>Gulp in Action<br>Gulp开发教程（翻译）<br>前端构建工具gulpjs的使用介绍及技巧<br>Grunt</p><p>gruntjs<br>Grunt中文网<br>Grunt入门教程<br>Fis</p><p>fis 官网<br>fis<br>webpack</p><p>webpack<br>Webpack 中文指南<br>Webpack，101入门体验<br>webpack入门教程<br>基于webpack搭建前端工程解决方案探索<br>Webpack傻瓜式指南（一）<br>Webpack指南<br>webpack指南<br>webpack 教程资源收集</p><p>####12. 轮播图</p><p>pc图轮</p><p>单屏轮播sochange<br>左右按钮多图切换<br>fullpage全屏轮播<br>haorooms资源库轮播大全<br>移动端</p><p>无缝切换<br>滑屏效果<br>全屏fullpage<br>单个图片切换<br>单个全屏切换<br>百度的切换库<br>单个全屏切换<br>滑屏效果<br>旋转拖动设置<br>类似于swipe切换<br>支持多种形式的触摸滑动<br>滑屏效果<br>大话主席pc移动图片轮换<br>滑屏效果<br>基于zepto的fullpage<br>[WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应<br>判断微信客户端的那些坑<br>可以通过javascript直接调用原生分享的工具<br>JiaThis 分享到微信代码<br>聊聊移动端跨平台开发的各种技术<br>前端自动化测试<br>多种轮换图片<br>滑动侧边栏</p><p>####13. 文件上传</p><p>百度上传组件<br>上传<br>flash 头像上传<br>图片上传预览<br>图片裁剪<br>图片裁剪-shearphoto<br>jQuery图片处理<br>文件上传</p><p>####14. 模拟select</p><p>糖饼 select<br>flexselect<br>双select<br>select2</p><p>####15. 取色插件</p><p>类似 Photoshop 的界面取色插件<br>jquery color<br>取色插件集合<br>farbtastic 圆环＋正方形</p><p>####16. 城市联动</p><p>jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果<br>移动端省市三级联动demo</p><p>####17. 剪贴板</p><p>剪贴板<br>clipboard 最新的剪切方案</p><p>####18. 简繁转换</p><p>简繁转换</p><p>####19. 表格 Grid</p><p>facebook表格<br>类似于Excel编辑表格-handsontable<br>bootstrap-table插件<br>datatables<br>不错的Grid</p><p>####20. 在线演示</p><p>js 在线编辑 - runjs<br>js 在线编辑 - jsbin<br>js 在线编辑 - codepen<br>js 在线编辑 - jsfiddle<br>phpfiddle<br>java 在线编辑 - ideone<br>js 在线编辑 - hcharts<br>js 在线编辑 - jsdm<br>sql 在线编辑 - sqlfiddle<br>mozilla 在线编辑器</p><p>####21. 播放器</p><p>Html5 VideoPlayer</p><p>####22. 粒子动画</p><p>Proton 烟花</p><p>####23. 表单验证</p><p>Validform<br>formvalidator<br>jQuery formValidator<br>表单验证完美解决方案</p><p>####24. 表单美化</p><p>美化checkbox</p><p>###九. Nodejs</p><p>Node.js 包教不包会<br>篇幅比较少<br>node express 入门教程<br>nodejs定时任务<br>一个nodejs博客<br>【NodeJS 学习笔记04】新闻发布系统<br>过年7天乐，学nodejs 也快乐<br>七天学会NodeJS<br>Nodejs学习笔记（二）— 事件模块<br>nodejs入门<br>angularjs nodejs<br>从零开始nodejs系列文章<br>理解nodejs<br>nodejs事件轮询<br>node入门<br>nodejs cms<br>Node初学者入门，一本全面的NodeJS教程<br>NodeJS的代码调试和性能调优<br>runs Node.js programs through Chromium DevTools</p><p>###十. 性能优化</p><p>常规优化</p><p>Javascript高性能动画与页面渲染<br>移动H5前端性能优化指南<br>5173首页前端性能优化实践<br>给网页设计师和前端开发者看的前端性能优化<br>复杂应用的 CSS 性能分析和优化建议<br>张鑫旭——前端性能<br>前端性能监控总结<br>网站性能优化之CSS无图片技术<br>web前端性能优化进阶路<br>前端技术：网站性能优化之CSS无图片技术<br>浏览器的加载与页面性能优化<br>页面加载中的图片性能优化<br>Hey——前端性能<br>html优化<br>99css——性能<br>Yslow——性能优化<br>YSLOW中文介绍<br>转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化<br>Yahoo!团队实践分享：网站性能<br>网站性能优化指南：什么使我们的网站变慢？<br>网站性能优化实践，减少加载时间，提高用户体验<br>浅谈网站性能优化 前端篇<br>前端重构实践之如何对网站性能优化？<br>前端性能优化：使用媒体查询加载指定大小的背景图片<br>网站性能系列博文<br>加载，不只是少一点点<br>前端性能的测试与优化<br>分享网页加载速度优化的一些技巧？<br>页面加载中的图片性能优化<br>web前端优化(基于Yslow)<br>网站性能优化工具大全<br>【高性能前端1】高性能HTML<br>【高性能前端2】高性能CSS<br>由12306谈谈网站前端性能和后端性能优化<br>AlloyTeam——前端优化<br>毫秒必争，前端网页性能最佳实践<br>网站性能工具Yslow的使用方法<br>前端工程与性能优化（上）：静态资源版本更新与缓存<br>前端工程与性能优化（下）：静态资源管理与模板框架<br>HTTPS连接的前几毫秒发生了什么<br>Yslow<br>Essential Web Performance Metrics — A Primer, Part 1<br>Essential Web Performance Metrics — Part 2<br>YUISlide,针对移动设备的动画性能优化<br>Improving Site Performance<br>让网站提速的最佳前端实践<br>Why Website Speed is Important<br>Need for Speed – How to Improve your Website Performance<br>阿里无线前端性能优化指南 (Pt.1 加载期优化)<br>前端性能优化补充篇<br>优化工具</p><p>JavaScript 性能分析新工具 OneProfile<br>JavaScript 堆内存分析新工具 OneHeap<br>在线工具</p><p>google在线工具<br>阿里测<br>阿里-免费测试服务<br>阿里-F2etest多浏览器兼容性测试解决方案<br>js性能测试<br>轻松玩转PDF</p><p>###十一. 前端架构</p><p>技术架构<br>前端架构<br>如何成为前端架构师<br>关于前端架构-张克军<br>百度腾讯offer比较（腾讯游戏VS百度基础架构）</p><p>###十二. 个人作品</p><p>####1. 推荐作品</p><p>winter代码片段需要翻墙<br>fgm<br>岑安作品集<br>当耐特demo集合<br>米空格 js作品<br>myFocus<br>SeaJS组件库<br>颜海镜作品<br>脚儿网作品<br>javascript个人作品<br>妙味的雷东升游戏作品<br>javascript作品集<br>云五笔，灰度产生生成工具<br>项目主页<br>个性的作品主页<br>ucren js demos 集<br>智能社<br>实例陈列架<br>zoye demo<br>王员外<br>平凡<br>jyg 游戏案例<br>很多jquery插件<br>不羁虫 - soJs 作品系列<br>frozenui<br>黑白棋<br>fromone</p><p>####2. 群员作品</p><p>MDialog - [合肥-M.J]<br>轮播图 - [上海－冷静]<br>[广州—坚壳]<br>[成都 - 无痕]　感恩节专题<br>[球霸天]<br>[北京-小数]<br>[ptf] Magix 工具<br>[杭州-Pft] Magix 基于 MVC 结构和 Hash 驱动的 OPOA（One Page One Application）应用<br>[上海-剧中人]-实验室<br>[上海-豪情 ] 作品集合<br>[成都-feeling]<br>[上海-angela]<br>[海南-hank]作品<br>[上海-张力]博客<br>[上海-zenki]作品<br>移动端图案解锁<br>[合肥-M.J] - MPreview 移动端图片预览组<br>[合肥-M.J] - Mexam 移动端在线做题组<br>[北京-苏瑞] - dancer小人<br>[上海-玄沐]- 个人网站<br>[厦门-二哲]- 个人博客</p><p>####3. 国外大牛精品</p><p>pazguille</p><p>###十三. 简历</p><p>生成</p><p>MarkDown在线简历工具<br>MarkDown在线简历工具<br>模板</p><p>简历<br>张伦<br>简历<br>翁天信<br>动画方式的简历<br>组件丰富简历<br>简历池<br>haorooms博客<br>Justin Young<br>各个程序员简历模板</p><p>###十四. 面试题</p><p>前端</p><p>那几个月在找工作（百度，网易游戏）<br>名企笔试大全<br>2016校招内推 – 阿里巴巴前端 – 三面面试经历<br>年后跳槽那点事：乐视+金山+360面试之行<br>拉勾网js面试题<br>前端面试<br>前端开发面试题<br>百度面试<br>前端工作面试问题<br>前端开发面试题<br>5个经典的前端面试问题<br>如何面试一名前端开发工程师？<br>前端实习生面试总结<br>史上最全 前端开发面试问题及答案整理<br>BAT及各大互联网公司2014前端笔试面试题：JavaScript篇<br>前端开发面试题大收集<br>收集的前端面试题和答案<br>如何面试前端工程师<br>前端开发面试题<br>牛客网-笔试面经<br>Front End Developer Questions<br>40 个重要的 HTML5 面试问题及答案<br>java</p><p>Java工程师笔试题整理[校招篇]</p><p>###十五. iconfont</p><p>中文字体<br>淘宝字库<br>字体<br>制作教程<br>zhangxinxu-icommon<br>icommon<br>用字体在网页中画ICON图标(推荐教程)<br>字体压缩工具 感谢初级群　[深圳-小鱼] 的推荐</p><p>###十六. 开发工具类</p><p>前端开发工具</p><p>IntelliJ IDEA 简体中文专题教程<br>Webstorm,InterllIdea,Phpstorm<br>SublimeText<br>Atom<br>Atom飞行手册（中文版）<br>Atom-vue代码高亮<br>visual studio code<br>visual studio code 使用指南<br>Chrome, Firebug, Filddle 调试</p><p>Fiddler</p><p>Fiddler调式使用知多少(一)深入研究<br>微信fiddle<br>微信fiddle<br>Chrome</p><p>Google Chrome 官方<br>Chrome - 基础<br>Chrome - 进阶<br>Chrome - 性能<br>Chrome - 性能进阶<br>Chrome - 移动<br>Chrome - 使用技巧<br>Chrome - Console控制台不完全指南<br>Chrome - Workspace使浏览器变成IDE<br>network面板<br>chrome开发工具快捷键<br>chrome调试工具常用功能整理<br>Chrome 开发工具 Workspace 使用<br>Chrome神器Vimium快捷键学习记录<br>sass调试-w3cplus<br>如何更专业的使用Chrome开发者工具-w3cplus<br>chrome调试canvas<br>chrome profiles1<br>chrome profiles2<br>chrome profiles3<br>chrome移动版调试<br>chrome调试<br>chrome的调试<br>chrome console 命令详解<br>查看事件绑定1<br>查看事件绑定2<br>神器——Chrome开发者工具(一)<br>奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍)<br>chrome 开发者工具的 15 个小技巧<br>Chrome开发者工具不完全指南<br>Chrome 开发者工具使用技巧<br>Chrome渲染分析之Rendering工具使用(1)<br>Chrome渲染分析之Rendering工具使用(2)<br>Chrome渲染分析之Rendering工具使用(3)<br>像 Sublime Text 一样使用 Chrome DevTools<br>Chorme 35个开发者工具的小技巧<br>Chrome 实用调试技巧<br>Firebug</p><p>firebug视频教程<br>firefox 模拟器<br>console.log 命令详解<br>Firebug入门指南<br>Firebug控制台详解<br>移动,微信调试</p><p>微信调试的那些事<br>微信调试官网<br>微信公众号本地调试<br>微信、手Q、Qzone之x5内核inspect调试解决方案<br>浏览器端调试安卓<br>移动端前端开发调试<br>使用 Chrome 远程调试 Android 设备<br>mac移动端调试<br>mac移动端调试<br>无线调试攻略<br>无线调试攻略<br>屌爆了,完美调试 微信webview(x5)<br>远程console<br>微信调试工具<br>各种真机远程调试方法汇总<br>手机测试自己写的web页面<br>iOS Simulator</p><p>Simulator<br>Xcode中的iOS模拟器(iOS Simulator)的介绍和使用心得<br>img</p><p>loading img<br>智图-图片优化平台<br>在线png优化<br>生成二维码</p><p>生成二维码<br>浏览器同步</p><p>puer<br>liveReload<br>f5<br>File Watchers<br>在线PPT制作</p><p>nodePPT<br>PPT<br>reveal<br>slippy</p><p>###十七. 前端导航网站</p><p>前端导航<br>前端网址导航<br>前端名录<br>前端导航<br>前端开发资源<br>前端开发仓库 - 众多效果的收集地<br>前端资源导航<br>F2E 前端导航<br>前端收藏夹<br>前端导航<br>前端工具箱<br>前端人俱乐部-灵感_Idea<br>haorooms前端导航</p><p>###十八. 常用CDN</p><p>新浪CDN<br>百度静态资源公共库<br>360网站卫士常用前端公共库CDN服务<br>Bootstrap中文网开源项目免费 CDN 服务<br>开放静态文件 CDN - 七牛<br>CDN加速 - jq22<br>jQuery CDN<br>Google jQuery CDN<br>微软CDN</p><p>###十九. Git,SVN,Github</p><p>Git</p><p>git-scm<br>廖雪峰-Git教程<br>git-for-windows<br>GitHub 添加 SSH keys<br>gogithub<br>git常规命令练习<br>git的资料整理<br>我所记录的git命令（非常实用）<br>企业开发git工作流模式探索部分休整<br>GitHub 漫游指南<br>GitHub秘籍<br>使用git和github进行协同开发流程<br>动画方式练习git<br>版本管理工具介绍—Git篇<br>版本控制入门 – 搬进 Github<br>Git动画演示<br>SVN</p><p>版本管理工具介绍—SVN篇</p><p>正文来自<a href="https://github.com/jsfront/src/blob/master/qq.md本文转载" target="_blank" rel="noopener">https://github.com/jsfront/src/blob/master/qq.md本文转载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###五. 资源教程:&lt;/p&gt;
&lt;p&gt;综合类&lt;br&gt;
    
    </summary>
    
    
      <category term="综合" scheme="https://wangdabao.js.org/tags/%E7%BB%BC%E5%90%88/"/>
    
      <category term="技术" scheme="https://wangdabao.js.org/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>&#39;福利 - 不过百行代码的爬虫爬取美女图&#39;</title>
    <link href="https://wangdabao.js.org/2017/02/14/node%E7%88%AC%E8%99%AB/"/>
    <id>https://wangdabao.js.org/2017/02/14/node爬虫/</id>
    <published>2017-02-14T01:54:48.000Z</published>
    <updated>2020-07-05T11:49:17.870Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到<br>序言<br><a id="more"></a><br>闲的无聊，看到一个段子网站的美女福利还不错，迫于福利加载太慢看的不过瘾，就想用Nodejs写个简单爬虫全部爬下来看多好….. 此处省略5000字…..</p><p>准备</p><p>要爬，首先得要有目标，我呢，就把目标锁定到了 某哈，然后呢就是用浏览器来分析分析其中的规律</p><p>从中可以看到每一条段子都是一个 .joke-list-item, 当点击下一页的时候 url中地址的最后一位数就表示分页的页码。有些图片是缩略图，我们把缩略图和正常图的地址进行了比较，发现他们的地址格式是一样的，缩略图在small文件夹下，大图在big文件夹下。分析完了我们就可以写代码了。</p><p>开始</p><p>这个简单爬虫分两个部分，1、获取图片地址。2、进行下载。因为下载是一个耗时的操作，所以两个部分分开了，这样也有利于后期改动。</p><p>导入必要的模块，使用cheerio 是第三方模块，可以使用 npm install cheerio 进行安装<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);<span class="comment">// http 网路</span></span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);<span class="comment">// html 解析</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);<span class="comment">// 流</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> queryHref = <span class="string">"http://www.haha.mx/topic/1/new/"</span>; <span class="comment">// 设置被查询的目标网址</span></span><br><span class="line"><span class="keyword">var</span> querySearch = <span class="number">1</span>;<span class="comment">// 设置分页位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> urls = [];<span class="comment">// 所有待下载的图片地址</span></span><br><span class="line"></span><br><span class="line">这个是解析图片地址方法</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据url和参数获取分页内容</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125;： url</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125;： serach</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;pre&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHtml</span>(<span class="params">href, serach</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pageData = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">var</span> req = http.get(href + serach, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">    res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">      pageData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      $ = cheerio.load(pageData);</span><br><span class="line">      <span class="keyword">var</span> html = $(<span class="string">".joke-list-item .joke-main-content a img"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; html.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> src = html[i].attribs.src;</span><br><span class="line">        <span class="comment">// 筛选部分广告，不是真的段子</span></span><br><span class="line">        <span class="keyword">if</span> (src.indexOf(<span class="string">"http://image.haha.mx"</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">          urls.push(html[i].attribs.src)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个是下载图片的方法</p><p>/**</p><ul><li>下载图片</li><li>@param {String} imgurl：图片地址<br>*/</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downImg</span>(<span class="params">imgurl</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> narr = imgurl.replace(<span class="string">"http://image.haha.mx/"</span>, <span class="string">""</span>).split(<span class="string">"/"</span>)</span><br><span class="line">  </span><br><span class="line">  http.get(imgurl.replace(<span class="string">"/small/"</span>, <span class="string">"/big/"</span>), <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> imgData = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//一定要设置response的编码为binary否则会下载下来的图片打不开</span></span><br><span class="line">    res.setEncoding(<span class="string">"binary"</span>);   </span><br><span class="line"></span><br><span class="line">    res.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">      imgData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    res.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> savePath = <span class="string">"./upload/topic1/"</span> + narr[<span class="number">0</span>]  + narr[<span class="number">1</span>] + narr[<span class="number">2</span>] + <span class="string">"_"</span> + narr[<span class="number">4</span>];</span><br><span class="line">      <span class="comment">// 保存图片</span></span><br><span class="line">      fs.writeFile(savePath, imgData, <span class="string">"binary"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，到这里核心的东西就写完了，然后就是组装一下，让他运行起来</p><p>附一个完整代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);<span class="comment">// http 网路</span></span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);<span class="comment">// html 解析</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);<span class="comment">// 流</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> queryHref = <span class="string">"http://www.haha.mx/topic/1/new/"</span>; <span class="comment">// 设置被查询的目标网址</span></span><br><span class="line"><span class="keyword">var</span> querySearch = <span class="number">1</span>;<span class="comment">// 设置分页位置</span></span><br><span class="line"><span class="keyword">var</span> urls = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sumConut = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> reptCount = <span class="number">0</span>;<span class="comment">// 重复的</span></span><br><span class="line"><span class="keyword">var</span> downCount = <span class="number">0</span>;<span class="comment">// 实际下载的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据url和参数获取分页内容</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125;： url</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125;： serach</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHtml</span>(<span class="params">href, serach</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"正在获取第 "</span>+serach + <span class="string">" 页的图片"</span>);</span><br><span class="line"><span class="keyword">var</span> pageData = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> req = http.get(href + serach, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">pageData += chunk;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">$ = cheerio.load(pageData);</span><br><span class="line"><span class="keyword">var</span> html = $(<span class="string">".joke-list-item .joke-main-content a img"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; html.length; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> src = html[i].attribs.src;</span><br><span class="line"><span class="comment">// 筛选部分广告，不是真的段子</span></span><br><span class="line"><span class="keyword">if</span> (src.indexOf(<span class="string">"http://image.haha.mx"</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">urls.push(html[i].attribs.src)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归调用</span></span><br><span class="line"><span class="keyword">if</span> (serach &lt; pagemax) &#123;</span><br><span class="line">getHtml(href, ++serach);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"图片链接获取完毕！"</span>);</span><br><span class="line">sumConut = urls.length;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"链接总数量："</span> + urls.length);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"开始下载......"</span>);</span><br><span class="line">downImg(urls.shift());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>/**</p><ul><li>下载图片</li><li>@param {String} imgurl：图片地址<br>*/</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downImg</span>(<span class="params">imgurl</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> narr = imgurl.replace(<span class="string">"http://image.haha.mx/"</span>, <span class="string">""</span>).split(<span class="string">"/"</span>)</span><br><span class="line"><span class="comment">// 做一步优化，如果存在文件，则不下载</span></span><br><span class="line"><span class="keyword">var</span> filename = <span class="string">"./upload/topic1/"</span> + narr[<span class="number">0</span>]  + narr[<span class="number">1</span>] + narr[<span class="number">2</span>] + <span class="string">"_"</span> + narr[<span class="number">4</span>];</span><br><span class="line">fs.exists(filename, <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) &#123;</span><br><span class="line"><span class="comment">// 文件不存则进行 下载</span></span><br><span class="line">http.get(imgurl.replace(<span class="string">"/small/"</span>, <span class="string">"/big/"</span>), <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> imgData = <span class="string">""</span>;</span><br><span class="line"><span class="comment">//一定要设置response的编码为binary否则会下载下来的图片打不开</span></span><br><span class="line">res.setEncoding(<span class="string">"binary"</span>); </span><br><span class="line"></span><br><span class="line">res.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">imgData += chunk;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">res.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> savePath = <span class="string">"./upload/topic1/"</span> + narr[<span class="number">0</span>]  + narr[<span class="number">1</span>] + narr[<span class="number">2</span>] + <span class="string">"_"</span> + narr[<span class="number">4</span>];</span><br><span class="line">fs.writeFile(savePath, imgData, <span class="string">"binary"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;  <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(narr[<span class="number">0</span>]  + narr[<span class="number">1</span>] + narr[<span class="number">2</span>] + <span class="string">"_"</span> + narr[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">if</span> (urls.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">downImg(urls.shift());</span><br><span class="line">downCount++;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"剩余图片数量...."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 统计重复的图片</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"该图片已经存在重复."</span>);</span><br><span class="line">reptCount++;</span><br><span class="line"><span class="keyword">if</span> (urls.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">downImg(urls.shift());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (urls.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"下载完毕"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"重复图片："</span> + reptCount);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"实际下载："</span> + downCount);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pagemax = <span class="number">30</span>;<span class="comment">// 获取到多少页的内容</span></span><br><span class="line"><span class="keyword">var</span> startindex = <span class="number">1</span>;<span class="comment">// 从多少页开始获取</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"开始获取图片连接"</span>);</span><br><span class="line">getHtml(queryHref, startindex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start();</span><br></pre></td></tr></table></figure><p>因为nodejs是异步的，所以在 start 方法中的for之后调用下载是不行，这个时候显示的 urls 中是没有数据的。</p><p>所以就是在 getHtml 中 等所有的连接分析完毕之后在调用 downImg，downImg下载完成之后在进行下一个下载。</p><p>项目目录很简单，如图：</p><p>然后我们切换到项目目录，执行 node app , 然后就静静的等待把，每次下载完一个会有对应的文件名打印出来的。</p><p>最后会出现 下载完毕！，之后就……. 你懂得……</p><p>这个是一个很简单的，当然后续你可以加上数据库，数据更新之类的…..</p><p>放几张我爬到的图</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>注意前方高能</p><p>注意前方高能</p><p>注意前方高能</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>嘘… 不要告诉别人….</p><p>原文地址:<a href="https://zhuanlan.zhihu.com/p/24730075" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24730075</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-----------------更新-----------------------&gt;</span><br></pre></td></tr></table></figure><p>隔了挺长时间的, 我又整理了下代码。<br>原作者的代码我测试了下, 发现已经不能使用了, 我整理了下, 测试已过了。<br>代码我提交到<a href="https://github.com/wangdabaoqq/nodeImage" target="_blank" rel="noopener">github</a></p><p>贴下图<br><img src="https://raw.githubusercontent.com/wangdabaoqq/nodeImage/master/img/2906885_c480745a9a03a497dae9e9fcc9a4b988_1572586050.jpg" alt="图一"></p><p><img src="https://raw.githubusercontent.com/wangdabaoqq/nodeImage/master/img/2907118_2cba6e116b5df38dc8ab297b64a0a4e0_1572761560.jpg" alt="图二"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看到&lt;br&gt;序言&lt;br&gt;
    
    </summary>
    
    
      <category term="web" scheme="https://wangdabao.js.org/tags/web/"/>
    
      <category term="node" scheme="https://wangdabao.js.org/tags/node/"/>
    
  </entry>
  
</feed>
