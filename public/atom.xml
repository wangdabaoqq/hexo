<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王西柚</title>
  <icon>https://www.gravatar.com/avatar/7d474fb471782a29372082c2d2649d01</icon>
  <subtitle>小儿无名,不耻而学。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tyty.me/"/>
  <updated>2017-12-22T04:11:23.821Z</updated>
  <id>https://tyty.me/</id>
  
  <author>
    <name>王西柚</name>
    <email>614692339@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&#39;git命令(全)&#39;</title>
    <link href="https://tyty.me/2017/10/01/git%E5%91%BD%E4%BB%A4%E5%9B%BE(%E5%85%A8)/"/>
    <id>https://tyty.me/2017/10/01/git命令图(全)/</id>
    <published>2017-10-01T14:02:12.000Z</published>
    <updated>2017-12-22T04:11:23.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><a id="more"></a><p><img src="https://qn.tyty.me/git%E5%91%BD%E4%BB%A4%E5%9B%BE.jpg" alt="git"></p><p>转载自掘金,手打。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;git&quot;&gt;&lt;a href=&quot;#git&quot; class=&quot;headerlink&quot; title=&quot;git&quot;&gt;&lt;/a&gt;git&lt;/h2&gt;
    
    </summary>
    
    
      <category term="git命令" scheme="https://tyty.me/tags/git%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>&#39;移动端资源整合部分&#39;</title>
    <link href="https://tyty.me/2017/09/27/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    <id>https://tyty.me/2017/09/27/移动端/</id>
    <published>2017-09-27T15:09:56.000Z</published>
    <updated>2017-12-22T04:11:23.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="meta篇"><a href="#meta篇" class="headerlink" title="meta篇"></a>meta篇</h2><h3 id="1-视窗宽度"><a href="#1-视窗宽度" class="headerlink" title="1.视窗宽度"></a>1.视窗宽度</h3><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;, initial-scale=1.0, minimum-scale=1.0, maxinum-scale=1.0,user-scalable=no&quot;&quot;&gt;</code></p><p>其中width=device-width是设置视窗宽设备宽度,还可以固定宽度,例如:width=640则是640px的宽度(常见于微信);<br>initial-scale=1.0: 设置缩放比例为1.0;<br>minimum-scale=1.0和maximum-scale=1.0: 最大缩放比例和最大缩放比例;<br>user-scalable-no: 禁止用户自由缩放,user-scalable默认值为yes.</p><a id="more"></a><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initscale=1.0, user-scalable=no&quot;&gt;</code></p><h3 id="自动识别格式"><a href="#自动识别格式" class="headerlink" title="自动识别格式"></a>自动识别格式</h3><p><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</code></p><p>content里面的参数: telephone是禁止浏览器自动识别手机号码,email=no是禁止浏览器自动识别Email.</p><h3 id="完整模板"><a href="#完整模板" class="headerlink" title="完整模板"></a>完整模板</h3><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt;</code></p><p><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</code></p><p><code>&lt;meta name=&quot;formate-detection&quot; content=&quot;email=no&quot;&gt;</code></p><h2 id="CSS篇"><a href="#CSS篇" class="headerlink" title="CSS篇"></a>CSS篇</h2><pre>body {  font-family: "Helvetica Neue",  Helvetica, STHeiTi, sans-serif;  /* 使用无衬线字体 */}a, img {  -webkit-touch-callout: none;  /* 禁止长按链接与图片弹出菜单 */}html, body {  -webkit-user-slect: none;  /* 禁止选中文中 */  user-select: none;}button, input, optgroup, select, textarea {  -webkit-tap-highlight-color: rgab(0, 0, 0, 0);  /* 去掉a, input和button点击时的蓝色外边框和灰色半透明背景 */}input::-webkit-input-placeholder {  color: #ccc;  /* 修改webkit中input的planceholder样式 */  }input:focus::-webkit-input-placeholder {  color: #f00;  /* 修改webkit中focus状态下input的planceholder样式 */}body {  -webkit-text-size-adjust: 100%!important;  /* 禁止Ios调整字体大小 */}input::-webkit-input-speech-button {  display: none;  /* 隐藏Android的语音输入按钮 */}</pre><h2 id="flex基础篇"><a href="#flex基础篇" class="headerlink" title="flex基础篇"></a>flex基础篇</h2><p>这里假设flex容器为.box, 子元素为item</p><h3 id="定义容器为flex布局"><a href="#定义容器为flex布局" class="headerlink" title="定义容器为flex布局"></a>定义容器为flex布局</h3>  <pre>    .box {      display: -webkit-flex;       display: flex;    }    /* 行内flex */    .box {      display: -webkit-inline-flex;      display: inline-flex;    }  </pre><h3 id="容器样式"><a href="#容器样式" class="headerlink" title="容器样式"></a>容器样式</h3>  <pre>  .box {    flex-direction: row | row-reverse | column | column-reverse;    /* 主轴方向: 从左到右(默认) | 从右到左 | 上到下 | 下到上 -->    flex-wrap: norwap | wrap | wrap-reverse;    /* 换行: 不换行(默认) | 换行 | 换行并第一行在下方 */    flex-flow: flex-direction | flex-wrap;    /* 主轴方向和换行简写 */    justify-content: flex-start | flex-end | center | space-between | space-argound;    /* 主轴对齐方式: 左对齐(默认) | 右对齐 | 居中对齐 | 两端对齐 | 平均分布 */    align-items: flex-start | flex-end | center | baseline | stretch;    /* 交叉轴对齐方式: 顶部对齐(默认) 顶部对齐 居中对齐 | 上下对齐并铺满 | 文本基线对齐 */    align-content: flex-start | flex-end | cneter | space-between | space-around | strech;    /* 多主轴对齐: 顶部对齐(默认) | 顶部对齐 | 居中对齐 | 上下对齐并铺满 | 上下平均分布 */  }  </pre><h3 id="子元素样式"><a href="#子元素样式" class="headerlink" title="子元素样式"></a>子元素样式</h3><pre>  item {    order: integer;    /* 排序: 数值越小,越排前,默认为0 */    flex-grow: <number>      /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/    flex-shrink: <number>    /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/    flex-basis: <length> | auto; /* default auto */    /*固定大小：默认为0，可以设置px值，也可以设置百分比大小*/    flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]    /*flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，*/    align-self: auto | flex-start | flex-end | center | baseline | stretch;    /*单独对齐方式：自动（默认） | 顶部对齐 | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/  }</'flex-basis'></'flex-shrink'></'flex-grow'></length></number></number></pre><h2 id="小技巧篇"><a href="#小技巧篇" class="headerlink" title="小技巧篇"></a>小技巧篇</h2><h3 id="自定义苹果图标"><a href="#自定义苹果图标" class="headerlink" title="自定义苹果图标"></a>自定义苹果图标</h3><p>在网站文件根目录放一个 apple-touch-icon.png 文件，苹果设备保存网站为书签或桌面快捷方式时，就会使用这个文件作为图标，文件尺寸建议为：180px × 180px。</p><h3 id="自定义favicon"><a href="#自定义favicon" class="headerlink" title="自定义favicon"></a>自定义favicon</h3><p><code>&lt;link rel=&quot;icon&quot; href=&quot;favicon.icon&quot; mce_href=&quot;favicon.icon&quot; type=&quot;image/x-icon&quot;&gt;</code></p><h3 id="定义浏览器点击行为"><a href="#定义浏览器点击行为" class="headerlink" title="定义浏览器点击行为"></a>定义浏览器点击行为</h3><p><code>&lt;a href=&quot;tel: 020-10086&quot;&gt;打电话: 020-10086&lt;/a&gt;</code></p><p><code>&lt;a href=&quot;sms: 10086&quot;&gt;发短信&lt;/a&gt;</code></p><p><code>&lt;a href=&quot;mailto:me@22.clue&gt;发送邮件&lt;/a&gt;</code></p><h3 id="定义上传文件类型和格式"><a href="#定义上传文件类型和格式" class="headerlink" title="定义上传文件类型和格式"></a>定义上传文件类型和格式</h3><p><code>&lt;input type=&quot;file&quot; accept=&quot;image/*&quot;&gt;</code></p><p>上面的文件上传框中,accept可以限制上传文件的类型,参数image/<em>是所有图片类型,点击会弹出图库,也可以指定图片格式,参数设置成image/png则可以限制图片类型png,参数如果为video/</em>则是选择视频的意思;accept还可以设置多个文件格式,语法为accept=”image/gif, image/jpeg”;</p><h3 id="使用box-shadow改变-挡住-表单自动填充后的黄色"><a href="#使用box-shadow改变-挡住-表单自动填充后的黄色" class="headerlink" title="使用box-shadow改变(挡住)表单自动填充后的黄色"></a>使用box-shadow改变(挡住)表单自动填充后的黄色</h3><pre>  input:-webkit-autofill, textarea: -webkit-autofill, select:-webkit-autofill {    box-shadow: inset 0 0 0 1000px #fff;  }</pre><h3 id="用CSS实现省略号截断"><a href="#用CSS实现省略号截断" class="headerlink" title="用CSS实现省略号截断"></a>用CSS实现省略号截断</h3><p><code>white-space: nowrap;text-overflow: elipsis;</code></p><h3 id="使用border绘制小三角"><a href="#使用border绘制小三角" class="headerlink" title="使用border绘制小三角"></a>使用border绘制小三角</h3><p>原理是:上下和左右的边框对接其实是个斜角,利用这个特性,使其中一边的边框透明,另外一边写成想要的颜色并隐藏对边,就可以变成小箭头形状。</p><p><img src="https://qn.tyty.me/三角形.png" alt="text"></p><pre>  border-width: 10px 10px 10px 0;  /* 三角形 */  border-color: transparent #fff;  border-style: solid;  width: 0; </pre><p>Toptips写法</p><p><code>&lt;div class=&quot;box&quot;&gt;嗨！点击菜单就可以关注兮兮公众号了哟</code></p><pre>.box {  position: relative;  padding: 0 20px;  width: 380px;  height: 80px;  border-radius: #efefef;  font-size: 18px;  line-height: 80px;}.box:after {  position: absolute;  top: 50%;  left: -15px;  z-index: 1;  display: block;  margin-top: -15px;  width: 0;  border-color: transparent #efefef;  border-style: solid;  border-width: 15px 15px 15px 0;  content: '';}</pre><p><img src="https://qn.tyty.me/toptips.png" alt="text"></p><p>以上内容绝对纯手打,没有任何机打痕迹。<br>转载自作者Heleth</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;meta篇&quot;&gt;&lt;a href=&quot;#meta篇&quot; class=&quot;headerlink&quot; title=&quot;meta篇&quot;&gt;&lt;/a&gt;meta篇&lt;/h2&gt;&lt;h3 id=&quot;1-视窗宽度&quot;&gt;&lt;a href=&quot;#1-视窗宽度&quot; class=&quot;headerlink&quot; title=&quot;1.视窗宽度&quot;&gt;&lt;/a&gt;1.视窗宽度&lt;/h3&gt;&lt;p&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width&amp;quot;, initial-scale=1.0, minimum-scale=1.0, maxinum-scale=1.0,user-scalable=no&amp;quot;&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中width=device-width是设置视窗宽设备宽度,还可以固定宽度,例如:width=640则是640px的宽度(常见于微信);&lt;br&gt;initial-scale=1.0: 设置缩放比例为1.0;&lt;br&gt;minimum-scale=1.0和maximum-scale=1.0: 最大缩放比例和最大缩放比例;&lt;br&gt;user-scalable-no: 禁止用户自由缩放,user-scalable默认值为yes.&lt;/p&gt;
    
    </summary>
    
    
      <category term="web" scheme="https://tyty.me/tags/web/"/>
    
      <category term="移动端" scheme="https://tyty.me/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>&#39;Javascript数组方法(ES5-ES6)&#39;</title>
    <link href="https://tyty.me/2017/09/20/Javascript%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <id>https://tyty.me/2017/09/20/Javascript的数组方法/</id>
    <published>2017-09-20T14:30:12.000Z</published>
    <updated>2017-12-22T04:11:23.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="join-ES5"><a href="#join-ES5" class="headerlink" title="join() ES5"></a>join() ES5</h2><p>join(speparator):将数组的元素组起一个字符串,spearator为分隔符,省略的话则用默认用逗号为分隔符,该方法只接收一个参数,即分隔符。</p><pre>  var arr = [1,2,3];  console.log(arr.join());  console.log(arr.join('-'));  console.log(arr);</pre>通过join()方法可以重复字符串,只需传入字符串以及重复的次数,就能返回重复后的字符串,函数如下:<pre>function repeatString(str, n) {  console.log(new Array(n + 1).join(str));  return new Array(n + 1).join(str);};console.log(repeatString('abc', 3)); // abcabcabc</pre><a id="more"></a><h2 id="push-和pop-ES5"><a href="#push-和pop-ES5" class="headerlink" title="push()和pop() ES5"></a>push()和pop() ES5</h2><p>push()：可以接收任意数量的参数，把他们逐个添加到数组末尾,并返回修改后数组的长度。<br>pop()：数组末尾移除最后,减少数组的length值,然后返回移除的项。</p><pre>var arr = ['mi', 'to', 'you'];var count = arr.push('yao');console.log(count);console.log(arr);var sd = arr.pop();console.log(sd);console.log(arr);</pre><h2 id="shift-和unshift"><a href="#shift-和unshift" class="headerlink" title="shift()和unshift()"></a>shift()和unshift()</h2><p>shift(): 删除原数组第一项,并返回删除元素的值,如果数组为空则返回undefind.<br>unshift():将参数添加到原数组开头,并返回数组的长度。</p><pre>var arr = ['ss', 'll', 'tt'];var cc = arr.unshift('cc');console.log(cc);console.log(arr);var ii = arr.shift();console.log(ii);console.log(arr);</pre><h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><p>sort():按照升序数组项-即最小的值位于最前面,最大的值排在最后面。<br>在排序时,sort()方法会调用每个数组项的toString()转型方法,然后比较得到的字符串,以确定如何排序。即使数组中的每一项都是数值,sort()方法比较的也是字符串,因此会出现一下情况:</p><pre>var arr = ['a', 'b', 'c'];console.log(arr.sort());var arr1 = [2, 3, 7, 8];console.log(arr1.sort());console.log(arr1); // 原数组被改变</pre><p>为了解决上述问题,sort()可以接收一个比较函数作为参数,以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数,如果第一个参数应该位于第二个之前则返回一个负数,如果两个参数相等则返回0,如果第一个参数位于第二个之后则返回一个正数。<br>升序：</p><pre>function compare (value1, value2) {  if (value1 < value2) {    return -1;  } else if (value1 > value2) {    return 1;  } else {    return 0;  }};var arr2 = [23, 34, 37, 333];console.log(arr2.sort(compare));</pre>降序：<pre>function compare (value1, value2) {  if (value1 < value2) {    return 1;  } else if (value1 > value2) {    return -1;  } else {    return 0;  }};var arr = [89, 23, 45, 99];console.log(arr.sort(compare));</pre><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h2><p>reserve():反转数组项的顺序</p><pre>var arr = [12, 34, 546, 333];console.log(arr.reverse());console.log(arr);   //  原数组改变</pre><h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h2><p>concat()：将参数添加到原数组中。这个方法会先创建当前数组的一个副本,然后将接收到的参数添加这个副本的末尾,最后返回新构建的数组。在没有concat()方法传递参数的情况下,它只是复制当前数组并返回副本。</p><pre>var arr = [1, 5, 9];var ss = arr.concat(98, [23, 78]);console.log(ss);console.log(arr);   //  原数组未改变</pre>传入的不是数组,则直接把参数添加到原数组的后面,传入的数组也是添加到原数组的后面。传入的二维数组？<pre>var cv = arr.concat([0, [11, 89]]);console.log(cv);  //  [1, 5, 9, 0, [11, 89]];console.log(cv[4]); //  [11, 89]</pre><p>上述代码中,cv的第4项是一个包含两项的数组,也就是说concat方法只能将传入数组中的每一项添加到数组中,如果传入数组中有些项是数组,那么也会把这一数组项当作一项添加到cv中。</p><h2 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h2><p>slice(): 返回从原数组中指定开始下标和结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数,即要返回项的起始和结束位置。在只有一个参数的情况下,slice()方法返回从该参数指定位置开始到当前数组的末尾的所有项,如果有两个参数,该方法返回起始位置和结束位置之间的项-但不包括结束的位置的项。</p><pre>var arr = [1, 3, 4, 90, 81];var count = arr.slice(1);console.log(count);var count1 = arr.slice(1, 4);console.log(count1);var count2 = arr.slice(1, -2);console.log(count2);var count3 = arr.slice(-2, -1);console.log(count3);</pre>count只设置了一个参数,也就是起始下标为1,所以返回的数组为下标,(包括下标)开始到数组的最后。count2只设置了两个参数,返回起始下标(包括1)开始到终止下标(不包括4)。count3只设置了两个参数,终止下标为负数,当出现负数时,将负数加上数组的长度的值(5)来替换该位置的数,因此就是1开始到3。count4中两个参数都是负数,所以都加上数组的长度5转换成正数,因此相当于slice(3, 4);##  splice()splice()：很强大的数组方法,它有很多用法,可以实现删除，插入和替换。删除：可以删除任意数量的项,它只需指定两个参数,要删除的第一项的位置和要删除的项数,例如,splice(0, 2)会删除数组中的前两项。插入:可以向指定位置插入任意数量的项,只需提供两个参数：其实位置,0(要删除的项数)和要插入的项。例如,splice(2, 0, 4, 6)会从当前的位置2开始插入4和6。替换:可以向指定位置插入任意数量的项,且同时删除任意数量的项,只需指定3个参数,起始位置,要删除的项数和要插入的任意数量的项,插入的项数不必与删除的项数相等。例如,splice(2, 1, 4, 6)会删除当前数组位置2的项,然后再从位置2开始插入4和6.splice()方法始终都会返回一个数组,该数组中包含从原始数组中删除的项, 如果没有删除任何项,则返回一个空数值。<pre>var arr = [1, 3, 4, 9, 90, 45];var ss = arr.splice(0, 2);console.log(arr);console.log(ss);var ss1 = arr.splice(2, 0, 4, 6);console.log(arr); //原数组已经改变console.log(ss1);var count3 = arr.splice(1, 1, 2, 4);console.log(arr);console.log(count);</pre><h2 id="indexOf-和lastIndexOf"><a href="#indexOf-和lastIndexOf" class="headerlink" title="indexOf()和lastIndexOf()"></a>indexOf()和lastIndexOf()</h2><p>indexof():接收两个参数：要查找的项和(可选的)表示查找起点的位置的索引。其中,从数组的开头(位置0)开始向后查找。</p><p>lastIndexOf():接收两个参数：要查找的项和(可选的)表示查找起点位置的索引。其中,从数组的末尾开始向前查找。</p><p>这两个方法都返回要查找的项在数组中的位置,或者在没找到的情况下返回-1,在比较第一个参数与书中的每一项时,会使用全等操作符。</p><pre>var arr = [1, 2, 5, 9, 23, 5];console.log(arr.indexOf(5));console.log(arr.lastIndexOf(5));console.log(arr.indexOf(5, 2));console.log(arr.indexOf(5, 5));console.log(arr.lastIndexOf(5, 3));console.log(arr.indexOf(6));</pre><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h2><p>forEach(): 对数组进行遍历循环,对数组的每一项进行给定函数。这个方法没有返回值。参数function类型,默认有传参,参数分别为：遍历的数组内容，对应的数组索引，数组本身。</p><pre>var arr = ['wa', 'ng', 'li', 'si'];arr.forEach(function(currentValue, index, li){console.log(item);console.log(index);console.log(li);});</pre><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>map():指’映射’,对数组中的每一项运行给定函数,返回每次函数调用的结果组成的数组。</p><pre>var arr = [1, 3, 5, 8];var arr2 = arr.map(function(item) {return item * item;});console.log(arr2);</pre><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><p>fliter():’过滤’功能,数组中的每一项运行给定函数,返回满足过滤条件组成的数组。</p><pre>var arr = [1, 3, 5, 7, 9];var arr2 = arr.filter(function(x, index) {// console.log(x);// console.log(index);return index % 3 == 0 || x >= 6;});console.log(arr2);</pre><h2 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h2><p>every():判断数组中的每一项都是否满足条件,只有所有满足条件,才会返回true.</p><pre>var arr = [1, 2, 3, 4];var arr2 = arr.every(function(x) {  return x < 1;});console.log(arr2);var arr3 = arr.every(function(x) {  return x < 10;});console.log(arr3);</pre><h2 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h2><p>some(): 判断数组中是否存在满足条件的项,只要有一项满足条件,就会返回true.</p><pre>var arr = [1, 2, 3];var arr2 = arr.some(function(x) {  return x < 2;});console.log(arr2);var arr3 = arr.some(function(x) {  return x < 1;});console.log(arr3);</pre><h2 id="reduce-和reduceRight"><a href="#reduce-和reduceRight" class="headerlink" title="reduce()和reduceRight()"></a>reduce()和reduceRight()</h2><p>这两个方法都会实现迭代数组的所有项,然后构建一个最终返回的值。reduce()方法从数组的第一项开始,逐个遍历到最后。而reduceRight()则从数组的最后一项开始,向前遍历到第一项。<br>这两个方法都接收两个参数:一个在每一项上调用的函数和(可选的)作为归并基础的初始值。</p><p>传给reduce()和reduceRight()的函数接收4个参数:前一个值,当前值,项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项,因此第一个参数是数组的第一项,第二个参数就是数组的第一项。</p><pre>var arr = [1, 2, 3, 4];var sum = arr.reduceRight(function(p, c, i, a) {console.log('prev', p);console.log('c', c);console.log('i', i);console.log('a', a);    return p + c;}, 10);console.log(sum);</pre><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展运算符(spread)是三个点(…).它好比reset参数的逆运算,将一个数组转为用逗号分隔的参数序列。</p><pre>console.log(...[1, 2, 3]);console.log(1, ...[2, 3, 4], 5);[...document.querySelectorAll('div')]</pre><p>该运算符用于函数的调用</p><pre>function push(array, ...items) {  array.push(...items);    }function add(x, y) {  return x + y;}var numbers = [3, 4];add(...numbers) // 7</pre><p>上面代码中,array.push(…items)和add(…numbers)这两行,都是函数的调用,它们都使用了扩展运算符,该运算将一个数组,变为参数序列。</p><p>扩展运算符与正常的函数参数可以结合使用,非常灵活。</p><pre>function f(z, x, c, v) {}var args = [0, 1];f(-1, ...args, 2 ...[3]);</pre><p>扩展运算符后面还可以放置表达式。</p><p><code>const arr = [  ...(x &gt; 0 ? [&#39;a&#39;] : []),  &#39;b&#39;,    ];</code></p><p>如果扩展运算符后面是一个空数组,则不产生任何效果。</p><p><code>[...[], 1]</code></p><h2 id="替代数组的apply方法"><a href="#替代数组的apply方法" class="headerlink" title="替代数组的apply方法"></a>替代数组的apply方法</h2><p>由于扩展运算符可以展开数组,所以不再需要apply方法,将数组转为函数的参数了。</p><pre> // ES5的写法 function f(x, y, z) {}var args = [0, 1, 2];f.apply(null, args);//  ES6的写法function f(x, y, z) {   }var args = [0, 1, 2, 3];f(...args);</pre><p>下面是扩展运算符取代apply方法的一个实例的例子,应用Math.max方法,简化求出一个数组最大元素的写法。</p><pre>//  ES5的写法Math.max.apply(null, [14, 3, 77])// ES6的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77);</pre><p>上面的代码中,由于javascript不提供数组最大元素的函数,所以只能套用Math.max函数,将数组转为一个参数序列,然后求最大值。有了扩展运算符以后,就可以直接用Math.max了。</p><p>另一个例子是通用push函数,将一个数组添加到另一个数组的尾部。</p><pre>//  ES5的写法var arr1 = [0, 1, 2];var arr2 = [3, 4 ,5];Array.protype.push.apply(arr1, arr2);//  ES6的写法var arr1 = [1, 2, 3];var arr2 = [3, 4, 5];arr1.push(...arr2);</pre><p>上面代码的ES5写法中,push方法的参数不能是数组,所以只好通过apply方法变通使用push方法。</p><p>有了扩展运算符,就可以直接将数组传入push方法。</p><p><code>new (Date.bind.apply(Date, [null, 2015, 1, 1]));</code></p><p><code>new Date(...[2015, 1, 1]);</code></p><h2 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h2><h3 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h3><p>扩展运算符提供了数组合并的新写法</p><pre>//  [1, 2].concat(more)//  [1, 2, ...more]var arr1 = ['a', ,'c'];var arr2 =  ['c'];var arr3 = ['d', 'e'];//  ES5的合并数组arr1.concat(arr2, arr3);//  ['a', 'b', 'c', 'd', 'e']//  ES6的合并数组[...arr1, ...arr2, ...arr3]// ['a', 'b', 'c', 'd', 'e']</pre><h3 id="与结构赋值结合"><a href="#与结构赋值结合" class="headerlink" title="与结构赋值结合"></a>与结构赋值结合</h3><p>扩展运算符可以解构赋值结合起来,用于生成数组</p><pre>// ES5a = list[0], rest = list.slice(1)//  ES6[a, ...rest] = list</pre><p>下面是另一些例子</p><pre>const [first, ...rest] = [1, 2, 3, 4, 5];first   //  1rest    //  [2, 3, 4, 5]const   [first, ...rest] = [];first   //  undefinedrest    //  []const [first, ...rest] = ['foo'];console.log(first);console.log(rest);</pre><p>如果扩展运算符用于数组赋值,只能放在参数的最后一位,否则会报错。</p><pre>const [...butLast, last] = [1, 2, 4, 5];//  报错const [first, ...middle, last] = [1, 2, 4, 5];// 报错const [first, last,  ...middle] = [1, 2, 3, 4, 5];console.log(first);console.log(last);console.log(middle);//  不抱错</pre><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>javascript的函数只能返回一个值,如果需要返回多个值,只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法.</p><p> <code>var dateFields = readDateFields(database);</code><br>  <code>var d = new Date(...dateFields);</code></p><p> 上面代码从数据库取出一行数据,通过扩展运算符,直接将其传入构造函数的Date.</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p> 扩展运算符还可以将字符串转为真正的数组</p><pre> console.log([...'hello']); // [ "h", "e", "l", "l", "o" ]</pre>  上面的写法,有一个重要的好处,那就是能够正确识别32位的Unicode字符。 <pre> 'x\uD83D\uDE80y'.length // 4[...'x\uD83D\uDE80y'].length // 3</pre><p>上面代码的第一种写法，JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p><pre>function length(str) {  return [...str].length;}</pre><p><code>length(&#39;x\uD83D\uDE80y&#39;) // 3</code></p><p>凡是涉及到操作32位 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p><pre>let str = 'x\uD83D\uDE80y';str.split('').reverse().join('')// 'y\uDE80\uD83Dx'[...str].reverse().join('')// 'y\uD83D\uDE80x'</pre><p>上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。</p><h3 id="实现了-Iterator-接口的对象"><a href="#实现了-Iterator-接口的对象" class="headerlink" title="实现了 Iterator 接口的对象"></a>实现了 Iterator 接口的对象</h3><p>任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p><p><code>var nodeList = document.querySelectorAll(&#39;div&#39;);</code></p><p><code>var array = [...nodeList];</code></p><p>上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。</p><p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p><pre>let arrayLike = {  '0': 'a',  '1': 'b',  '2': 'c',  length: 3};// TypeError: Cannot spread non-iterable object.let arr = [...arrayLike];</pre><p>上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。</p><h3 id="Map-和-Set-结构，Generator-函数"><a href="#Map-和-Set-结构，Generator-函数" class="headerlink" title="Map 和 Set 结构，Generator 函数"></a>Map 和 Set 结构，Generator 函数</h3><p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p><pre>let map = new Map([  [1, 'one'],  [2, 'two'],  [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3]</pre><p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p><pre>var go = function*(){  yield 1;  yield 2;  yield 3;};[...go()] // [1, 2, 3]</pre><p>上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p><p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。</p><pre>var obj = {a: 1, b: 2};let arr = [...obj]; // TypeError: Cannot spread non-iterable object</pre><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p><p>下面是一个类似数组的对象,Array.from将他转为真正的数组。</p><pre> let arrays = {  '0': 'a',  '1': 'c',  length: 2};//  ES5var arr1 = [].slice.call(arrays);console.log(arr1);//  ES6let arr2 = Array.from(arrays);console.log(arr2);</pre><p>实际应用中,常见的类似数组的对象是DOM操作返回的NodeList集合,以及函数内部的arguments对象。</p><p>Array.from 都可以将他们转为真正的数组。</p><pre>// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) {  console.log(p);});// arguments对象function foo() {  var args = Array.from(arguments);}</pre><p>上面代码中,querySelectorAll方法返回的是一个类似数组的对象,可以将这个对象转为真正的数组,在使用forEach方法。</p><p>只要是部署了Iterator接口的数据结构,Array.from都能将其转为数组。</p><pre>console.log(Array.from('hello'));//  ["h", "e", "l", "l", "o"]let nameSet = new Set(['a', 'b']);console.log(Array.from(nameSet));// (2) ["a", "b"] </pre><p>上面代码中,字符串和Set结构都具有Iterator接口,因此可以被Array.from转为真正的数组。</p><p>如果参数是一个真正的数组,Array.from会返回一个一模一样的新数组。</p><pre>Array.from([1, 2, 3])// [1, 2, 3]值的提醒的是,扩展运算符(...)也可以将某些数据结构转为数组。// arguments对象function foo() {  var args = [...arguments];}// NodeList对象[...document.querySelectorAll('div')]</pre><p>扩展运算符背后调用的是遍历器接口(Symbol.iterator),如果一个对象没有部署这个接口,就无法转换。Array.from方法还可以支持数组的对象。所谓类似数组的对象,本质特征只有一点,即必须有length属性。因此,任何length属性的对象,都可以通过Array.from方法转为数组,而此时扩展运算符就无法转换。</p><pre> Array.from({ length: 3 });// [ undefined, undefined, undefined ]</pre><p>上面的代码中,Array.from返回了一个具有三个成员的数组,每个位置的值都是undefind。扩展运算符转换不了这个对象。</p><p>对于还没有部署该方法的浏览器,可以用Array.prototype.slice方法替代。</p><pre>const toArray = (() =>  Array.from ? Array.from : obj => [].slice.call(obj))();</pre><p>Array.from 还可以接受第二个参数,作用类似与数组的map方法,用来对每个元素进行处理,将处理后的值放入返回的数组。</p><pre>Array.from(arrayLike, x => x * x);// 等同于Array.from(arrayLike).map(x => x * x);Array.from([1, 2, 3], (x) => x * x)// [1, 4, 9]console.log(Array.from([1, 2, 3], (x) => x * x))</pre><p>下面的例子是取出一组Dom节点的文本内容。</p><pre>let spans = document.querySelectorAll('span.name');// map()let names1 = Array.prototype.map.call(spans, s => s.textContent);// Array.from()let names2 = Array.from(spans, s => s.textContent)</pre><p>下面的例子将数组中布尔值为false的成员转为0。</p><pre> console.log(Array.from([1, , , 2], (n) => n || 0));</pre><p> 另一个例子是返回各种数据的类型。</p><pre>function typeOf () {  return Array.from(arguments, value => typeof value)}console.log(typeOf(null, [], NaN))//  ["object", "object", "number"]</pre><p>如果map函数里面用到了this关键字,还可以传入Array.from的第三个参数,用来绑定this.</p><p>Array.from()可以将各种值转为真正的数组,并且还提供map功能。这实际上意味着,只要有一个原始的数据结构,你就可以先对它的值进行处理,然后专程规范的数组结构,进而就可以使用数量众多的数组方法。</p><pre>console.log(Array.from({ length: 2}, () => 'jack'))// ['jack', 'jack']</pre><p>上面的代码中,Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法非常灵活。</p><p>Array.from()的另一个应用是,将字符串转为数组,然后返回字符串的长度。因为它能正确处理各种Unicode字符,可以避免Javascript将大于\uFFFF的Unicode字符,算做两个字符的bug.</p><pre>function countSymbols(string) {  return Array.from(string).length;}</pre><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p>Array.of方法用于将一组值,转换为数组。</p><pre>console.log(Array.of(3, 11, 8));console.log(Array.of(1));console.log(Array.of(1).length);</pre><p>这个方法的目的,是弥补数组构造函数的Array()的不足.因为参数个数的不同,会导致Array()行为差异。</p><pre>Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8]</pre><p>上面的代码中,Array方法没有参数,一个参数,三个参数时,返回的结果都不一样。只有当参数不小于2个时,Array()才会返回由参数组成的新数组,参数个数只有一个时,实际上是指定数组的长度。</p><p>Array.of基本上可以替代Array()或new Array(),并且不存在由于参数不同而导致的重载.它的行为非常统一。</p><pre>Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2]</pre><p>Array.of总是返回参数组成的数组。如果没有参数,就返回一个空数组。</p><p>Array.of方法可以用下面的代码模拟实现。</p><pre>function ArrayOf(){  return [].slice.call(arguments);}</pre><h3 id="数组实例的-copyWithin"><a href="#数组实例的-copyWithin" class="headerlink" title="数组实例的 copyWithin()"></a>数组实例的 copyWithin()</h3><p>数组实例的copyWithin方法,在当前数组内部,将指定位置的成员复制到其他位置(会覆盖原有成员),然后返回当前数组。也就是说,使用这个方法,会修改当前数组。</p><pre> Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。  - target(必需): 从该位置开始替换数据。  - start(可选): 从该位置开始读取数据,默认是0.如果为负值,表示倒数。  - end(可选):到该位置前停止读取数据,默认等于数组长度,如果为负值,表示倒数。 这三个参数都应该是数值,如果不是,会自动转换为数值。  </pre> <pre>console.log([1, 2, 3].copyWithin(0, 1));//  [2, 3, 3]</pre><p>上面的代码表示将从3号位直到数组结束的成员(4和5),复制到从0号位开始的位置,结果覆盖了原来了1和2.</p><p>下面是更多的例子</p><pre>console.log([1, 2, 3].copyWithin(0, 1, 2))//  [2, 2, 3]// -2相当于3号位，-1相当于4号位console.log([1, 2, 3, 4, 5].copyWithin(0, -2, -1));[4, 2, 3, 4, 5]// 没有理解如下:// 将3号位复制到0号位[].copyWithin.call({length: 5, 3: 1}, 0, 3)// {0: 1, 3: 1, length: 5}// 将2号位到数组结束，复制到0号位var i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5]</pre><h3 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h3><p>数组实例的find方法,用于找出第一个符合条件的数组成员.它的参数是一个回调函数,所有的数组成员依次执行该回调函数,直到找出第一个返回值为true的成员,然后返回该成员。如果没有符合条件,则返回undefined.</p><pre>let ss = [1, 4, -5, 10].find((n) => n < 0)console.log(ss);// -5</pre><p>上面代码找出数组中第一个小于0的成员。</p><pre>let arr = [1, 4, -5, 10].find(function(value, index, arr) {  return value > 9;})console.log(arr);//  9</pre><p>上面代码中,find方法的回调函数可以接受三个参数,以此为当前的值,当前的位置和原数组。</p><p>数组实例的findIndex方法的用法与find方法类似,返回第一个符合条件的数组成员的位置,如果所有成员都不符合条件,则返回-1.</p><pre>let arr = [1, 5, 10, 15].findIndex(function(value, index, arr) {  return value > 9;})console.log(arr)// 2</pre><p>这两个方法都可以接受第二个参数,用来绑定回调函数的this对象<br>另外,这两个方法都可以发现NaN,弥补了数组的IndexOf方法的不足。</p><pre>[NaN].indexOf(NaN)// -1[NaN].findIndex(y => Object.is(NaN, y))// 0</pre><p>上面的代码中,indexOf方法无法识别数组的NaN成员,但是findIndex方法可以借助Object.is方法做到。</p><h3 id="数组实例的fill"><a href="#数组实例的fill" class="headerlink" title="数组实例的fill()"></a>数组实例的fill()</h3><pre>let arr = ['a', 'b', 'c'];console.log(arr.fill(7));//  [7, 7, 7]console.log(new Array(3).fill(7));//  [7, 7, 7]</pre><p>上面代码表明,fill方法用于空数组的初始化非常方便.数组中已有的元素,会被全部抹去。</p><p>fill方法还可以接受第二个参数和第三个参数,用于指定填充起始位置和结束位置.</p><pre>let arr = ['a', 'b', 'c'];console.log(arr.fill(7, 1, 2));//  ["a", 7, "c"]</pre><p>上面代码表示,fill方法从1号位开始,向原数组填充7,到2号位之前结束。</p><h3 id="数组实例的entries-keys-和values"><a href="#数组实例的entries-keys-和values" class="headerlink" title="数组实例的entries(),keys()和values()"></a>数组实例的entries(),keys()和values()</h3><p>ES6提供了三个新的方法–entries(),keys()和values()–用于遍历数组.它们都返回一个遍历器对象(详见《Iterator》一章),可以用for…of循环进行遍历,唯一的区别是keys()是对键名的遍历,entries()是对键值对的遍历。</p><pre>for (let index of ['a', 'b'].keys()) {  console.log(index);}// 0 1for (let elem of ['a', 'b'].values()) {  console.log(elem);}//  ["a","b"].values(...) is not iterablefor (let [index, elem] of ['a', 'b'].entries()) {  console.log(index, elem);}//  0 "a"//  1 "b"</pre><p>如果不使用for…of循环,可以手动调用循环遍历器对象的next方法,进行遍历。</p><pre>let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value);console.log(entries.next().value);console.log(entries.next().value);//  [0, "a"]//  [1, "b"]//  [2, "c"]</pre><h3 id="数组实例的includes"><a href="#数组实例的includes" class="headerlink" title="数组实例的includes()"></a>数组实例的includes()</h3><p>Array.prototype.includes方法返回一个布尔值,表示某个数组是否包含给定的值,与字符串的includes方法类似。ES2016引入了该方法。</p><pre>console.log([1, 2, 3].includes(2));console.log([1, 2, 3].includes(4));console.log([1, 2, NaN].includes(NaN)); //  true//  false//  true</pre><p>该方法的第二个参数的表搜索的起始位置,默认为0。如果第二个参数为负数,则表示倒数的位置。如果这时它大于数组的长度(比如第二个参数为-4,但数组长度为3)则会重置它从0开始。</p><pre>console.log([1, 2, 3].includes(3, 3)); // falseconsole.log([1, 2, 3].includes(3, -1)); // true</pre><p>没有该方法之前,我们通常使用数组的indexOf方法,检查是否包含某个值。</p><pre>if (arr.indexOf(el) !== -1) {}</pre><p>indexOf方法有两个缺点,一是不够语义化,它的含义是找到参数值的第一个出现位置,所以要去比较是否不等于-1,表达起来不够直观。二是,它内部使用严格相等运算符(===)进行判断,这会导致NaN的误判。</p><pre>[NaN].index(NaN)//  -1</pre>includes使用的是不一样的判断算法,就没有这个问题。<pre>[NaN].includes(NaN)//  true</pre>下面代码用来检查当前环境是否支持该方法,如果不支持,部署一个简易的替代版本。<pre>const = contains = (() =>   Array.prototype.includes ? (arr, value) => arr.includes(value) : (arr, value) => arr.some(el => el ===value))();  contains(['foo', 'bar'], 'baz');  //  false</pre><p>另外,Map和Set数据结构有一个has方法,需要注意includes区分。</p><pre>  -Map结构的has方法,用来查找键名的,比如Map.prototype.has(key)  webkMap.prototype.has(key),Reflect.has(target, prototypeKey).  -Set结构的has方法,用来查找值的,比如Set.prototype.has(value),  WeakSet.prototype.has(value).</pre><h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><p>数组的空位指,数组的某一位置没有任何值。比如,Array构造函数返回的数组都是空位。</p><pre>console.log(Array(3))//  [empty × 3]</pre><p>上面代码中,Array(3)返回一个具有3个空位的数组。<br>注意,空位不是undefined,一个位置等于undefined,依然是有值的。空位是没有任何值,in运算符可以说明这一点。</p><pre>console.log(0 in [undefined, undefined, undefined]) //  trueconsole.log(0 in [, , ,]) //  false</pre><p>上面代码说明,第一个数组的0号位置是有值的,第二个数组的0号位置。<br>ES5对空位的处理,已经很不一致,大多数情况下会忽略空位。</p><pre>  - forEach(), filter(), every()和some()都会跳过空位。  - map()会跳过空位,但会保留这个值  - join()和toString()会将空位视为undefined,而undefined和null会被处理成空字符串。</pre><pre>//  forEach方法[, 'a'].forEach((x, i) => {  console.log(i); //  1});//  filter方法 console.log(['a', , 'b'].filter(x => true)); //   ["a", "b"]//  every方法console.log([, 'a'].every(x => x === 'a')) // true//  some方法console.log([, 'a'].some(x => x!== 'a'))  //false//  map方法console.log([, 'a'].map(x => 1)) // [empty × 1, 1]//  join方法console.log([, 'a', undefined, null].join('#')) //  #a##//  toString方法console.log([, 'a', undefined, null].toString()) //  ,a,, </pre><p>ES6则是明确将空位转为undefined.<br>Array.from方法会将数组的空位,转为undefined,也就是说,这个方法不会忽略空位。</p><pre> console.log(Array.from(['a', , 'b'])) // ["a", undefined, "b"]</pre><p>扩展运算符(…[‘a’ , , ‘b’])也会把空位转为undefined.</p><pre>console.log([...['a', , 'b']]) // ["a", undefined, "b"]</pre><p>copyWithin()会连空位一起拷贝。</p><pre>console.log([, 'a', 'b', ,].copyWithin(2, 0))//  [empty × 1, "a", empty × 1, "a"]</pre><p>fill()会将空位视为正常的数组位置。</p><pre>console.log(new Array(3).fill('a'))</pre><p>for…of循环也会遍历空位。</p><pre>let arr = [, ,];for (let i of arr) {  console.log(i); //  undefined*2}</pre><p>上面代码中,数组arr有两个空位,for…of并没有忽略他们。如果改成map方法遍历,空位是会跳过。<br>entries(),keys(),values(),find()和findIndex()会将空位处理成undefined.</p><pre>//  entries()console.log([...[, 'a'].entries()]) //  [0, undefined] [1, "a"]//  keys()console.log([...[, 'a'].keys()])  //  [0, 1]//  values()console.log([...[,'a'].values()] ) // [(intermediate value),"a"].values(...) is not iterable//  find()console.log([, 'a'].find(x => true)) //  undefined//  findIndex()console.log([, 'a'].findIndex(x => true)) //  0</pre><p>由于空位的处理规则非常不统一,所以建议避免出现空位。</p><p>纯手打,没有任何机打痕迹。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;join-ES5&quot;&gt;&lt;a href=&quot;#join-ES5&quot; class=&quot;headerlink&quot; title=&quot;join() ES5&quot;&gt;&lt;/a&gt;join() ES5&lt;/h2&gt;&lt;p&gt;join(speparator):将数组的元素组起一个字符串,spearator为分隔符,省略的话则用默认用逗号为分隔符,该方法只接收一个参数,即分隔符。&lt;/p&gt;
&lt;pre&gt;
  var arr = [1,2,3];
  console.log(arr.join());
  console.log(arr.join(&#39;-&#39;));
  console.log(arr);
&lt;/pre&gt;
通过join()方法可以重复字符串,只需传入字符串以及重复的次数,就能返回重复后的字符串,函数如下:
&lt;pre&gt;
function repeatString(str, n) {
  console.log(new Array(n + 1).join(str));
  return new Array(n + 1).join(str);
};
console.log(repeatString(&#39;abc&#39;, 3)); // abcabcabc
&lt;/pre&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://tyty.me/tags/javascript/"/>
    
      <category term="Array方法" scheme="https://tyty.me/tags/Array%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>&#39;面试题目&#39;</title>
    <link href="https://tyty.me/2017/08/31/%E9%9D%A2%E8%AF%95/"/>
    <id>https://tyty.me/2017/08/31/面试/</id>
    <published>2017-08-30T16:00:00.000Z</published>
    <updated>2017-12-22T04:11:23.821Z</updated>
    
    <content type="html"><![CDATA[<p>2017年08月31日又开始上班了,我总结下我面试的一些题目,当然有些我没有回答上来。<br><a id="more"></a><br>面试的第一天天气很不好,下着大雨,今天要面试三家公司,公司都相距很远,面试的第一家是做管理系统的后台是用php的,到了以后填写了相关信息,面试岗位,等等。给了一份面试题,上面就三个大题,第一道题目是关于迭代。</p><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>用迭代实现1+2+3+4+5+…+n求值<br>写的时候就忘了迭代与循环的什么关系这道题没有写出来<br>回去以后就查了查迭代与循环的关系<br>迭代是循环的一种。</p><p><pre><br>  var n = 100;<br>  var s = 0;<br>  for (var i = 1; i &lt;= n; i++ ) {<br>    s += i;<br>    console.log(s)<br>  }<br></pre></p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>第二道题是类似杨辉三角形<br>也没有做出来,具体题目我不大记得了,等我回想然后再去上传题目</p><p>##题目三<br>第三道题目类似有个字符串把他进行倒叙输出再把<br>首字母转换为大写。</p><p><pre><br>var reverse = function (str) {<br>  return str.split(‘ ‘).reverse().join(‘ ‘);<br>}<br>function titleCase(str) {<br>  str = str.toLowerCase().split(‘ ‘);<br>  for (var i in str) {<br>     str[i] = str[i].replace(str[i].charAt(0), str[i].charAt(0).toUpperCase());<br>    };<br>return str.join(‘ ‘);<br>}<br>console.log(titleCase(reverse(‘this is apple’))); //“Hello World” 著作权归作者所有。<br></pre><br>三道题一道题目也没有做出来,内心很难受,就意识到基础知识的薄弱,我也希望有同学看到我的面试经历,自己会去思考自己哪方面的知识稍微薄弱,可以去加深下。</p><p>这是第一家面试公司,结果失败,很糟糕接下来的面试说实话都不想去了,但是已经约了人家了就硬着头皮去了。<br>——————————————第一家结束—————————————-<br>第二家开始,第二家做的是一些汽车的网站。<br>第二家面试的题目</p><h2 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h2><p>面试的技术跟我说了这样一个问题,比如说现在有这样一个问题项目已经完成并打包上线,但是出现个问题比如说有个汽车的价格写的不对,运营方面就直接修改了线上的价格,但是这样就出现了一个问题,如果运营直接把线上的修改了就会和本地的产生了差异,怎么才能不出现这个问题(大概是这个意思),那我就说,先给用户去看,如果没有问题了,再去把本地的去做更改,再去打包,部署到线上。然后他就点点头。(?).</p><h2 id="题目二-1"><a href="#题目二-1" class="headerlink" title="题目二"></a>题目二</h2><p>说说git与svn的区别<br>我没有回答出来,面试官告诉我的是git是分布式的自己可以玩,而svn不能自己玩(大概就是这个意思)<br>回去百度了下<br>答案如下:<br>1.GIT是分布式的，SVN不是：</p><p>这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。如果你能理解这个概念，那么你就已经上手一半了。需要做一点声明，GIT并不是目前第一个或唯一的分布式版本控制系统。还有一些系统，例如Bitkeeper, Mercurial等，也是运行在分布式模式上的。但GIT在这方面做的更好，而且有更多强大的功能特征。</p><p>GIT跟SVN一样有自己的集中式版本库或服务器。但，GIT更倾向于被使用于分布式模式，也就是每个开发人员从中心版本库/服务器上chect out代码后会在自己的机器上克隆一个自己的版本库。可以这样说，如果你被困在一个不能连接网络的地方时，就像在飞机上，地下室，电梯里等，你仍然能够提交文件，查看历史版本记录，创建项目分支，等。对一些人来说，这好像没多大用处，但当你突然遇到没有网络的环境时，这个将解决你的大麻烦。</p><p>同样，这种分布式的操作模式对于开源软件社区的开发来说也是个巨大的恩赐，你不必再像以前那样做出补丁包，通过email方式发送出去，你只需要创建一个分支，向项目团队发送一个推请求。这能让你的代码保持最新，而且不会在传输过程中丢失。GitHub.com就是一个这样的优秀案例。</p><p>有些谣言传出来说subversion将来的版本也会基于分布式模式。但至少目前还看不出来。</p><p>2.GIT把内容按元数据方式存储，而SVN是按文件：</p><p>所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。如果你把.git目录的体积大小跟.svn比较，你会发现它们差距很大。因为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。</p><p>3.GIT分支和SVN的分支不同：</p><p>分支在SVN中一点不特别，就是版本库中的另外的一个目录。如果你想知道是否合并了一个分支，你需要手工运行像这样的命令svn propget svn:mergeinfo，来确认代码是否被合并。感谢Ben同学指出这个特征。所以，经常会发生有些分支被遗漏的情况。</p><p>然而，处理GIT的分支却是相当的简单和有趣。你可以从同一个工作目录下快速的在几个分支间切换。你很容易发现未被合并的分支，你能简单而快捷的合并这些文件。</p><p>Git logo</p><p>4.GIT没有一个全局的版本号，而SVN有：</p><p>目前为止这是跟SVN相比GIT缺少的最大的一个特征。你也知道，SVN的版本号实际是任何一个相应时间的源代码快照。我认为它是从CVS进化到SVN的最大的一个突破。因为GIT和SVN从概念上就不同，我不知道GIT里是什么特征与之对应。如果你有任何的线索，请在评论里奉献出来与大家共享。</p><p>更新：有些读者指出，我们可以使用GIT的SHA-1来唯一的标识一个代码快照。这个并不能完全的代替SVN里容易阅读的数字版本号。但，用途应该是相同的。</p><p>5.GIT的内容完整性要优于SVN：</p><p>GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p>说说webpack与grunt或gulp的异同<br>同:我回答的是这三个都是打包自动化工具,都是为了提升工作效率.<br>异:我回答的是webpack可以对一些图片或者js css等进行打包压缩,而gulp或grunt不能。<br>grunt与gulp是自动化工具,而webpack是前端模块化工具。</p><p>##题目四<br>说说var和let的区别<br>我回答的是作用域的不一样,在作用域外var可以在作用域内访问到而let不可以,let只能在那里定义在那里访问。<br>使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；<br>使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；<br>使用const声明的是常量，在后面出现的代码中不能再修改该常量的值。</p><h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><p>说一个div元素距离顶部为10像素在其内部也有个div距离上一个div的距离也是10像素,那么内部的div元素距离顶部是多少像素。<br>我回答的是20像素,面试官告诉我是10像素,我问他为什么他说这是一个坑。</p><h2 id="题目五-1"><a href="#题目五-1" class="headerlink" title="题目五"></a>题目五</h2><p>说下vue是不是适合像政府类的网站<br>我回答的是不适合,因为我觉得vue是轻量级的,而政府类的一般都是内容比较多的,特别的臃肿,所以我觉得不太适合。</p><h2 id="题目五-2"><a href="#题目五-2" class="headerlink" title="题目五"></a>题目五</h2><p>用jquery和vue分别实现导航高亮显示<br>jquery就是选择元素当鼠标点击时当前的元素给他添加一个class样式,而他的兄弟节点进行removClass保持正常。<br>vue我回答的不好,或者说不对。就不说了。</p><h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><p>第二家公司大体就是这样,最后跟我说一两天给我消息,我就走了,走的时候忘了拿伞又回去拿伞碰到了他们老板,他们老板让我去他办公司聊聊,聊了聊发现他认识我以前的同事,最后问了我薪资要求.(乌龙)</p><p>—————————————–第二家结束——————————————<br>赶去第三家,第三家比较远,做公交车,坐了一个小时多点,到了地方进行简单的自我介绍.<br>开始面试的不是技术,就稍微问了我基本情况,过了一会让我进行了电话面试。</p><h2 id="题目一-2"><a href="#题目一-2" class="headerlink" title="题目一"></a>题目一</h2><p>说下怎么jquery怎么跨域<br>讲道理之前看了跨域的实现方式有8种,我就回答可能是用的最多的一种jsonp</p><h2 id="题目二-2"><a href="#题目二-2" class="headerlink" title="题目二"></a>题目二</h2><p>vue和jquery的区别<br>我回答的是:我觉得vue他本身是框架,而jquery他是库,框架他制定了一种自己的规则,你想要使用他你就要去按照他的方式去使用,而jquery他是一个库,引入就可以使用,我觉得他们两个不能进行比较。</p><p>过了一会他们老板进来了问了我平常喜欢做什么,我就说喜欢coding(抖个机灵),然后就问了一些个人情况,最后问我,面试几家了,我说好几家了(其实想博一下)然后跟我说来我们公司吧,其他的就不用去了,我说我考虑下,跟我说不用考虑了,我说你们公司现在前端多少人,他说都是新招的,我又问了他们用的什么框架,用的是can我不知道。<br>然后跟我说,他是从阿里出来的,然后又是说了马云爸爸的激励人生的名言。</p><p>回去以后五点左右,开始继续投递,然后约了第二天面试的公司。。。<br>————————————–第三家结束———————————————<br>第二天去了离我住的很近的一个公司,但是要求很多,心理很虚.<br>第一家公司题目</p><h2 id="题目一-3"><a href="#题目一-3" class="headerlink" title="题目一"></a>题目一</h2><p>等我整理下再来补充</p><p>——————————————第四家结束—————————————–<br>第五家<br>简单问了问你用什么编辑器,我说了某某,然后跟我说了公司的基本情况,然后等等,公司是用vue的,然后给他看了看我打包的app但流畅性不好,最后问了问薪资,等等。</p><p>————————————第五家结束———————————————–<br>第六家</p><h2 id="题目一-4"><a href="#题目一-4" class="headerlink" title="题目一"></a>题目一</h2><p>说说怎么让一个函数怎么页面一加载就立即执行,我说了让window.onload等于那个函数,这样页面一加载函数就会立即执行,我问他这样可不可以,他说不行,我又说写个立即执行函数可以吗,他说也不行。</p><h2 id="题目二-3"><a href="#题目二-3" class="headerlink" title="题目二"></a>题目二</h2><p>问了我关于怎么让页面一加载就调用数据,说实话我是不理解的。</p><h2 id="题目三-1"><a href="#题目三-1" class="headerlink" title="题目三"></a>题目三</h2><p>问了html接近满了,说实话很心虚(当时写的有点多,呵呵)。友情提示:关于技能方面不要写那么多,那么满。</p><h2 id="题目五-3"><a href="#题目五-3" class="headerlink" title="题目五"></a>题目五</h2><p>问了我psd图能还原多少,我说我没有办法做到100%还原。。。GG<br>还有问了我看了什么书我说权威指南与你不知道的javascript他说权威指南不好….?(为啥)<br>还有几个但是我给忘了,想起来再补充。<br>人事给我说了薪资,等等一些方面,说给我打电话。</p><p>——————————————-面试结束——————————————<br>最后我去了第三家,因为离我很近, 而且技术方面我觉得可能更合适我。<br>就先这样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年08月31日又开始上班了,我总结下我面试的一些题目,当然有些我没有回答上来。&lt;br&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://tyty.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>&#39;Promise&#39;</title>
    <link href="https://tyty.me/2017/08/10/promise/"/>
    <id>https://tyty.me/2017/08/10/promise/</id>
    <published>2017-08-10T02:54:48.000Z</published>
    <updated>2017-12-22T04:11:23.821Z</updated>
    
    <content type="html"><![CDATA[<h2>1.Promise的立即执行性 </h2><pre><code>var p = new Promise(function(resolve, reject){  console.log(&quot;create a promise&quot;);  resolve(&quot;success&quot;);});console.log(&quot;after new Promise&quot;);p.then(function(value){  console.log(value);});</code></pre><p>控制台输出：</p><pre><code>&quot;create a promise&quot;&quot;after new Promise&quot;&quot;success&quot;</code></pre><p>Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。<br><a id="more"></a></p><h2>2.Promise 三种状态</h2><pre><code>var p1 = new Promise(function(resolve,reject){  resolve(1);});var p2 = new Promise(function(resolve,reject){  setTimeout(function(){    resolve(2);    }, 500);      });var p3 = new Promise(function(resolve,reject){  setTimeout(function(){    reject(3);    }, 500);      });console.log(p1);console.log(p2);console.log(p3);setTimeout(function(){  console.log(p2);}, 1000);setTimeout(function(){  console.log(p3);}, 1000);p1.then(function(value){  console.log(value);});p2.then(function(value){  console.log(value);});p3.catch(function(err){  console.log(err);});</code></pre><p>控制台输出：</p><pre><code>Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 1}Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined}Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined}123Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 2}Promise {[[PromiseStatus]]: &quot;rejected&quot;, [[PromiseValue]]: 3}</code></pre><p>Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。</p><p>p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个setTimeout函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。</p><h2>3.Promise 状态的不可逆性</h2><pre><code>var p1 = new Promise(function(resolve, reject){  resolve(&quot;success1&quot;);  resolve(&quot;success2&quot;);});var p2 = new Promise(function(resolve, reject){  resolve(&quot;success&quot;);  reject(&quot;reject&quot;);});p1.then(function(value){  console.log(value);});p2.then(function(value){  console.log(value);});</code></pre><p>控制台输出：</p><pre><code>&quot;success1&quot;&quot;success&quot;</code></pre><p>Promise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中resolve(“success2”)并不能将p1的值更改为success2，p2中reject(“reject”)也不能将p2的状态由resolved改变为rejected.</p><h2>4.链式调用</h2><pre><code>var p = new Promise(function(resolve, reject){  resolve(1);});p.then(function(value){               //第一个then  console.log(value);  return value*2;}).then(function(value){              //第二个then  console.log(value);}).then(function(value){              //第三个then  console.log(value);  return Promise.resolve(&apos;resolve&apos;); }).then(function(value){              //第四个then  console.log(value);  return Promise.reject(&apos;reject&apos;);}).then(function(value){              //第五个then  console.log(&apos;resolve: &apos;+ value);}, function(err){  console.log(&apos;reject: &apos; + err);})</code></pre><p>控制台输出：</p><pre><code>12undefined&quot;resolve&quot;&quot;reject: reject&quot;</code></pre><p>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：</p><p>return 一个同步的值 ，或者 undefined（当没有返回一个有效值时，默认返回undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。<br>return 另一个 Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。<br>throw 一个同步异常，then方法将返回一个rejected状态的Promise, 值是该异常。<br>根据以上分析，代码中第一个then会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个then输出的值是2。第二个then中没有返回值，因此将返回默认的undefined，于是在第三个then中输出undefined。第三个then和第四个then中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个then中成功的回调函数和第五个then中失败的回调函数处理。</p><h2>5.Promise then() 回调异步性</h2><pre><code>var p = new Promise(function(resolve, reject){  resolve(&quot;success&quot;);});p.then(function(value){  console.log(value);});console.log(&quot;which one is called first ?&quot;);</code></pre><p>控制台输出：</p><pre><code>&quot;which one is called first ?&quot;&quot;success&quot;</code></pre><p>Promise接收的函数参数是同步执行的，但then方法中的回调函数执行则是异步的，因此，”success”会在后面输出。</p><h2>6.Promise 中的异常</h2><pre><code>var p1 = new Promise( function(resolve,reject){  foo.bar();  resolve( 1 );      });p1.then(  function(value){    console.log(&apos;p1 then value: &apos; + value);  },  function(err){    console.log(&apos;p1 then err: &apos; + err);  }).then(  function(value){    console.log(&apos;p1 then then value: &apos;+value);  },  function(err){    console.log(&apos;p1 then then err: &apos; + err);  });var p2 = new Promise(function(resolve,reject){  resolve( 2 );    });p2.then(  function(value){    console.log(&apos;p2 then value: &apos; + value);    foo.bar();  },   function(err){    console.log(&apos;p2 then err: &apos; + err);  }).then(  function(value){    console.log(&apos;p2 then then value: &apos; + value);  },  function(err){    console.log(&apos;p2 then then err: &apos; + err);    return 1;  }).then(  function(value){    console.log(&apos;p2 then then then value: &apos; + value);  },  function(err){    console.log(&apos;p2 then then then err: &apos; + err);  });</code></pre><p>控制台输出：</p><pre><code>p1 then err: ReferenceError: foo is not definedp2 then value: 2p1 then then value: undefinedp2 then then err: ReferenceError: foo is not definedp2 then then then value: 1</code></pre><p>Promise中的异常由then参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，then返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级then的回调函数是交替执行的 ，这正是由Promise then回调的异步性决定的。</p><h2>7.Promise.resolve()</h2><pre><code>var p1 = Promise.resolve( 1 );var p2 = Promise.resolve( p1 );var p3 = new Promise(function(resolve, reject){  resolve(1);});var p4 = new Promise(function(resolve, reject){  resolve(p1);});console.log(p1 === p2); console.log(p1 === p3);console.log(p1 === p4);console.log(p3 === p4);p4.then(function(value){  console.log(&apos;p4=&apos; + value);});p2.then(function(value){  console.log(&apos;p2=&apos; + value);})p1.then(function(value){  console.log(&apos;p1=&apos; + value);})</code></pre><p>控制台输出：</p><pre><code>truefalsefalsefalsep2=1p1=1p4=1</code></pre><p>Promise.resolve(…)可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的then最先调用，但在控制台上是最后输出结果的呢？因为p4的resolve中接收的参数是一个Promise对象p1，resolve会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。</p><h2>8.resolve vs reject</h2><pre><code>var p1 = new Promise(function(resolve, reject){  resolve(Promise.resolve(&apos;resolve&apos;));});var p2 = new Promise(function(resolve, reject){  resolve(Promise.reject(&apos;reject&apos;));});var p3 = new Promise(function(resolve, reject){  reject(Promise.resolve(&apos;resolve&apos;));});p1.then(  function fulfilled(value){    console.log(&apos;fulfilled: &apos; + value);  },   function rejected(err){    console.log(&apos;rejected: &apos; + err);  });p2.then(  function fulfilled(value){    console.log(&apos;fulfilled: &apos; + value);  },   function rejected(err){    console.log(&apos;rejected: &apos; + err);  });p3.then(  function fulfilled(value){    console.log(&apos;fulfilled: &apos; + value);  },   function rejected(err){    console.log(&apos;rejected: &apos; + err);  });</code></pre><p>控制台输出：</p><pre><code>p3 rejected: [object Promise]p1 fulfilled: resolvep2 rejected: reject</code></pre><p>Promise回调函数中的第一个参数resolve，会对Promise执行”拆箱”动作。即当resolve的参数是一个Promise对象时，resolve会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；p2”拆箱”后，获取到Promise对象的状态是rejected，因此rejected回调被执行。但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。</p><h2><a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="noopener">转载自掘金</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;1.Promise的立即执行性 &lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var p = new Promise(function(resolve, reject){
  console.log(&amp;quot;create a promise&amp;quot;);
  resolve(&amp;quot;success&amp;quot;);
});

console.log(&amp;quot;after new Promise&amp;quot;);

p.then(function(value){
  console.log(value);
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;控制台输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;create a promise&amp;quot;
&amp;quot;after new Promise&amp;quot;
&amp;quot;success&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。&lt;br&gt;
    
    </summary>
    
    
      <category term="web" scheme="https://tyty.me/tags/web/"/>
    
      <category term="ES6" scheme="https://tyty.me/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>css3</title>
    <link href="https://tyty.me/2017/07/22/px%E8%BD%ACrem/"/>
    <id>https://tyty.me/2017/07/22/px转rem/</id>
    <published>2017-07-22T05:57:48.000Z</published>
    <updated>2017-12-22T04:11:23.821Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Sass基础——Rem与Px的转换</code></pre><p>rem是CSS3中新增加的一个单位值，他和em单位一样，都是一个相对单位。不同的是em是相对于元素的父元素的font-size进行计算；rem是相对于根元素html的font-size进行计算。这样一来rem就绕开了复杂的层级关系，实现了类似于em单位的功能。</p><h2>Rem的使用</h2><p>前面说了em是相对于其父元素来设置字体大小的，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小，在我们多次使用时，就会带来无法预知的错误风险。而rem是相对于根元素<html>，这样就意味着，我们只需要在根元素确定一个参考值，这个参考值设置为多少，完全可以根据您自己的需求来定。<br><a id="more"></a><br>假设就使用浏览器默认的字号16px，来看一些px单位与rem之间的转换关系：</html></p><pre><code>|  px  |     rem       |------------------------|  12  | 12/16 = .75   ||  14  | 14/16 = .875  ||  16  | 16/16 = 1     ||  18  | 18/16 = 1.125 ||  20  | 20/16 = 1.25  ||  24  | 24/16 = 1.5   ||  30  | 30/16 = 1.875 ||  36  | 36/16 = 2.25  ||  42  | 42/16 = 2.625 ||  48  | 48/16 = 3     |-------------------------        </code></pre><p>如果你要设置一个不同的值，那么需要在根元素<html>中定义，为了方便计算，时常将在<html>元素中设置font-size值为62.5%:</html></html></p><pre><code>html {    font-size: 62.5%; /* 10 ÷ 16 × 100% = 62.5% */}</code></pre><p>相当于在<html>中设置font-size为10px，此时，上面示例中所示的值将会改变：</html></p><pre><code>|  px  |     rem        |-------------------------|  12  | 12/10 = 1.2    ||  14  | 14/10 = 1.4    ||  16  | 16/10 = 1.6    ||  18  | 18/10 = 1.8    ||  20  | 20/10 = 2.0    ||  24  | 24/10 = 2.4    ||  30  | 30/10 = 3.0    ||  36  | 36/10 = 3.6    ||  42  | 42/10 = 4.2    ||  48  | 48/10 = 4.8    |-------------------------        </code></pre><p>由于rem是CSS3中的一个属性，很多人首先关注的就是浏览器对他的支持度，我截了一张caniuse对rem属性的兼容表：<br><img src="http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2013/sass/sass-px-rem-1.jpg" alt="CSS"><br>从上图可以清楚的知道，rem在众多浏览器中都已得到很好的支持，如果您的项目不用考虑IE低版本的话，你就可以放心的使用了，如果您的项目在IE低版本中还占有不少的比例，那么你还在担心使用rem不能兼容，而不敢使用。其实是没有必要的，可以针对低版本的IE浏览器做一定的处理：</p><pre><code>html { font-size: 62.5%; } body { font-size: 14px; font-size: 1.4rem; } /* =14px */h1   { font-size: 24px; font-size: 2.4rem; } /* =24px */    </code></pre><p>这样一来解决了IE低版本的不能兼容的问题，但生出另一个不足地方，就是增加了代码量。必竟鱼和熊掌很多时候不能兼得嘛。</p><div><br>如果你想更深入的了解rem如何使用，建议您阅读：<br><br><br> <a href="http://www.w3cplus.com/css3/define-font-size-with-css3-rem" target="_blank" rel="noopener">CSS3的REM设置字体大小</a>——viaw3cplus<br><br> <a href="http://snook.ca/archives/html_and_css/font-size-with-rem" target="_blank" rel="noopener">FONT SIZING WITH REM</a>——viaJonathan Snook<br><br> <a href="http://css-tricks.com/theres-more-to-the-css-rem-unit-than-font-sizing/" target="_blank" rel="noopener">There’s more to the CSS rem unit than font sizing</a>——viacss-tricks<br><br> <a href="http://techtime.getharvest.com/blog/in-defense-of-rem-units" target="_blank" rel="noopener">In Defense Of Rem Units</a>——viaMatthew Lettini<br><br> <a href="http://csswizardry.com/2011/05/font-sizing-with-rem-could-be-avoided/" target="_blank" rel="noopener">Font sizing with rem could be avoided</a>——viaHarry<br><br> <a href="http://ued.taobao.com/blog/2013/05/rem-font-size/" target="_blank" rel="noopener">响应式十日谈第一日：使用 rem 设置文字大小</a>——via一丝<br></div><h2>为什么要使用rem</h2><p>像em单位一样，在Responsive设计中使用rem单位非常有用。虽然他们都是相对单位，但使用rem单位可以避开很多层级的关系。因为em是相对于他的父元素的font-size，而rem是相对于根元素<html>。比如说h1设置了font-size为1rem之后，只要不重置html的font-size大小，无论他的父元素设置多大，对h1都不会有任何的影响。</html></p><h4>Sass中rem的使用</h4><p>在CSS中，实现px和rem转换非常简单，但每次使用都需进行计算。虽然在html中设置font-size:62.5%;会给大家带来便利，但终究有些烦人，也不是长远之计。既然我们学习了Sass，就应该思考如何让Sass来帮助我们做这些计算的工作。接下来介绍如何使用Sass实现px和rem之间的计算。</p><p>rem在@function中的使用</p><p>Sass中也可以像使用em一样，实现px转换为rem。这个过程也同样是通过Sass的@function方法来实现。</p><p>根据rem的使用原理，可以知道px转rem需要在html根元素设置一个font-size值，因为rem是相对于html根元素。在Sass中定义一个px转rem的函数，先要设置一个默认变量：</p><p>$browser-default-font-size: 16px !default;//变量的值可以根据自己需求定义<br>而且需要在html根元素中显示的声明font-size：</p><pre><code>html {    font-size: $browser-default-font-size;}</code></pre><p>然后通过@function来实现px转为rem计算：</p><pre><code>@function pxTorem($px){//$px为需要转换的字号    @return $px / $browser-default-font-size * 1rem;}</code></pre><p>定义好@function之后，实际使用中就简单多了：</p><pre><code>//SCSShtml {    font-size: $browser-default-font-size;}.header {    font-size: pxTorem(12px);}//CSShtml {  font-size: 16px; }.header {  font-size: 0.75rem; }</code></pre><p>不过定义的这个函数pxTorem()虽然实现了px转换成rem的计算，但不能同时服务于多个属性值的计算：</p><pre><code>.header {    font-size: pxTorem(12px);    margin: pxTorem(5px 10px);//同时计算多个值将报错}</code></pre><p>如果这样使用，编译的时候将会报错：</p><pre><code>&gt;&gt;&gt; Change detected to: /Users/airen/Sites/testSass/style.scss      error style.scss (Line 4: Undefined operation: &quot;5px 10px/16px times 1rem&quot;.)这也就是说，如果样式同时需要设置多个属性值的时候，pxTorem()变得就局限性太大，换句话说，这个函数仅适合运用在具有单个属性值的属性上，例如font-size。如果要强行使用，只能同时使用多个pxTorem()：</code></pre><pre>//SCSS.header {    font-size: pxTorem(12px);    margin: pxTorem(5px) pxTorem(10px) pxTorem(15px);    border: pxTorem(1px) solid #f36;}//CSS.header {  font-size: 0.75rem;  margin: 0.3125rem 0.625rem 0.9375rem;  border: 0.0625rem solid #ff3366; }</pre><h2>Sass中mixin实现rem</h2><p>除了使用@function实现px转换成rem之外，还可以使用Sass中的mixin实现px转rem功能。</p><p>font-size是样式中常见的属性之一，我们先来看一个简单mixin，用来实现font-size的px转rem：</p><pre><code>@mixin font-size($target){    font-size: $target;    font-size: ($target / $browser-default-font-size) * 1rem;}</code></pre><p>在实际使用中，可以通过@include调用定义好的@mixin font-size:</p><pre><code>//SCSS.footer {    @include font-size(12px);}//CSS.footer {  font-size: 12px;  font-size: 0.75rem; }</code></pre><p>可实际中，这个mixin太弱小了，根本无法实现我们需要的效果，因为我们很多样式属性中他可不只一个属性。为了实现多个属性能设置多值，就需要对mixin做出功能扩展：</p><pre><code>@mixin remCalc($property, $values...) {  $max: length($values);//返回$values列表的长度值  $pxValues: &apos;&apos;;  $remValues: &apos;&apos;;  @for $i from 1 through $max {    $value: strip-units(nth($values, $i));//返回$values列表中的第$i个值，并将单位值去掉    $browser-default-font-size: strip-units($browser-default-font-size);    $pxValues: #{$pxValues + $value * $browser-default-font-size}px;    @if $i &lt; $max {      $pxValues: #{$pxValues + &quot; &quot;};    }  }   @for $i from 1 through $max {    $value: strip-units(nth($values, $i));    $remValues: #{$remValues + $value}rem;    @if $i &lt; $max {      $remValues: #{$remValues + &quot; &quot;};    }  }   #{$property}: $pxValues;   #{$property}: $remValues; }</code></pre><p>在这个remCalc()中定义了两个参数$property和$values…。其中$property表示的是样式属性，而$values…表示一个或者多个属性值。</p><p>注：在上面定义的remCalc中使用了下自定义的函数strip-units，主要用来去除单位，详细的请参阅Sass基础——PX to EM Mixin和@function一文中的strip-units函数定义方法。</p><p>px转rem的mixin定义完成后，就可以通过@include来引用：</p><pre><code>//SCSS.wrapper {    @include remCalc(width,45);    @include remCalc(margin,1,.5,2,3);}//CSS.wrapper {  width: 720px;  width: 45rem;  margin: 16px 8px 32px 48px;  margin: 1rem 0.5rem 2rem 3rem; }</code></pre><p>在实际使用中取值有一点非常重要在remCalc()取的$values值为rem值。</p><p>总结</p><p>在这篇文章中，简单介绍了在Sass中如何定义@function和@mixin来实现px转换成rem的计算。希望大家能在这篇文章中找到自己需要的灵感。</p><p> <a href="http://www.w3cplus.com/preprocessor/sass-px-to-rem-with-mixin-and-function.html" target="_blank" rel="noopener">转载自© w3cplus.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Sass基础——Rem与Px的转换
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;rem是CSS3中新增加的一个单位值，他和em单位一样，都是一个相对单位。不同的是em是相对于元素的父元素的font-size进行计算；rem是相对于根元素html的font-size进行计算。这样一来rem就绕开了复杂的层级关系，实现了类似于em单位的功能。&lt;/p&gt;
&lt;h2&gt;Rem的使用&lt;/h2&gt;

&lt;p&gt;前面说了em是相对于其父元素来设置字体大小的，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小，在我们多次使用时，就会带来无法预知的错误风险。而rem是相对于根元素&lt;html&gt;，这样就意味着，我们只需要在根元素确定一个参考值，这个参考值设置为多少，完全可以根据您自己的需求来定。&lt;br&gt;
    
    </summary>
    
    
      <category term="综合" scheme="https://tyty.me/tags/%E7%BB%BC%E5%90%88/"/>
    
      <category term="css3" scheme="https://tyty.me/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>music</title>
    <link href="https://tyty.me/2017/07/18/%E8%AE%A4%E9%94%99/"/>
    <id>https://tyty.me/2017/07/18/认错/</id>
    <published>2017-07-18T10:30:48.000Z</published>
    <updated>2017-12-22T04:11:23.821Z</updated>
    
    <content type="html"><![CDATA[<pre><code>认错-林志炫</code></pre><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27537217&auto=1&height=66"></iframe><pre><code>认错-林志炫I Don&apos;t Believe IT 是我放弃了你只为了一个没有理由的决定以为这次我可以 承受你离我而去故意让你伤心 却刺痛自己一个人常在傍晚七点的台北CITY 等着心痛就像黑夜一样来临I Hate Myself 又整夜追逐梦中的你　而明天只剩哭泣的心怎么才能让我告诉你　我不愿意　教彼此都在孤独里忍住伤心我又怎么告诉你　我还爱你　是我自己错误的决定我要告诉你　我不愿意教彼此都在孤独里忍住伤心我又怎么告诉你　我还爱你　是我自己错误的决定             </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;认错-林志炫
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="综合" scheme="https://tyty.me/tags/%E7%BB%BC%E5%90%88/"/>
    
      <category term="music" scheme="https://tyty.me/tags/music/"/>
    
  </entry>
  
  <entry>
    <title>music</title>
    <link href="https://tyty.me/2017/07/15/%E7%A8%BB%E8%B0%B7/"/>
    <id>https://tyty.me/2017/07/15/稻谷/</id>
    <published>2017-07-14T18:30:48.000Z</published>
    <updated>2017-12-22T04:11:23.821Z</updated>
    
    <content type="html"><![CDATA[<pre><code>我的一个稻谷朋友</code></pre><a id="more"></a><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=437250607&auto=1&height=66"></iframe><br>                                我的一个稻谷朋友</p><pre><code>而你撑伞拥我入怀中一字一句誓言多慎重你眼中有柔情千种如脉脉春风 冰雪也消融那年长街春意正浓策马同游 烟雨如梦檐下躲雨望进一双深邃眼瞳宛如华山夹着细雪的微风雨丝微凉风吹过暗香朦胧一时心头悸动 似你温柔剑锋过处翩若惊鸿是否情字写来都空洞一笔一画斟酌着奉送甘愿卑微换个笑容或沦为平庸而你撑伞拥我入怀中一字一句誓言多慎重你眼中有柔情千种如脉脉春风 冰雪也消融后来谁家喜宴重逢佳人在侧 烛影摇红灯火缱绻映照一双如画颜容宛如豆蔻枝头温柔的旧梦对面不识恍然间思绪翻涌望你白衣如旧神色几分冰冻谁知我心惶恐也许我应该趁醉装疯借你怀抱留一抹唇红再将旧事轻歌慢诵任旁人惊动可我只能假笑扮从容侧耳听那些情深意重不去看你熟悉脸孔只默默饮酒 多无动于衷山门外 雪拂过白衣又在指尖消融负长剑 试问江湖诺大该何去何从今生至此 像个笑话一样自己都嘲讽一厢情愿 有始无终若你早与他人两心同何苦惹我错付了情衷难道看我失魂落魄你竟然心动所幸经年漂浮红尘中这颗心已是千疮百孔怎惧你以薄情为刃添一道裂缝又不会痛不如将往事埋在风中以长剑为碑 以霜雪为冢此生若是错在相逢求一个善终孤身打马南屏旧桥边过恰逢山雨来时雾蒙蒙想起那年伞下轻拥就像躺在桥索之上做了一场梦梦醒后跌落 粉身碎骨无影亦无踪</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;我的一个稻谷朋友
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="综合" scheme="https://tyty.me/tags/%E7%BB%BC%E5%90%88/"/>
    
      <category term="music" scheme="https://tyty.me/tags/music/"/>
    
  </entry>
  
  <entry>
    <title>windows-ubuntu</title>
    <link href="https://tyty.me/2017/06/29/windows-ubuntu/"/>
    <id>https://tyty.me/2017/06/29/windows-ubuntu/</id>
    <published>2017-06-29T05:30:48.000Z</published>
    <updated>2017-12-22T04:11:23.821Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间从windows服务器换到了ubuntu服务器,讲道理ubuntu是真的比<br>windows好用,当然linux的也是类似的,没用过就不多BB,我强烈推荐一波,如果说你正好要买服务器,考虑下linux的系统的服务器,当然你说不会什么shell命令什么都没有关系,跟着视频撸一遍,这样下来新鲜感十足,如有神助。<br><a id="more"></a><br>可能我bb一通,还是觉得没有实例来的痛快,我说下我用的ubuntu的部署的node项目。之前我用的也是windows的服务器,windows服务器本身是没有什么问题的。(只是对我而言)在windows上我采用的是本地更改项目代码然后通过ftp或者qq邮箱(呵呵)但是这两种方式,无论是哪一种都要去远程连接服务器,然后去重启服务,我觉得很麻烦,登来登去的很烦,很偶然看到ubuntu可以通过pm2部署,这样我给大家看下我pm2的代码</p><pre>ecosystem.jsons  {    "apps":[{          "name":"xiaomo",            "script":"app.js",          "env":{            "COMMON_VARIABLE":"true"        },        "env_production":{            "NODE_ENV":"production"        }    }    ],    "deploy":{        "production":{            "user":"wangdabao",            "host":["47.94.153.153"],            "ref":"origin/master",            "repo":"git@git.oschina.net:wangdabaoqq/node-millet.git",            "path":"/www/xiao/production",            "ssh_options":"StrictHostKeyChecking=no",            "post-deploy":"npm install --registry=https://registry.npm.taobao.org && pm2 startOrRestart ecosystem.json --env production",            "env":{                "NODE_ENV":"production"            }        }    }}</pre>   <p>当然我也是按照pm2官网的进行的编写,具体里面代表的意思可以看下pm2官网的部署<a href="http://pm2.keymetrics.io/docs/usage/deployment/" target="_blank" rel="noopener">http://pm2.keymetrics.io/docs/usage/deployment/</a>我也贴下链接,如果有兴趣的可以看下,当然这个必须要配合的是github或者是码云,coding等等我在这里也不说了,因为可以从上面的代码中看到我们的代码是从码云拉取的所以,到这里又有一个问题了私钥或者公钥,当然关于私钥和公钥是和git有关系的,如果你没有配置或者生成可以百度下非常简单,生成完以后要把私钥放到git或者码云的ssh上面,这样写完以后还要在服务器上添加私钥和公钥,一上弄完以后,我们就可以通过命令</p><p><pre><br>git add .<br>git commit -m ‘update’<br>git push origin master<br>由于你是第一次使用所有要先<br>git remote add origin +上你的ssh或者https的git项目地址<br>第一次进行上传<br>pm2 deploy ecosystem.json production setup<br>以后每次都可以直接<br>pm2 deploy ecosystem.json production setup<br></pre></p><p><pre><br><img src="https://qn.tyty.me/Screenshot.png"><br></pre><br>最后我推荐个慕课网上的一个视频叫</p><h3><a href="http://coding.imooc.com/class/95.html" target="_blank" rel="noopener">Node.js项目的线上服务器部署与发布</a></h3><i style="font-weight:bold">看完以后你会有一个全新的了解与认识。</i><p></p><p><b style="font-size:14px; color:red;">↓↓<br>打下广告各位看官老爷们动动小手指给个start,我会继续努力让你们不喜欢的,先谢谢爸爸们,告辞.</b></p><h1><a href="https://github.com/wangdabaoqq/node-millet" target="_blank" rel="noopener">传送门</a></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间从windows服务器换到了ubuntu服务器,讲道理ubuntu是真的比&lt;br&gt;windows好用,当然linux的也是类似的,没用过就不多BB,我强烈推荐一波,如果说你正好要买服务器,考虑下linux的系统的服务器,当然你说不会什么shell命令什么都没有关系,跟着视频撸一遍,这样下来新鲜感十足,如有神助。&lt;br&gt;
    
    </summary>
    
    
      <category term="综合" scheme="https://tyty.me/tags/%E7%BB%BC%E5%90%88/"/>
    
      <category term="服务器" scheme="https://tyty.me/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>技术贴</title>
    <link href="https://tyty.me/2017/04/15/%E6%8A%80%E6%9C%AF%E8%B4%B4/"/>
    <id>https://tyty.me/2017/04/15/技术贴/</id>
    <published>2017-04-15T05:30:48.000Z</published>
    <updated>2017-12-22T04:11:23.821Z</updated>
    
    <content type="html"><![CDATA[<p>###五. 资源教程:</p><p>综合类</p><p>前端知识体系<br>前端知识结构<br>Web前端开发大系概览<br>Web前端开发大系概览-中文版<br>Web Front-end Stack v2.2<br>En类资源汇总<br>免费的编程中文书籍索引<br>前端书籍<br>前端免费书籍大全<br>免费的编程中文书籍索引<br>智能社 - 精通JavaScript开发<br>重新介绍 JavaScript（JS 教程）<br>麻省理工学院公开课：计算机科学及编程导论<br>JavaScript中的this陷阱的最全收集–没有之一<br>JS函数式编程指南<br><a id="more"></a><br>JavaScript Promise迷你书（中文版）<br>腾讯移动Web前端知识库<br>Front-End-Develop-Guide 前端开发指南<br>前端开发笔记本<br>大前端工具集 - 聂微东<br>前端开发者手册<br>前端开发者手册<br>JavaScript 资源大全中文版<br>伯乐在线 - 资源大全<br>伯乐在线 - 前端资源库<br>入门类</p><p>前端入门教程<br>瘳雪峰的Javascript教程<br>jQuery基础教程<br>前端工程师必备的PS技能——切图篇<br>结合个人经历总结的前端入门方法<br>效果类</p><p>弹出层<br>焦点图轮播特效<br>工具类</p><p>css sprite 雪碧图制作<br>版本控制入门 – 搬进 Github<br>Grunt-beginner前端自动化工具<br>慕课专题</p><p>张鑫旭 - 慕课系列<br>lyn - 慕课系列<br>艾伦 - 慕课系列<br>碧仔 - Hello，移动WEB<br>haorooms - js/jquery宽高介绍<br>周刊类</p><p>百度FEX技术周刊<br>平安科技移动开发二队技术周报<br>360奇舞周刊</p><p>###六. API:</p><p>####1. 总目录</p><p>开发中心</p><p>mozilla js参考<br>chrome开发中心（chrome的内核已转向blink）<br>safari开发中心<br>microsoft js参考<br>js秘密花园<br>js秘密花园<br>w3help 综合Bug集合网站<br>综合搜索</p><p>javascripting<br>各种流行库搜索<br>综合API</p><p>runoob.com-包含各种API集合<br>开源中国在线API文档合集<br>devdocs 英文综合API网站<br>devdocs 中文综合API网站<br>overapi 英文综合API网站</p><p>####2. jQuery</p><p>jQuery API 中文文档<br>hemin 在线版<br>css88 jq api<br>css88 jqui api<br>学习jquery<br>jquery 源码查找</p><p>####3. Ecmascript</p><p>Understanding ECMAScript 6 - Nicholas C. Zakas<br>exploring-es6<br>exploring-es6翻译<br>exploring-es6翻译后预览<br>阮一峰 es6<br>阮一峰 Javascript<br>ECMA-262，第 5 版<br>es5</p><p>####4. Js template</p><p>template-chooser<br>artTemplate<br>tomdjs<br>淘宝模板juicer模板<br>Fxtpl v1.0 繁星前端模板引擎<br>laytpl<br>mozilla - nunjucks<br>Juicer<br>dustjs<br>etpl<br>twitter-tpl</p><p>####5. 弹出层</p><p>artDialog 最新版<br>artDialog 文档<br>google code 下载地址<br>贤心弹出层<br>响应式用户交互组件库<br>sweetalert-有css3动画弹出层</p><p>####6. CSS</p><p>CSS 语法参考<br>CSS3动画手册<br>alloyteam - CSS3 UI 库<br>腾讯css3动画制作工具<br>志爷css小工具集合<br>css3 js 移动大杂烩<br>bouncejs 触摸库<br>css3 按钮动画<br>animate.css<br>全局CSS的终结(狗带) [译]<br>ANIMATION - 大漠<br>css选择器</p><p>####7. Angularjs</p><p>Angular.js 的一些学习资源<br>angularjs中文社区<br>Angular Style Guide<br>Angularjs源码学习<br>Angularjs源码学习<br>angular对bootstrap的封装<br>angularjs + nodejs<br>吕大豹 Angularjs<br>AngularJS 最佳实践<br>Angular的一些扩展指令<br>Angular数据绑定原理<br>一些扩展Angular UI组件<br>Ember和AngularJS的性能测试<br>带你走近AngularJS - 基本功能介绍<br>Angularjs开发指南<br>Angularjs学习<br>不要带着jQuery的思维去学习AngularJS<br>angularjs 学习笔记<br>angularjs 开发指南<br>angularjs 英文资料<br>angular bootstrap<br>angular jq mobile<br>angular ui<br>整合jQuery Mobile+AngularJS经验谈<br>有jQuery背景，该如何用AngularJS编程思想<br>AngularJS在线教程<br>angular学习笔记<br>UI Bootstrap - AngularJS directives specific to Bootstrap<br>NG Bootstrap - Angular 2 directives specific to Bootstrap 4</p><p>####8. React</p><p>react海量资源<br>react.js 中文论坛<br>react.js 官方网址<br>react.js 官方文档<br>react.js material UI<br>react.js TouchstoneJS UI<br>react.js amazeui UI<br>React 入门实例教程 - 阮一峰<br>React Native 中文版<br>Webpack 和 React 小书 - 前端乱炖<br>Webpack 和 React 小书 - gitbook<br>React原创实战视频教程<br>React 入门教程<br>react-webpack-starter<br>基于react组件化开发<br>React 编程规范(by Airbnb)<br>React Webpack小说<br>ant.design</p><p>####9. 移动端API</p><p>API<br>99移动端知识集合<br>移动端前端开发知识库<br>移动前端的一些坑和解决方法（外观表现）<br>【原】移动web资源整理<br>zepto 1.0 中文手册<br>zepto 1.0 中文手册<br>zepto 1.1.2<br>zepto 中文注释<br>jqmobile 手册<br>移动浏览器开发集合<br>移动开发大杂烩<br>微信webview中的一些问题<br>框架<br>特色的HTML框架可以创建精美的iOS应用<br>淘宝SUI</p><p>####10. avalon</p><p>avalonjs<br>Avalon新一代UI库： OniUI<br>avalon.oniui-基于avalon的组件库</p><p>####11. Requriejs</p><p>Javascript模块化编程（一）：模块的写法<br>Javascript模块化编程（二）：AMD规范<br>Javascript模块化编程（三）：require.js的用法<br>RequireJS入门（一）<br>RequireJS入门（二）<br>RequireJS进阶（三）<br>requrie源码学习<br>requrie 入门指南<br>requrieJS 学习笔记<br>requriejs 其一<br>require backbone结合</p><p>####12. Seajs</p><p>seajs<br>seajs 中文手册<br>JavaScript模块化开发库之SeaJS</p><p>####13. Less,sass</p><p>sass<br>sass教程-sass中国<br>Sass 中文文档<br>less</p><p>####14. Markdown</p><p>Markdown 语法说明 (简体中文版)<br>markdown入门参考<br>gitbook 国外的在线markdown可编辑成书<br>mdeditor 一款国内的在线markdown编辑器<br>stackedit 国外的在线markdown编辑器，功能强大，同步云盘<br>mditor 一款轻量级的markdown编辑器<br>lepture-editor<br>markdown-editor<br>Markdown 在线编辑器</p><p>####15. D3</p><p>d3 Tutorials<br>Gallery<br>lofter<br>iteye<br>ruanyifeng</p><p>####16. 兼容性</p><p>esma 兼容列表<br>W3C CSS验证服务<br>caniuse<br>csscreator<br>microsoft<br>在线测兼容-移动端<br>emulators</p><p>####17. UI相关</p><p>bootcss<br>MetroUICSS<br>semantic<br>Buttons<br>kitecss<br>pintuer<br>amazeui<br>worldhello<br>linuxtoy<br>gitmagic<br>rogerdudler<br>gitref<br>book<br>gogojimmy</p><p>####18. HTTP</p><p>HTTP API 设计指南</p><p>####19. 其它API</p><p>javascript流行库汇总<br>验证api<br>underscore 中文手册<br>underscore源码分析<br>underscore源码分析-亚里士朱德的博客<br>underscrejs en api<br>lodash - underscore的代替品<br>ext4api<br>backbone 中文手册<br>qwrap手册<br>缓动函数<br>svg 中文参考<br>svg mdn参考<br>svg 导出 canvas<br>svg 导出 png<br>ai-to-svg<br>localStorage 库</p><p>####20. 图表类</p><p>Highcharts 中文API<br>Highcharts 英文API<br>ECharts 百度的图表软件<br>高德地图<br>开源的矢量图脚本框架<br>svg 地图<br>jQuery Vector Map Library</p><p>####21. vue</p><p>Vue<br>Vue 论坛<br>Vue 入门指南<br>Vue 的一些资源索引</p><p>####21. 正则</p><p>JS正则表达式元字符<br>正则表达式30分钟入门教程<br>MDN-正则表达式<br>ruanyifeng - RegExp对象<br>小胡子哥 - 进阶正则表达式<br>is.js<br>正则在线测试<br>haorooms正则文章</p><p>####22. ionic</p><p>ionic</p><p>####23. 其它</p><p>Mock.js 是一款模拟数据生成器<br>jsdoc 注释生成 - apidocjs</p><p>###七. 开发规范</p><p>前端</p><p>通过分析github代码库总结出来的工程师代码书写习惯<br>HTML&amp;CSS编码规范 by @mdo<br>前端编码规范之js - by yuwenhui<br>前端编码规范之js - by 李靖<br>前端开发规范手册<br>Airbnb JavaScript 编码规范（简体中文版）<br>AMD与CMD规范的区别<br>AMD与CMD规范的区别<br>KISSY 源码规范<br>bt编码规范<br>规范加强版<br>前端代码规范 及 最佳实践<br>百度前端规范<br>百度前端规范<br>百度前端规范<br>ECMAScript6 编码规范–广发证券前端团队<br>JavaScript 风格指南/编码规范（Airbnb公司版）<br>网易前端开发规范<br>css模块<br>前端规范资源列表<br>前端JavaScript规范<br>Nodejs</p><p>Node.js 风格指南<br>PHP</p><p>最流行的PHP 代码规范<br>最流行的PHP 代码规范<br>Android</p><p>【敏捷开发】Android团队开发规范<br>Android 开发规范与应用<br>IOS</p><p>Swift Style Guide</p><p>###八. 其它收集</p><p>####1. 各大公司开源项目</p><p>Facebook</p><p>Facebook Projects<br>百度 Baidu</p><p>百度web前端研发部<br>百度EFE<br>百度github<br>腾讯 qq</p><p>alloyteam<br>alloyteam-github<br>alloyteam-AlloyGameEngine<br>AlloyDesigner 即时修改，即时保存，设计稿较正，其它开发辅助工具<br>H5交互页编辑器AEditor介绍 H5动画交互页开发的工具介绍<br>AEditor H5动画交互页开发的工具<br>腾讯html5<br>腾讯开源项目<br>奇舞团</p><p>奇舞团开源项目<br>去哪儿</p><p>Qunar UED<br>其它</p><p>maka<br>值得订阅的weekly</p><p>####2. Javascript</p><p>常用</p><p>ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性<br>模拟键盘<br>拼音<br>中国个人身份证号验证<br>算法</p><p>数据结构与算法 JavaScript 描述. 章节练习<br>常见排序算法（JS版）<br>经典排序<br>常见排序算法-js版本<br>JavaScript 算法与数据结构 精华集<br>面试常考算法题精讲<br>移动端</p><p>fastclick<br>no-click-delay<br>JSON</p><p>模拟生成JSON数据<br>返回跨域JSONAPI</p><p>####3. Html5</p><p>HTML5 有哪些让你惊艳的 demo？<br>html5 Canvas画图系列教程目录</p><p>####4. CSS</p><p>browserhacks</p><p>####5. jQuery</p><p>焦点图</p><p>myfocus<br>myfocus-官方演示站<br>SuperSlidev2.1 – 大话主席<br>soChange</p><p>####6. Ext, EasyUI, J-UI 及其它各种UI方案</p><p>Ext</p><p>extjs<br>ext4英文api<br>ext4中文api<br>EasyUI</p><p>jquery easyui 未压缩源代码<br>J-UI</p><p>J-UI<br>Other</p><p>MUI-最接近原生APP体验的高性能前端框架<br>Amaze UI | 中国首个开源 HTML5 跨屏前端框架<br>淘宝 HTML5 前端框架<br>KISSY - 阿里前端JavaScript库<br>网易Nej - Nice Easy Javascript<br>Kendo UI MVVM Demo<br>Bootstrap<br>Smart UI<br>雅虎UI - CSS UI</p><p>####7. 页面 社会化 分享功能</p><p>百度分享 pc端<br>JiaThis pc端<br>社会化分享组件 移动端<br>ShareSDK 轻松实现社会化功能 移动端<br>友盟分享 移动端<br>addthis 国外社交分享<br>一键分享到各种SNS</p><p>####8. 富文本编辑器</p><p>百度 ueditor<br>经典的ckeditor<br>经典的kindeditor<br>wysiwyg<br>一个有情怀的编辑器。Bach’s Editor<br>tower用的编辑器<br>summernote 编辑器<br>html5编辑器<br>XEditor<br>wangEditor<br>wangEditor-mobile–移动端编辑器<br>Trumbowyg - 轻量编辑器<br>国外的一款编辑器 - tinymce</p><p>####9. 日历</p><p>PC</p><p>经典my97<br>强大的独立日期选择器<br>fullcalendar<br>fullcalendar日历控件知识点集合<br>中文api<br>农历日历<br>超酷的仿百度带节日日历老黄历控件<br>日期格式化<br>大牛日历控件<br>我群某管理作品<br>input按位替换-官网<br>input按位替换-github<br>bootstrap-daterangepicker<br>国外30个插件集合<br>JavaScript datepicker<br>Datepair.js<br>一个风格多样的日历<br>弹出层式的全日历<br>jquery双日历<br>bootstrap-datetimepicker/<br>贤心-laydate<br>Pikaday-微型日历<br>AngularJS datepicker directives<br>周选择日历插件<br>移动</p><p>大气实用jQuery手机移动端日历日期选择插件<br>jQuery Mobile 移动开发中的日期插件Mobiscroll<br>Date library</p><p>Datejs<br>sugarjs</p><p>####10. 综合效果搜索平台</p><p>效果网<br>17素材<br>常用的JavaScript代码片段</p><p>####11. 前端工程化</p><p>概述</p><p>前端工具大全<br>什么是前端工程化<br>Gulp</p><p>Gulp官网<br>Gulp中文网<br>gulp资料收集<br>Gulp：任务自动管理工具 - ruanyifeng<br>Gulp插件<br>Gulp不完全入门教程<br>为什么使用gulp?<br>Gulp安装及配合组件构建前端开发一体化<br>Gulp 入门指南<br>Gulp 入门指南 - nimojs<br>Gulp入门教程<br>Gulp in Action<br>Gulp开发教程（翻译）<br>前端构建工具gulpjs的使用介绍及技巧<br>Grunt</p><p>gruntjs<br>Grunt中文网<br>Grunt入门教程<br>Fis</p><p>fis 官网<br>fis<br>webpack</p><p>webpack<br>Webpack 中文指南<br>Webpack，101入门体验<br>webpack入门教程<br>基于webpack搭建前端工程解决方案探索<br>Webpack傻瓜式指南（一）<br>Webpack指南<br>webpack指南<br>webpack 教程资源收集</p><p>####12. 轮播图</p><p>pc图轮</p><p>单屏轮播sochange<br>左右按钮多图切换<br>fullpage全屏轮播<br>haorooms资源库轮播大全<br>移动端</p><p>无缝切换<br>滑屏效果<br>全屏fullpage<br>单个图片切换<br>单个全屏切换<br>百度的切换库<br>单个全屏切换<br>滑屏效果<br>旋转拖动设置<br>类似于swipe切换<br>支持多种形式的触摸滑动<br>滑屏效果<br>大话主席pc移动图片轮换<br>滑屏效果<br>基于zepto的fullpage<br>[WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应<br>判断微信客户端的那些坑<br>可以通过javascript直接调用原生分享的工具<br>JiaThis 分享到微信代码<br>聊聊移动端跨平台开发的各种技术<br>前端自动化测试<br>多种轮换图片<br>滑动侧边栏</p><p>####13. 文件上传</p><p>百度上传组件<br>上传<br>flash 头像上传<br>图片上传预览<br>图片裁剪<br>图片裁剪-shearphoto<br>jQuery图片处理<br>文件上传</p><p>####14. 模拟select</p><p>糖饼 select<br>flexselect<br>双select<br>select2</p><p>####15. 取色插件</p><p>类似 Photoshop 的界面取色插件<br>jquery color<br>取色插件集合<br>farbtastic 圆环＋正方形</p><p>####16. 城市联动</p><p>jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果<br>移动端省市三级联动demo</p><p>####17. 剪贴板</p><p>剪贴板<br>clipboard 最新的剪切方案</p><p>####18. 简繁转换</p><p>简繁转换</p><p>####19. 表格 Grid</p><p>facebook表格<br>类似于Excel编辑表格-handsontable<br>bootstrap-table插件<br>datatables<br>不错的Grid</p><p>####20. 在线演示</p><p>js 在线编辑 - runjs<br>js 在线编辑 - jsbin<br>js 在线编辑 - codepen<br>js 在线编辑 - jsfiddle<br>phpfiddle<br>java 在线编辑 - ideone<br>js 在线编辑 - hcharts<br>js 在线编辑 - jsdm<br>sql 在线编辑 - sqlfiddle<br>mozilla 在线编辑器</p><p>####21. 播放器</p><p>Html5 VideoPlayer</p><p>####22. 粒子动画</p><p>Proton 烟花</p><p>####23. 表单验证</p><p>Validform<br>formvalidator<br>jQuery formValidator<br>表单验证完美解决方案</p><p>####24. 表单美化</p><p>美化checkbox</p><p>###九. Nodejs</p><p>Node.js 包教不包会<br>篇幅比较少<br>node express 入门教程<br>nodejs定时任务<br>一个nodejs博客<br>【NodeJS 学习笔记04】新闻发布系统<br>过年7天乐，学nodejs 也快乐<br>七天学会NodeJS<br>Nodejs学习笔记（二）— 事件模块<br>nodejs入门<br>angularjs nodejs<br>从零开始nodejs系列文章<br>理解nodejs<br>nodejs事件轮询<br>node入门<br>nodejs cms<br>Node初学者入门，一本全面的NodeJS教程<br>NodeJS的代码调试和性能调优<br>runs Node.js programs through Chromium DevTools</p><p>###十. 性能优化</p><p>常规优化</p><p>Javascript高性能动画与页面渲染<br>移动H5前端性能优化指南<br>5173首页前端性能优化实践<br>给网页设计师和前端开发者看的前端性能优化<br>复杂应用的 CSS 性能分析和优化建议<br>张鑫旭——前端性能<br>前端性能监控总结<br>网站性能优化之CSS无图片技术<br>web前端性能优化进阶路<br>前端技术：网站性能优化之CSS无图片技术<br>浏览器的加载与页面性能优化<br>页面加载中的图片性能优化<br>Hey——前端性能<br>html优化<br>99css——性能<br>Yslow——性能优化<br>YSLOW中文介绍<br>转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化<br>Yahoo!团队实践分享：网站性能<br>网站性能优化指南：什么使我们的网站变慢？<br>网站性能优化实践，减少加载时间，提高用户体验<br>浅谈网站性能优化 前端篇<br>前端重构实践之如何对网站性能优化？<br>前端性能优化：使用媒体查询加载指定大小的背景图片<br>网站性能系列博文<br>加载，不只是少一点点<br>前端性能的测试与优化<br>分享网页加载速度优化的一些技巧？<br>页面加载中的图片性能优化<br>web前端优化(基于Yslow)<br>网站性能优化工具大全<br>【高性能前端1】高性能HTML<br>【高性能前端2】高性能CSS<br>由12306谈谈网站前端性能和后端性能优化<br>AlloyTeam——前端优化<br>毫秒必争，前端网页性能最佳实践<br>网站性能工具Yslow的使用方法<br>前端工程与性能优化（上）：静态资源版本更新与缓存<br>前端工程与性能优化（下）：静态资源管理与模板框架<br>HTTPS连接的前几毫秒发生了什么<br>Yslow<br>Essential Web Performance Metrics — A Primer, Part 1<br>Essential Web Performance Metrics — Part 2<br>YUISlide,针对移动设备的动画性能优化<br>Improving Site Performance<br>让网站提速的最佳前端实践<br>Why Website Speed is Important<br>Need for Speed – How to Improve your Website Performance<br>阿里无线前端性能优化指南 (Pt.1 加载期优化)<br>前端性能优化补充篇<br>优化工具</p><p>JavaScript 性能分析新工具 OneProfile<br>JavaScript 堆内存分析新工具 OneHeap<br>在线工具</p><p>google在线工具<br>阿里测<br>阿里-免费测试服务<br>阿里-F2etest多浏览器兼容性测试解决方案<br>js性能测试<br>轻松玩转PDF</p><p>###十一. 前端架构</p><p>技术架构<br>前端架构<br>如何成为前端架构师<br>关于前端架构-张克军<br>百度腾讯offer比较（腾讯游戏VS百度基础架构）</p><p>###十二. 个人作品</p><p>####1. 推荐作品</p><p>winter代码片段需要翻墙<br>fgm<br>岑安作品集<br>当耐特demo集合<br>米空格 js作品<br>myFocus<br>SeaJS组件库<br>颜海镜作品<br>脚儿网作品<br>javascript个人作品<br>妙味的雷东升游戏作品<br>javascript作品集<br>云五笔，灰度产生生成工具<br>项目主页<br>个性的作品主页<br>ucren js demos 集<br>智能社<br>实例陈列架<br>zoye demo<br>王员外<br>平凡<br>jyg 游戏案例<br>很多jquery插件<br>不羁虫 - soJs 作品系列<br>frozenui<br>黑白棋<br>fromone</p><p>####2. 群员作品</p><p>MDialog - [合肥-M.J]<br>轮播图 - [上海－冷静]<br>[广州—坚壳]<br>[成都 - 无痕]　感恩节专题<br>[球霸天]<br>[北京-小数]<br>[ptf] Magix 工具<br>[杭州-Pft] Magix 基于 MVC 结构和 Hash 驱动的 OPOA（One Page One Application）应用<br>[上海-剧中人]-实验室<br>[上海-豪情 ] 作品集合<br>[成都-feeling]<br>[上海-angela]<br>[海南-hank]作品<br>[上海-张力]博客<br>[上海-zenki]作品<br>移动端图案解锁<br>[合肥-M.J] - MPreview 移动端图片预览组<br>[合肥-M.J] - Mexam 移动端在线做题组<br>[北京-苏瑞] - dancer小人<br>[上海-玄沐]- 个人网站<br>[厦门-二哲]- 个人博客</p><p>####3. 国外大牛精品</p><p>pazguille</p><p>###十三. 简历</p><p>生成</p><p>MarkDown在线简历工具<br>MarkDown在线简历工具<br>模板</p><p>简历<br>张伦<br>简历<br>翁天信<br>动画方式的简历<br>组件丰富简历<br>简历池<br>haorooms博客<br>Justin Young<br>各个程序员简历模板</p><p>###十四. 面试题</p><p>前端</p><p>那几个月在找工作（百度，网易游戏）<br>名企笔试大全<br>2016校招内推 – 阿里巴巴前端 – 三面面试经历<br>年后跳槽那点事：乐视+金山+360面试之行<br>拉勾网js面试题<br>前端面试<br>前端开发面试题<br>百度面试<br>前端工作面试问题<br>前端开发面试题<br>5个经典的前端面试问题<br>如何面试一名前端开发工程师？<br>前端实习生面试总结<br>史上最全 前端开发面试问题及答案整理<br>BAT及各大互联网公司2014前端笔试面试题：JavaScript篇<br>前端开发面试题大收集<br>收集的前端面试题和答案<br>如何面试前端工程师<br>前端开发面试题<br>牛客网-笔试面经<br>Front End Developer Questions<br>40 个重要的 HTML5 面试问题及答案<br>java</p><p>Java工程师笔试题整理[校招篇]</p><p>###十五. iconfont</p><p>中文字体<br>淘宝字库<br>字体<br>制作教程<br>zhangxinxu-icommon<br>icommon<br>用字体在网页中画ICON图标(推荐教程)<br>字体压缩工具 感谢初级群　[深圳-小鱼] 的推荐</p><p>###十六. 开发工具类</p><p>前端开发工具</p><p>IntelliJ IDEA 简体中文专题教程<br>Webstorm,InterllIdea,Phpstorm<br>SublimeText<br>Atom<br>Atom飞行手册（中文版）<br>Atom-vue代码高亮<br>visual studio code<br>visual studio code 使用指南<br>Chrome, Firebug, Filddle 调试</p><p>Fiddler</p><p>Fiddler调式使用知多少(一)深入研究<br>微信fiddle<br>微信fiddle<br>Chrome</p><p>Google Chrome 官方<br>Chrome - 基础<br>Chrome - 进阶<br>Chrome - 性能<br>Chrome - 性能进阶<br>Chrome - 移动<br>Chrome - 使用技巧<br>Chrome - Console控制台不完全指南<br>Chrome - Workspace使浏览器变成IDE<br>network面板<br>chrome开发工具快捷键<br>chrome调试工具常用功能整理<br>Chrome 开发工具 Workspace 使用<br>Chrome神器Vimium快捷键学习记录<br>sass调试-w3cplus<br>如何更专业的使用Chrome开发者工具-w3cplus<br>chrome调试canvas<br>chrome profiles1<br>chrome profiles2<br>chrome profiles3<br>chrome移动版调试<br>chrome调试<br>chrome的调试<br>chrome console 命令详解<br>查看事件绑定1<br>查看事件绑定2<br>神器——Chrome开发者工具(一)<br>奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍)<br>chrome 开发者工具的 15 个小技巧<br>Chrome开发者工具不完全指南<br>Chrome 开发者工具使用技巧<br>Chrome渲染分析之Rendering工具使用(1)<br>Chrome渲染分析之Rendering工具使用(2)<br>Chrome渲染分析之Rendering工具使用(3)<br>像 Sublime Text 一样使用 Chrome DevTools<br>Chorme 35个开发者工具的小技巧<br>Chrome 实用调试技巧<br>Firebug</p><p>firebug视频教程<br>firefox 模拟器<br>console.log 命令详解<br>Firebug入门指南<br>Firebug控制台详解<br>移动,微信调试</p><p>微信调试的那些事<br>微信调试官网<br>微信公众号本地调试<br>微信、手Q、Qzone之x5内核inspect调试解决方案<br>浏览器端调试安卓<br>移动端前端开发调试<br>使用 Chrome 远程调试 Android 设备<br>mac移动端调试<br>mac移动端调试<br>无线调试攻略<br>无线调试攻略<br>屌爆了,完美调试 微信webview(x5)<br>远程console<br>微信调试工具<br>各种真机远程调试方法汇总<br>手机测试自己写的web页面<br>iOS Simulator</p><p>Simulator<br>Xcode中的iOS模拟器(iOS Simulator)的介绍和使用心得<br>img</p><p>loading img<br>智图-图片优化平台<br>在线png优化<br>生成二维码</p><p>生成二维码<br>浏览器同步</p><p>puer<br>liveReload<br>f5<br>File Watchers<br>在线PPT制作</p><p>nodePPT<br>PPT<br>reveal<br>slippy</p><p>###十七. 前端导航网站</p><p>前端导航<br>前端网址导航<br>前端名录<br>前端导航<br>前端开发资源<br>前端开发仓库 - 众多效果的收集地<br>前端资源导航<br>F2E 前端导航<br>前端收藏夹<br>前端导航<br>前端工具箱<br>前端人俱乐部-灵感_Idea<br>haorooms前端导航</p><p>###十八. 常用CDN</p><p>新浪CDN<br>百度静态资源公共库<br>360网站卫士常用前端公共库CDN服务<br>Bootstrap中文网开源项目免费 CDN 服务<br>开放静态文件 CDN - 七牛<br>CDN加速 - jq22<br>jQuery CDN<br>Google jQuery CDN<br>微软CDN</p><p>###十九. Git,SVN,Github</p><p>Git</p><p>git-scm<br>廖雪峰-Git教程<br>git-for-windows<br>GitHub 添加 SSH keys<br>gogithub<br>git常规命令练习<br>git的资料整理<br>我所记录的git命令（非常实用）<br>企业开发git工作流模式探索部分休整<br>GitHub 漫游指南<br>GitHub秘籍<br>使用git和github进行协同开发流程<br>动画方式练习git<br>版本管理工具介绍—Git篇<br>版本控制入门 – 搬进 Github<br>Git动画演示<br>SVN</p><p>版本管理工具介绍—SVN篇</p><p>正文来自<a href="https://github.com/jsfront/src/blob/master/qq.md本文转载" target="_blank" rel="noopener">https://github.com/jsfront/src/blob/master/qq.md本文转载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###五. 资源教程:&lt;/p&gt;
&lt;p&gt;综合类&lt;/p&gt;
&lt;p&gt;前端知识体系&lt;br&gt;前端知识结构&lt;br&gt;Web前端开发大系概览&lt;br&gt;Web前端开发大系概览-中文版&lt;br&gt;Web Front-end Stack v2.2&lt;br&gt;En类资源汇总&lt;br&gt;免费的编程中文书籍索引&lt;br&gt;前端书籍&lt;br&gt;前端免费书籍大全&lt;br&gt;免费的编程中文书籍索引&lt;br&gt;智能社 - 精通JavaScript开发&lt;br&gt;重新介绍 JavaScript（JS 教程）&lt;br&gt;麻省理工学院公开课：计算机科学及编程导论&lt;br&gt;JavaScript中的this陷阱的最全收集–没有之一&lt;br&gt;JS函数式编程指南&lt;br&gt;
    
    </summary>
    
    
      <category term="综合" scheme="https://tyty.me/tags/%E7%BB%BC%E5%90%88/"/>
    
      <category term="技术" scheme="https://tyty.me/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>&#39;福利 - 不过百行代码的爬虫爬取美女图&#39;</title>
    <link href="https://tyty.me/2017/02/14/node%E7%88%AC%E8%99%AB/"/>
    <id>https://tyty.me/2017/02/14/node爬虫/</id>
    <published>2017-02-14T01:54:48.000Z</published>
    <updated>2017-12-22T04:11:23.821Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址:<a href="https://zhuanlan.zhihu.com/p/24730075" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24730075</a><br>最近看到<br>序言</p><p>闲的无聊，看到一个段子网站的美女福利还不错，迫于福利加载太慢看的不过瘾，就想用Nodejs写个简单爬虫全部爬下来看多好….. 此处省略5000字…..</p><p>准备</p><p>要爬，首先得要有目标，我呢，就把目标锁定到了 某哈，然后呢就是用浏览器来分析分析其中的规律</p><p>从中可以看到每一条段子都是一个 .joke-list-item, 当点击下一页的时候 url中地址的最后一位数就表示分页的页码。有些图片是缩略图，我们把缩略图和正常图的地址进行了比较，发现他们的地址格式是一样的，缩略图在small文件夹下，大图在big文件夹下。分析完了我们就可以写代码了。<br><a id="more"></a></p><p>开始</p><p>这个简单爬虫分两个部分，1、获取图片地址。2、进行下载。因为下载是一个耗时的操作，所以两个部分分开了，这样也有利于后期改动。</p><p>导入必要的模块，使用cheerio 是第三方模块，可以使用 npm install cheerio 进行安装</p><p>var http = require(‘http’);            // http 网路<br>var cheerio = require(‘cheerio’);    // html 解析<br>var fs = require(“fs”);                // 流</p><p>var queryHref = “<a href="http://www.haha.mx/topic/1/new/" target="_blank" rel="noopener">http://www.haha.mx/topic/1/new/</a>“;     // 设置被查询的目标网址<br>var querySearch = 1;                                // 设置分页位置</p><p>var urls = [];            // 所有待下载的图片地址</p><p>这个是解析图片地址方法</p><p>/**</p><ul><li>根据url和参数获取分页内容</li><li>@param {String}： url</li><li><p>@param {int}： serach<br>*/<br><pre><br>function getHtml(href, serach) {<br>var pageData = “”;<br>var req = http.get(href + serach, function(res) {<br> res.setEncoding(‘utf8’);<br> res.on(‘data’, function(chunk) {<br>   pageData += chunk;<br> });</pre></p><p> res.on(‘end’, function() {<br>   $ = cheerio.load(pageData);<br>   var html = $(“.joke-list-item .joke-main-content a img”);</p><p>   for(var i = 0; i &lt; html.length; i++) {</p><pre><code>var src = html[i].attribs.src;// 筛选部分广告，不是真的段子if (src.indexOf(&quot;http://image.haha.mx&quot;) &gt; -1) {  urls.push(html[i].attribs.src)}</code></pre><p>   }</p><p> });<br>});<br>}<br><br>这个是下载图片的方法</p></li></ul><p>/**</p><ul><li>下载图片</li><li><p>@param {String} imgurl：图片地址<br>*/<br><pre><br>function downImg(imgurl) {<br>var narr = imgurl.replace(“<a href="http://image.haha.mx/" target="_blank" rel="noopener">http://image.haha.mx/</a>“, “”).split(“/“)</pre></p><p>http.get(imgurl.replace(“/small/“, “/big/“), function(res) {<br> var imgData = “”;<br> //一定要设置response的编码为binary否则会下载下来的图片打不开<br> res.setEncoding(“binary”);   </p><p> res.on(“data”, function(chunk) {<br>   imgData += chunk;<br> });</p><p> res.on(“end”, function() {<br>   var savePath = “./upload/topic1/“ + narr[0]  + narr[1] + narr[2] + “_” + narr[4];<br>   // 保存图片<br>   fs.writeFile(savePath, imgData, “binary”, function(err) {</p><pre><code>if(err) {  console.log(err);}</code></pre><p>   });<br> });<br>});<br>}<br><br>好，到这里核心的东西就写完了，然后就是组装一下，让他运行起来</p></li></ul><p>附一个完整代码：</p><p><pre><br>var http = require(‘http’);            // http 网路<br>var cheerio = require(‘cheerio’);    // html 解析<br>var fs = require(“fs”);                // 流</pre></p><p>var queryHref = “<a href="http://www.haha.mx/topic/1/new/" target="_blank" rel="noopener">http://www.haha.mx/topic/1/new/</a>“;     // 设置被查询的目标网址<br>var querySearch = 1;                                // 设置分页位置<br>var urls = [];</p><p>var sumConut = 0;<br>var reptCount = 0;        // 重复的<br>var downCount = 0;        // 实际下载的</p><p>/**</p><ul><li>根据url和参数获取分页内容</li><li>@param {String}： url</li><li><p>@param {int}： serach<br>*/<br>function getHtml(href, serach) {<br> console.log(“正在获取第 “+serach + “ 页的图片”);<br> var pageData = “”;<br> var req = http.get(href + serach, function(res) {</p><pre><code>res.setEncoding(&apos;utf8&apos;);res.on(&apos;data&apos;, function(chunk) {    pageData += chunk;});res.on(&apos;end&apos;, function() {    $ = cheerio.load(pageData);    var html = $(&quot;.joke-list-item .joke-main-content a img&quot;);    for(var i = 0; i &lt; html.length; i++) {        var src = html[i].attribs.src;        // 筛选部分广告，不是真的段子        if (src.indexOf(&quot;http://image.haha.mx&quot;) &gt; -1) {            urls.push(html[i].attribs.src)        }    }    // 递归调用    if (serach &lt; pagemax) {        getHtml(href, ++serach);    } else {        console.log(&quot;图片链接获取完毕！&quot;);        sumConut = urls.length;        console.log(&quot;链接总数量：&quot; + urls.length);        console.log(&quot;开始下载......&quot;);        downImg(urls.shift());    }});</code></pre><p> });<br>}</p></li></ul><p><br>/**</p><ul><li>下载图片</li><li><p>@param {String} imgurl：图片地址<br>*/<br><pre><br>function downImg(imgurl) {<br> var narr = imgurl.replace(“<a href="http://image.haha.mx/" target="_blank" rel="noopener">http://image.haha.mx/</a>“, “”).split(“/“)<br> // 做一步优化，如果存在文件，则不下载<br> var filename = “./upload/topic1/“ + narr[0]  + narr[1] + narr[2] + “_” + narr[4];<br> fs.exists(filename, function(b){</pre></p><pre><code>if (!b) {    // 文件不存则进行 下载    http.get(imgurl.replace(&quot;/small/&quot;, &quot;/big/&quot;), function(res) {        var imgData = &quot;&quot;;        //一定要设置response的编码为binary否则会下载下来的图片打不开        res.setEncoding(&quot;binary&quot;);         res.on(&quot;data&quot;, function(chunk) {            imgData += chunk;        });        res.on(&quot;end&quot;, function() {            var savePath = &quot;./upload/topic1/&quot; + narr[0]  + narr[1] + narr[2] + &quot;_&quot; + narr[4];            fs.writeFile(savePath, imgData, &quot;binary&quot;, function(err) {                if(err) {                    console.log(err);                }  else {                    console.log(narr[0]  + narr[1] + narr[2] + &quot;_&quot; + narr[4]);                    if (urls.length &gt; 0) {                        downImg(urls.shift());                        downCount++;                        console.log(&quot;剩余图片数量....&quot;);                    }                }            });        });    });} else {    // 统计重复的图片    console.log(&quot;该图片已经存在重复.&quot;);    reptCount++;    if (urls.length &gt; 0) {        downImg(urls.shift());    }}</code></pre><p> });</p><p> if (urls.length &lt;= 0) {</p><pre><code>console.log(&quot;下载完毕&quot;);console.log(&quot;重复图片：&quot; + reptCount);console.log(&quot;实际下载：&quot; + downCount);</code></pre><p> }<br>}</p></li></ul><p>var pagemax = 30;        // 获取到多少页的内容<br>var startindex = 1;        // 从多少页开始获取</p><p>function start(){<br>    console.log(“开始获取图片连接”);<br>    getHtml(queryHref, startindex);<br>}</p><p>start();<br><br>因为nodejs是异步的，所以在 start 方法中的for之后调用下载是不行，这个时候显示的 urls 中是没有数据的。</p><p>所以就是在 getHtml 中 等所有的连接分析完毕之后在调用 downImg，downImg下载完成之后在进行下一个下载。</p><p>项目目录很简单，如图：</p><p>然后我们切换到项目目录，执行 node app , 然后就静静的等待把，每次下载完一个会有对应的文件名打印出来的。</p><p>最后会出现 下载完毕！，之后就……. 你懂得……</p><p>这个是一个很简单的，当然后续你可以加上数据库，数据更新之类的…..</p><p>放几张我爬到的图</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>注意前方高能</p><p>注意前方高能</p><p>注意前方高能</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p><img src="https://qn.tyty.me/20.jpg" alt=""></p><p><img src="https://qn.tyty.me/201.jpg" alt=""></p><p>嘘… 不要告诉别人….</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址:&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24730075&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/24730075&lt;/a&gt;&lt;br&gt;最近看到&lt;br&gt;序言&lt;/p&gt;
&lt;p&gt;闲的无聊，看到一个段子网站的美女福利还不错，迫于福利加载太慢看的不过瘾，就想用Nodejs写个简单爬虫全部爬下来看多好….. 此处省略5000字…..&lt;/p&gt;
&lt;p&gt;准备&lt;/p&gt;
&lt;p&gt;要爬，首先得要有目标，我呢，就把目标锁定到了 某哈，然后呢就是用浏览器来分析分析其中的规律&lt;/p&gt;
&lt;p&gt;从中可以看到每一条段子都是一个 .joke-list-item, 当点击下一页的时候 url中地址的最后一位数就表示分页的页码。有些图片是缩略图，我们把缩略图和正常图的地址进行了比较，发现他们的地址格式是一样的，缩略图在small文件夹下，大图在big文件夹下。分析完了我们就可以写代码了。&lt;br&gt;
    
    </summary>
    
    
      <category term="web" scheme="https://tyty.me/tags/web/"/>
    
      <category term="node" scheme="https://tyty.me/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>&#39;深入理解正则&#39;</title>
    <link href="https://tyty.me/2017/01/14/%E6%AD%A3%E5%88%99/"/>
    <id>https://tyty.me/2017/01/14/正则/</id>
    <published>2017-01-14T07:54:48.000Z</published>
    <updated>2017-12-22T04:11:23.821Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址:<a href="http://www.cnblogs.com/China3S/archive/2013/11/30/3451971.html" target="_blank" rel="noopener">深入理解正则表达式</a><br>一 前言</p><p>　　对于正则表达式，相信很多人都知道，但是很多人的第一感觉就是难学，因为看第一眼时，觉得完全没有规律可寻，而且全是一堆各种各样的特殊符号，完全不知所云。</p><p>其实只是对正则不了解而以，了解了你就会发现，原来就这样啊正则所用的相关字符其实不多，也不难记，更不难懂，唯一难的就是组合起来之后，可读性比较差，而且不容易理解，本文旨在让大家对正则有一个基本的了解，能看得懂简单的正则表达式，写得出简单的正则表达式，用以满足日常开发中的需求即可。</p><p>0\d{2}-\d{8}|0\d{3}-\d{7} 先来一段正则，如果你对正则不了解，是不是完全不知道这一串字符是什么意思？这不要紧文章会详细解释每个字符的含义的。</p> <a id="more"></a><p>1.1 什么是正则表达式</p><pre><code>正则表达式是一种特殊的字符串模式，用于匹配一组字符串，就好比用模具做产品，而正则就是这个模具，定义一种规则去匹配符合规则的字符。</code></pre><p>1.2 常用的正则匹配工具 </p><pre><code>在线匹配工具：</code></pre><p>　　1 <a href="http://www.regexpal.com/" target="_blank" rel="noopener">http://www.regexpal.com/</a> </p><pre><code> 2 http://rubular.com/ 正则匹配软件 McTracer  用过几个之后还是觉得这个是最好用的，支持将正则导成对应的语言如java C# js等还帮你转义了，Copy直接用就行了很方便，另外支持把正则表达式用法解释，如哪一段是捕获分组，哪段是贪婪匹配等等，总之用起来 So Happy .</code></pre><p>二 正则字符简单介绍</p><p>2.1 元字符介绍</p><p>   “^” ：^会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。 </p><p>   “$”  ：$会匹配行或字符串的结尾<br>如图</p><pre><code>而且被匹配的字符必须是以This开头有空格也不行，必须以Regex结尾，也不能有空格与其它字符</code></pre><p><img src="http://images.cnitblog.com/blog/366784/201311/23112422-56df0ef3f54c42abb55e7cabd5278824.png" alt=""><br> “\b” :不会消耗任何字符只匹配一个位置，常用于匹配单词边界 如 我想从字符串中”This is Regex”匹配单独的单词 “is” 正则就要写成 “\bis\b”  </p><p>　　  \b 不会匹配is 两边的字符，但它会识别is 两边是否为单词的边界 </p><p> “\d”: 匹配数字，</p><p>　　  例如要匹配一个固定格式的电话号码以0开头前4位后7位，如0737-5686123  正则:^0\d\d\d-\d\d\d\d\d\d\d$ 这里只是为了介绍”\d”字符，实际上有更好的写法会在     下面介绍。</p><p> “\w”：匹配字母，数字，下划线.</p><p>　　  例如我要匹配”a2345BCD__TTz” 正则：”\w+”  这里的”+”字符为一个量词指重复的次数，稍后会详细介绍。</p><p> “\s”：匹配空格 </p><p>　　  例如字符 “a b c” 正则：”\w\s\w\s\w”  一个字符后跟一个空格，如有字符间有多个空格直接把”\s” 写成 “\s+” 让空格重复</p><p>  “.”：匹配除了换行符以外的任何字符</p><p>　　  这个算是”\w”的加强版了”\w”不能匹配 空格 如果把字符串加上空格用”\w”就受限了，看下用 “.”是如何匹配字符”a23 4 5 B C D__TTz”  正则：”.+”</p><p>  “[abc]”: 字符组  匹配包含括号内元素的字符 </p><pre><code>这个比较简单了只匹配括号内存在的字符，还可以写成[a-z]匹配a至z的所以字母就等于可以用来控制只能输入英文了，</code></pre><p>2.2 几种反义</p><p>　　写法很简单改成大写就行了，意思与原来的相反，这里就不举例子了</p><p>   “\W”   匹配任意不是字母，数字，下划线 的字符</p><p>   “\S”   匹配任意不是空白符的字符</p><p>　“\D”  匹配任意非数字的字符</p><p>   “\B”  匹配不是单词开头或结束的位置</p><p>   “[^abc]”  匹配除了abc以外的任意字符</p><p> 2.3  量词</p><p>　　先解释关于量词所涉及到的重要的三个概念</p><pre><code>贪婪(贪心) 如&quot;*&quot;字符 贪婪量词会首先匹配整个字符串，尝试匹配时，它会选定尽可能多的内容，如果 失败则回退一个字符，然后再次尝试回退的过程就叫做回溯，它会每次回退一个字符，直到找到匹配的内容或者没有字符可以回退。相比下面两种贪婪量词对资源的消耗是最大的，</code></pre><p>   懒惰(勉强) 如 “?”  懒惰量词使用另一种方式匹配，它从目标的起始位置开始尝试匹配，每次检查一个字符，并寻找它要匹配的内容，如此循环直到字符结尾处。</p><p>   占有  如”+” 占有量词会覆盖事个目标字符串，然后尝试寻找匹配内容 ，但它只尝试一次，不会回溯，就好比先抓一把石头，然后从石头中挑出黄金</p><pre><code>&quot;*&quot;(贪婪)   重复零次或更多</code></pre><p>　　　  例如”aaaaaaaa” 匹配字符串中所有的a  正则： “a*”   会出到所有的字符”a”</p><pre><code>&quot;+&quot;(懒惰)   重复一次或更多次</code></pre><p>　　     例如”aaaaaaaa” 匹配字符串中所有的a  正则： “a+”  会取到字符中所有的a字符，  “a+”与”a<em>“不同在于”+”至少是一次而”</em>“ 可以是0次，</p><p>　　     稍后会与”?”字符结合来体现这种区别</p><pre><code>&quot;?&quot;(占有)   重复零次或一次</code></pre><p>　　     例如”aaaaaaaa” 匹配字符串中的a 正则 ： “a?” 只会匹配一次，也就是结果只是单个字符a</p><p>　  “{n}”  重复n次</p><p>　　     例如从”aaaaaaaa” 匹配字符串的a 并重复3次 正则：  “a{3}”  结果就是取到3个a字符  “aaa”;</p><p>　  “{n,m}”  重复n到m次</p><p>　　     例如正则 “a{3,4}” 将a重复匹配3次或者4次 所以供匹配的字符可以是三个”aaa”也可以是四个”aaaa” 正则都可以匹配到</p><pre><code>&quot;{n,}&quot;  重复n次或更多次</code></pre><p> 　　    与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则”a{3,}” a至少要重复3次</p><p> 把量词了解了之后之前匹配电话号码的正则现在就可以改得简单点了^0\d\d\d-\d\d\d\d\d\d\d可以改为”0\d+−\d7可以改为”0\d+−\d7”。</p><p>这样写还不够完美如果因为前面的区号没有做限定，以至于可以输入很多们，而通常只能是3位或者4位，</p><p>现在再改一下 “^0\d{2,3}-\d{7}”如此一来区号部分就可以匹配3位或者4位的了</p><p> 2.4 懒惰限定符</p><p>　　“*?”   重复任意次，但尽可能少重复 </p><p>　　    如 “acbacb”  正则  “a.*?b” 只会取到第一个”acb” 原本可以全部取到但加了限定符后，只会匹配尽可能少的字符 ，而”acbacb”最少字符的结果就是”acb” </p><p>　　“+?”  重复1次或更多次，但尽可能少重复</p><p>　　   与上面一样，只是至少要重复1次</p><p>　　“??”  重复0次或1次，但尽可能少重复</p><p>　　    如 “aaacb” 正则 “a.??b” 只会取到最后的三个字符”acb”</p><p>　　“{n,m}?”  重复n到m次，但尽可能少重复</p><pre><code>如 &quot;aaaaaaaa&quot;  正则 &quot;a{0,m}&quot; 因为最少是0次所以取到结果为空</code></pre><p>　　“{n,}?”    重复n次以上，但尽可能少重复</p><pre><code>如 &quot;aaaaaaa&quot;  正则 &quot;a{1,}&quot; 最少是1次所以取到结果为 &quot;a&quot;</code></pre><p>三  正则进阶</p><pre><code>3.1 捕获分组</code></pre><p>　　先了解在正则中捕获分组的概念，其实就是一个括号内的内容 如 “(\d)\d” 而”(\d)” 这就是一个捕获分组，可以对捕获分组进行 后向引用 (如果后而有相同的内容则可以直接引用前面定义的捕获组，以简化表达式) 如(\d)\d\1 这里的”\1”就是对”(\d)”的后向引用</p><p>那捕获分组有什么用呢看个例子就知道了</p><p>如  “zery zery” 正则 \b(\w+)\b\s\1\b 所以这里的”\1”所捕获到的字符也是 与(\w+)一样的”zery”，为了让组名更有意义，组名是可以自定义名字的</p><p>“\b(?<name>\w+)\b\s\k<name>\b” 用”?<name>“就可以自定义组名了而要后向引用组时要记得写成 “\k<name>“;自定义组名后,捕获组中匹配到的值就会保存在定义的组名里</name></name></name></name></p><p>下面列出捕获分组常有的用法</p><p>“(exp)”    匹配exp,并捕获文本到自动命名的组里</p><p>“(?<name>exp)”   匹配exp,并捕获文本到名称为name的组里</name></p><p>“(?:exp)”  匹配exp,不捕获匹配的文本，也不给此分组分配组号</p><p>以下为零宽断言</p><p>“(?=exp)”  匹配exp前面的位置</p><p>　　如 “How are you doing” 正则”(?<txt>.+(?=ing))” 这里取ing前所有的字符，并定义了一个捕获分组名字为 “txt” 而”txt”这个组里的值为”How are you do”;</txt></p><p>“(?&lt;=exp)”  匹配exp后面的位置</p><p>　　如 “How are you doing” 正则”(?<txt>(?&lt;=How).+)” 这里取”How”之后所有的字符，并定义了一个捕获分组名字为 “txt” 而”txt”这个组里的值为” are you doing”;</txt></p><p>“(?!exp)”  匹配后面跟的不是exp的位置</p><p>　　如 “123abc” 正则 “\d{3}(?!\d)”匹配3位数字后非数字的结果</p><p>“(?&lt;!exp)”  匹配前面不是exp的位置</p><p>　　如 “abc123 “ 正则 “(?&lt;![0-9])123” 匹配”123”前面是非数字的结果也可写成”(?!&lt;\d)123”</p><p>四  正则实战</p><p>　　正则在做验证，与数据过滤时体现的威力是巨大的，我想用过的朋友都知道，下面我们把刚刚了解的全部结合起来做一次实战 做数据采集用正则过滤Html标签并取相应的数据</p><p>我们的战场就选在博客园吧，假设现在要采集博客园首页的所有文章信息 包括文章标题，链接接 作者博客地址，文章简介，文章发布时间，阅读数据，评论数 ，推荐数。</p><p>先看博客园文章的Html格式</p><p>通过构造一个Http请求来取到数据并对数据进行相应处理得到关键信息，在过滤Html标签取文章时正则的强大的威力就体现出来了，</p><p>正则的知识点也都基本用上了比如 “\s \w+ . * ? “还有捕获分组，零宽断言等等。喜欢的朋友可以试一试，然后自己看如何通过正则取相应数据的，代码中的正则都是很基本简单的，其意思与用法都在上文中详细写了。</p><pre><code> class Program{    static void Main(string[] args)    {        string content = HttpUtility.HttpGetHtml();        HttpUtility.GetArticles(content);    }}internal class HttpUtility{    //默认获取第一页数据    public static string HttpGetHtml()    {        HttpWebRequest request = (HttpWebRequest)WebRequest.Create(&quot;http://www.cnblogs.com/&quot;);        request.Accept = &quot;text/plain, */*; q=0.01&quot;;        request.Method = &quot;GET&quot;;        request.Headers.Add(&quot;Accept-Language&quot;, &quot;zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3&quot;);        request.ContentLength = 0;        request.Host = &quot;www.cnblogs.com&quot;;        request.UserAgent = &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.1 (KHTML, like Gecko) Maxthon/4.1.3.5000 Chrome/26.0.1410.43 Safari/537.1&quot;;        HttpWebResponse response = (HttpWebResponse)request.GetResponse();        Stream responStream = response.GetResponseStream();        StreamReader reader = new StreamReader(responStream, Encoding.UTF8);        string content = reader.ReadToEnd();        return content;    }    public static List&lt;Article&gt; GetArticles(string htmlString)    {        List&lt;Article&gt; articleList = new List&lt;Article&gt;();        Regex regex = null;        Article article = null;        regex = new Regex(&quot;&lt;div class=\&quot;post_item\&quot;&gt;(?&lt;content&gt;.*?)(?=&lt;div class=\&quot;clear\&quot;&gt;&quot; + @&quot;&lt;/div&gt;\s*&lt;/div&gt;)&quot;,                          RegexOptions.Singleline);        if (regex.IsMatch(htmlString))        {            MatchCollection aritcles = regex.Matches(htmlString);            foreach (Match item in aritcles)            {                article = new Article();                //取推荐                regex =                    new Regex(                        &quot;&lt;div class=\&quot;digg\&quot;&gt;.*&lt;span.*&gt;(?&lt;digNum&gt;.*)&quot; + @&quot;&lt;/span&gt;&quot; +                        &quot;.*&lt;div class=\&quot;post_item_body\&quot;&gt;&quot;, RegexOptions.Singleline);                article.DiggNum = regex.Match(item.Value).Groups[&quot;digNum&quot;].Value;                //取文章标题 需要去除转义字符                regex = new Regex(&quot;&lt;h3&gt;(?&lt;a&gt;.*)&lt;/h3&gt;&quot;, RegexOptions.Singleline);                string a = regex.Match(item.Value).Groups[&quot;a&quot;].Value;                regex = new Regex(&quot;&lt;a\\s.*href=\&quot;(?&lt;href&gt;.*?)\&quot;.*&gt;(?&lt;summary&gt;.*)&lt;/a&gt;&quot;, RegexOptions.Singleline);                article.AritcleUrl = regex.Match(a).Groups[&quot;href&quot;].Value;                article.AritcleTitle = regex.Match(a).Groups[&quot;summary&quot;].Value;                //取作者图片                 regex = new Regex(&quot;&lt;a.*&gt;(?&lt;img&gt;&lt;img[^&gt;].*&gt;)&lt;/a&gt;&quot;, RegexOptions.Singleline);                article.AuthorImg = regex.Match(item.Value).Groups[&quot;img&quot;].Value;                //取作者博客URL及链接的target属性                regex = new Regex(&quot;&lt;a\\s*?href=\&quot;(?&lt;href&gt;.*)\&quot;\\s*?target=\&quot;(?&lt;target&gt;.*?)\&quot;&gt;.*&lt;/a&gt;&quot;,                                  RegexOptions.Singleline);                article.AuthorUrl = regex.Match(item.Value).Groups[&quot;href&quot;].Value;                string urlTarget = regex.Match(item.Value).Groups[&quot;target&quot;].Value;                //取文章简介                //1 先取summary Div中所有内容                regex = new Regex(&quot;&lt;p class=\&quot;post_item_summary\&quot;&gt;(?&lt;summary&gt;.*)&lt;/p&gt;&quot;, RegexOptions.Singleline);                string summary = regex.Match(item.Value).Groups[&quot;summary&quot;].Value;                //2 取简介                regex = new Regex(&quot;(?&lt;indroduct&gt;(?&lt;=&lt;/a&gt;).*)&quot;, RegexOptions.Singleline);                article.AritcleInto = regex.Match(summary).Groups[&quot;indroduct&quot;].Value;                //取发布人与发布时间                regex =                    new Regex(                        &quot;&lt;div class=\&quot;post_item_foot\&quot;&gt;\\s*&lt;a.*?&gt;(?&lt;publishName&gt;.*)&lt;/a&gt;(?&lt;publishTime&gt;.*)&lt;span class=\&quot;article_comment\&quot;&gt;&quot;,                        RegexOptions.Singleline);                article.Author = regex.Match(item.Value).Groups[&quot;publishName&quot;].Value;                article.PublishTime = regex.Match(item.Value).Groups[&quot;publishTime&quot;].Value.Trim();                //取评论数                regex =                    new Regex(                        &quot;&lt;span class=\&quot;article_comment\&quot;&gt;&lt;a.*&gt;(?&lt;comment&gt;.*)&lt;/a&gt;&lt;/span&gt;&lt;span class=\&quot;article_view\&quot;&gt;&quot;,                        RegexOptions.Singleline);                article.CommentNum = regex.Match(item.Value).Groups[&quot;comment&quot;].Value;                //取阅读数                regex = new Regex(&quot;&lt;span\\s*class=\&quot;article_view\&quot;&gt;&lt;a.*&gt;(?&lt;readNum&gt;.*)&lt;/a&gt;&quot;, RegexOptions.Singleline);                article.ReadNum = regex.Match(item.Value).Groups[&quot;readNum&quot;].Value;                articleList.Add(article);            }        }        return articleList;    }    public static string ClearSpecialTag(string htmlString)    {        string htmlStr = Regex.Replace(htmlString, &quot;\n&quot;, &quot;&quot;, RegexOptions.IgnoreCase);        htmlStr = Regex.Replace(htmlStr, &quot;\t&quot;, &quot;&quot;, RegexOptions.IgnoreCase);        htmlStr = Regex.Replace(htmlStr, &quot;\r&quot;, &quot;&quot;, RegexOptions.IgnoreCase);        htmlStr = Regex.Replace(htmlStr, &quot;\&quot;&quot;, &quot;&apos;&quot;, RegexOptions.IgnoreCase);        return htmlStr;    }}public class Article{    /// &lt;summary&gt;    /// 文章标题    /// &lt;/summary&gt;    public string AritcleTitle { get; set; }    /// &lt;summary&gt;    /// 文章链接    /// &lt;/summary&gt;    public string AritcleUrl { get; set; }    /// &lt;summary&gt;    /// 文章简介    /// &lt;/summary&gt;    public string AritcleInto { get; set; }    /// &lt;summary&gt;    /// 作者名    /// &lt;/summary&gt;    public string Author { get; set; }    /// &lt;summary&gt;    /// 作者地址    /// &lt;/summary&gt;    public string AuthorUrl { get; set; }    /// &lt;summary&gt;    /// 作者图片    /// &lt;/summary&gt;    public string AuthorImg { get; set; }    /// &lt;summary&gt;    /// 发布时间    /// &lt;/summary&gt;    public string PublishTime { get; set; }    /// &lt;summary&gt;    /// 推荐数    /// &lt;/summary&gt;    public string DiggNum { get; set; }    /// &lt;summary&gt;    /// 评论数    /// &lt;/summary&gt;    public string CommentNum { get; set; }    /// &lt;summary&gt;    /// 阅读数    /// &lt;/summary&gt;    public string ReadNum { get; set; }}</code></pre><p>正则部分可能写得不很完美，但至少也匹配出来了，另外因为自己也是刚接触正则，也只能写出这种比较简单的正则。还望大家海涵~~</p><h1>转载自<a href="http://www.cnblogs.com/China3S/archive/2013/11/30/3451971.html" target="_blank" rel="noopener">作者赖格英</a></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址:&lt;a href=&quot;http://www.cnblogs.com/China3S/archive/2013/11/30/3451971.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入理解正则表达式&lt;/a&gt;&lt;br&gt;一 前言&lt;/p&gt;
&lt;p&gt;　　对于正则表达式，相信很多人都知道，但是很多人的第一感觉就是难学，因为看第一眼时，觉得完全没有规律可寻，而且全是一堆各种各样的特殊符号，完全不知所云。&lt;/p&gt;
&lt;p&gt;其实只是对正则不了解而以，了解了你就会发现，原来就这样啊正则所用的相关字符其实不多，也不难记，更不难懂，唯一难的就是组合起来之后，可读性比较差，而且不容易理解，本文旨在让大家对正则有一个基本的了解，能看得懂简单的正则表达式，写得出简单的正则表达式，用以满足日常开发中的需求即可。&lt;/p&gt;
&lt;p&gt;0\d{2}-\d{8}|0\d{3}-\d{7} 先来一段正则，如果你对正则不了解，是不是完全不知道这一串字符是什么意思？这不要紧文章会详细解释每个字符的含义的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web" scheme="https://tyty.me/tags/web/"/>
    
      <category term="正则" scheme="https://tyty.me/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
</feed>
